#!/bin/sh
# SPDX-License-Identifier: BSD-2-Clause
# Copyright (C) 2021-2025 Dimitar Yurukov <mscalindt@protonmail.com>
#
# syscfg - declarative OS configuration
#
# Table of syscfg-defined error codes:
# ---
# (1): EERROR: "General operation error".
# ---
# STANDARD:
# (1): EPERM: "Operation not permitted".
# (2): ENOENT: "No such file or directory".
# (17): EEXIST: "Already exists".
# (20): ENOTDIR: "Not a directory".
# (21): EISDIR: "Is a directory".
# (22): EINVAL: "Invalid argument".
# ---
# SPECIAL CUSTOM:
# (255): Bad function input/usage error.

# Maintainer note for any functions in assertive_functions():
#
# Assertive functions shall not return `255` on empty input, and instead,
# simply return true/false appropriately. `255` is only returned when input is
# unspecified. If a function cannot adhere to the aforementioned, it does not
# belong in assertive_functions().
assertive_functions() { # START assertive_functions
    :
} # END assertive_functions

helper_functions() { # START helper_functions
    :
} # END helper_functions

# Maintainer note for any functions in utility_functions():
#
# Utility functions shall always begin with two underscore characters.
utility_functions() { # START utility_functions
    :
} # END utility_functions

# Maintainer note for any functions in utility_functions_err():
#
# Utility error functions shall always begin with an underscore character.
utility_functions_err() { # START utility_functions_err
    :
} # END utility_functions_err

# Maintainer note for any functions in utility_functions_out():
#
# Utility output functions shall always begin with an underscore character.
utility_functions_out() { # START utility_functions_out
#! .desc:
# Print formatted text to stderr (syscfg client string)
#! .params:
# <$1> - color(
#     '-'  - none
#     '-black' - bold (`1;`) foreground (`3X`) black (`0`)
#     '-red' - bold (`1;`) foreground (`3X`) red (`1`)
#     '-green' - bold (`1;`) foreground (`3X`) green (`2`)
#     '-yellow' - bold (`1;`) foreground (`3X`) yellow (`3`)
#     '-blue' - bold (`1;`) foreground (`3X`) blue (`4`)
#     '-magenta' - bold (`1;`) foreground (`3X`) magenta (`5`)
#     '-cyan' - bold (`1;`) foreground (`3X`) cyan (`6`)
#     '-white' - bold (`1;`) foreground (`3X`) white (`7`)
#     .
# )
# <$2> - format(
#     '-' - raw
#     '--' - raw; no <newline>
#     .
# )
# <"$3">+ - text
#! .uses.var.err:
# [NO_COLOR] $ - environment variable;
#                disable color
#! .uses.fn:
# <err> ('$@');
#       Print formatted text
#! .rc.fn:
# (err) (0) success
# (err) (*) error
#! .desc.ext:
# The colors are bold, foreground text, escape sequences of ANSI.
#
# The usage of color results in undefined behavior. For strict POSIX
# compatibility, specify `-` for $1 or set variable `NO_COLOR`
# to a non-empty value.
#.
_err() {
    _clr="$1"
    _fmt="$2"

    shift 2 && set -- "$_clr" "$_fmt" "[E $$ $opd]" "$@"

    err "$@"
}

#! .desc:
# Print formatted text to stdout (syscfg client string)
#! .params:
# <$1> - color(
#     '-'  - none
#     '-black' - bold (`1;`) foreground (`3X`) black (`0`)
#     '-red' - bold (`1;`) foreground (`3X`) red (`1`)
#     '-green' - bold (`1;`) foreground (`3X`) green (`2`)
#     '-yellow' - bold (`1;`) foreground (`3X`) yellow (`3`)
#     '-blue' - bold (`1;`) foreground (`3X`) blue (`4`)
#     '-magenta' - bold (`1;`) foreground (`3X`) magenta (`5`)
#     '-cyan' - bold (`1;`) foreground (`3X`) cyan (`6`)
#     '-white' - bold (`1;`) foreground (`3X`) white (`7`)
#     .
# )
# <$2> - format(
#     '-' - raw
#     '--' - raw; no <newline>
#     .
# )
# <"$3">+ - text
#! .uses.var.info:
# [NO_COLOR] $ - environment variable;
#                disable color
#! .uses.fn:
# <info> ('$@');
#        Print formatted text
#! .rc:
# (info) (0) success
# (info) (*) error
#! .desc.ext:
# The colors are bold, foreground text, escape sequences of ANSI.
#
# The usage of color results in undefined behavior. For strict POSIX
# compatibility, specify `-` for $1 or set variable `NO_COLOR`
# to a non-empty value.
#.
_info() {
    _clr="$1"
    _fmt="$2"

    shift 2 && set -- "$_clr" "$_fmt" "[I $$ $opd]" "$@"

    info "$@"
}
} # END utility_functions_out

# START boilerplate_functions

#! .desc:
# Restore the old state of IFS
#! .rc:
# (0) success
# (*) error
#.
IFS_restore() {
    IFS="$_old_IFS" 2> /dev/null
    ${_old_IFS+':'} unset IFS 2> /dev/null
}

#! .desc:
# Save the current state of IFS
#! .rc:
# (0) success
# (*) error
#.
IFS_save() {
    _old_IFS="$IFS" 2> /dev/null
    ${IFS+':'} unset _old_IFS 2> /dev/null
}

#! .desc:
# Check if a command exists
#! .params:
# <"$1"> - command
#! .rc:
# (0) yes
# (*) no
# (255) bad input
#.
cmd() {
    assert -eq "$#" 1 || return 255

    command -v "$1" > /dev/null 2>&1
}

#! .desc:
# Check if a given path is a directory
#! .params:
# <"$1"> - path
#! .rc:
# (0) yes
# (1) no
# (255) bad input
#.
dir() {
    assert -eq "$#" 1 || return 255

    [ -d "$1" ]
}

#! .desc:
# Check if a given path exists
#! .params:
# <"$1"> - path
#! .rc:
# (0) yes
# (1) no
# (255) bad input
#.
exist() {
    assert -eq "$#" 1 || return 255

    [ -e "$1" ]
}

#! .desc:
# Check if a given path is a regular file
#! .params:
# <"$1"> - path
#! .rc:
# (0) yes
# (1) no
# (255) bad input
#.
file() {
    assert -eq "$#" 1 || return 255

    [ -f "$1" ]
}

#! .desc:
# Check if a given string is entirely octal
#! .params:
# <"$1"> - string
#! .rc:
# (0) yes
# (1) no
# (*) error
# (255) bad input
#.
is_octal() {
    assert -eq "$#" 1 || return 255

    IFS_save;

    IFS="$LF"' '; for _octal in $1; do
        case "$_octal" in
            *[!0123456789]*) IFS_restore; return 1 ;;
        esac
    done

    IFS_restore;
}

#! .desc:
# Check if the system is booted in UEFI mode
#! .rc:
# (0) yes
# (1) no
#.
is_uefi() {
    dir '/sys/firmware/efi/efivars'
}

#! .desc:
# Check if a given path is readable
#! .params:
# <"$1"> - path
#! .rc:
# (0) yes
# (1) no
# (255) bad input
#.
readable() {
    assert -eq "$#" 1 || return 255

    [ -r "$1" ]
}

#! .desc:
# Check if text appears anywhere in a given string
#! .params:
# <"$1"> - text
# <"$2"> - string
#! .rc:
# (0) yes
# (1) no
# (255) bad input
#.
str() {
    assert -eq "$#" 2 || return 255

    case "$2" in
        *"$1"*) return 0 ;;
    esac

    return 1
}

#! .desc:
# Check if text appears at the left side of a given string
#! .params:
# <"$1"> - text
# <"$2"> - string
#! .rc:
# (0) yes
# (1) no
# (255) bad input
#.
str_pfix() {
    assert -eq "$#" 2 || return 255

    case "$2" in
        "$1"*) return 0 ;;
    esac

    return 1
}

#! .desc:
# Check if text appears at the right side of a given string
#! .params:
# <"$1"> - text
# <"$2"> - string
#! .rc:
# (0) yes
# (1) no
# (255) bad input
#.
str_sfix() {
    assert -eq "$#" 2 || return 255

    case "$2" in
        *"$1") return 0 ;;
    esac

    return 1
}

#! .desc:
# Check if a given path is writable
#! .params:
# <"$1"> - path
#! .rc:
# (0) yes
# (1) no
# (255) bad input
#.
writable() {
    assert -eq "$#" 1 || return 255

    [ -w "$1" ]
}

# END boilerplate_functions
# START output_functions

#! .desc:
# Print formatted text to stderr
#! .params:
# <$1> - color(
#     '-'  - none
#     '-black' - bold (`1;`) foreground (`3X`) black (`0`)
#     '-red' - bold (`1;`) foreground (`3X`) red (`1`)
#     '-green' - bold (`1;`) foreground (`3X`) green (`2`)
#     '-yellow' - bold (`1;`) foreground (`3X`) yellow (`3`)
#     '-blue' - bold (`1;`) foreground (`3X`) blue (`4`)
#     '-magenta' - bold (`1;`) foreground (`3X`) magenta (`5`)
#     '-cyan' - bold (`1;`) foreground (`3X`) cyan (`6`)
#     '-white' - bold (`1;`) foreground (`3X`) white (`7`)
#     .
# )
# <$2> - format(
#     '-' - raw
#     '--' - raw; no <newline>
#     .
# )
# <"$3">+ - text
#! .uses.var.info:
# [NO_COLOR] $ - environment variable;
#                disable color
#! .uses.fn:
# <info> ('$@');
#        Print formatted text
#! .rc.fn:
# (info) (0) success
# (info) (*) error
#! .desc.ext:
# The colors are bold, foreground text, escape sequences of ANSI.
#
# The usage of color results in undefined behavior. For strict POSIX
# compatibility, specify `-` for $1 or set variable `NO_COLOR`
# to a non-empty value.
#.
err() {
    info "$@" >&2
}

#! .desc:
# Identify the type of an object on the filesystem
#! .params:
# <"$1"> - path
# [$2] - fd(
#     '-err' - print to stderr; &2
#     '-info' - print to stdout; &1
#     .
# )
#! .uses.var.err:
# [NO_COLOR] $ - environment variable;
#                disable color
#! .uses.var.info:
# [NO_COLOR] $ - environment variable;
#                disable color
#! .uses.fn:
# (-err) <err> ('-red' '--' "text");
#              Print formatted text to stderr
# (-info) <info> ('-white' '--' "text");
#                Print formatted text
#! .sets:
# (0) <_type> $ - 'B' | 'C' | 'D' | 'F' | 'L' | 'P' | 'S' | '?';
# (1) <_type> $ - '>';
#! .rc:
# (0) success
# (1) does not exist
# (255) bad input
#! .rc.fn:
# (err) (*) error
# (info) (*) error
#! .desc.ext:
# The function denotes the type of the specified object using a letter.
# File categorization will take precedence over directory categorization,
# but exceptions[1] apply. Special file categorization will take precedence
# over regular file categorization according to implicit POSIX behavior,
# depicted below in absolute order.
#
# `L` means "symbolic link";
# `B` means "block special file";
# `C` means "character special file";
# `S` means "socket";
# `P` means "FIFO / named pipe";
# `F` means "regular file";
# `D` means "directory";
# `?` means "unrecognized file type"[2];
# `>` means "does not exist".
#
# The usage of color results in undefined behavior. For strict POSIX
# compatibility, set variable `NO_COLOR` to a non-empty value.
#
# For more information, refer to:
# > "POSIX.1-2024, Volume: Base Definitions, Section: General Concepts,
#   Subsection: Pathname Resolution".
# > "POSIX.1-2024, Volume: Shell & Utilities, Section: Utilities,
#   Utility: test".
#
# [1] A trailing slash in the path string can affect the assert, effectively
#     forcing the type to resolve to a directory or otherwise inexistence.
#     See the "Pathname Resolution" POSIX reference for details.
# [2] Practically, on POSIX shells and systems, `?` (unrecognized file type)
#     should never be returned, but nonetheless exists as a catch-all
#     on non-POSIX platforms.
#.
ftype() {
    case "$2" in
        '-err') set -- "$1" 'err' '-red' '--' ;;
        '-info') set -- "$1" 'info' '-white' '--' ;;
        *) [ ! "$2" ] || return 255; set -- "$1" ':' ;;
    esac

    if [ -h "$1" ]; then
        shift; _type='L'; "$@" 'L' || return "$?"
    elif [ -b "$1" ]; then
        shift; _type='B'; "$@" 'B' || return "$?"
    elif [ -c "$1" ]; then
        shift; _type='C'; "$@" 'C' || return "$?"
    elif [ -S "$1" ]; then
        shift; _type='S'; "$@" 'S' || return "$?"
    elif [ -p "$1" ]; then
        shift; _type='P'; "$@" 'P' || return "$?"
    elif [ -f "$1" ]; then
        shift; _type='F'; "$@" 'F' || return "$?"
    elif [ -d "$1" ]; then
        shift; _type='D'; "$@" 'D' || return "$?"
    elif [ -e "$1" ]; then
        shift; _type='?'; "$@" '?' || return "$?"
    else
        shift; _type='>'; "$@" '>' || return "$?"; return 1
    fi

    return 0
}

#! .desc:
# Print formatted text
#! .params:
# <$1> - color(
#     '-'  - none
#     '-black' - bold (`1;`) foreground (`3X`) black (`0`)
#     '-red' - bold (`1;`) foreground (`3X`) red (`1`)
#     '-green' - bold (`1;`) foreground (`3X`) green (`2`)
#     '-yellow' - bold (`1;`) foreground (`3X`) yellow (`3`)
#     '-blue' - bold (`1;`) foreground (`3X`) blue (`4`)
#     '-magenta' - bold (`1;`) foreground (`3X`) magenta (`5`)
#     '-cyan' - bold (`1;`) foreground (`3X`) cyan (`6`)
#     '-white' - bold (`1;`) foreground (`3X`) white (`7`)
#     .
# )
# <$2> - format(
#     '-' - raw
#     '--' - raw; no <newline>
#     .
# )
# <"$3">+ - text
#! .uses.var:
# [NO_COLOR] $ - environment variable;
#                disable color
#! .rc:
# (0) success
# (*) error
# (255) bad input / error
#! .desc.ext:
# The colors are bold, foreground text, escape sequences of ANSI.
#
# The usage of color results in undefined behavior. For strict POSIX
# compatibility, specify `-` for $1 or set variable `NO_COLOR`
# to a non-empty value.
#.
info() {
    _reset='\033[0m'; case $1 in
        '-') _color=; _reset= ;;
        '-black') _color='\033[1;30m' ;;
        '-red') _color='\033[1;31m' ;;
        '-green') _color='\033[1;32m' ;;
        '-yellow') _color='\033[1;33m' ;;
        '-blue') _color='\033[1;34m' ;;
        '-magenta') _color='\033[1;35m' ;;
        '-cyan') _color='\033[1;36m' ;;
        '-white') _color='\033[1;37m' ;;
        *) return 255 ;;
    esac

    _format="$2"

    [ ! "$NO_COLOR" ] || { _color=; _reset=; }

    shift 2; case "$_format" in
        '-') printf "%b%s%b\n" "$_color" "$*" "$_reset" ;;
        '--') printf "%b%s%b" "$_color" "$*" "$_reset" ;;
        *) return 255 ;;
    esac
}

# END output_functions
# START utility_functions

#! .desc:
# Assert a string
#! .params:
# <$1> - type(
#     '-single-quote-escaped-argument' - argument escaped with single quotes
#     '-single-quotes-array' - pseudo array of single-quote-escaped arguments
#     '-bit' - N that represents a valid bit (valid bit position)
#     '-eq' - N [0,1,00,01...] (integer) equal to another N
#     '-max' - N [0,1,00,01...] (integer) maximum of another N
#     '-min' - N [0,1,00,01...] (integer) minimum of another N
#     '-n' - N [0,1,00,01...] (integer)
#     '-greater-n' - N [0,1,00,01...] (integer) greater than another N
#     '-lower-n' - N [0,1,00,01...] (integer) lower than another N
#     '-natural-n' - natural N [1...] (positive integer)
#     '-whole-n' - whole N [0,1...] (non-negative integer)
#     '-portable-name' - portable ("Portable Filename") name
#     '-absolute-path' - absolute path (/*)
#     '-canonical-path' - lexically canonical (assertable) path
#     '-directory-path' - directory path
#     '-file-path' - file path
#     '-fs-canonical-path' - semantically canonical (assertable) path
#     '-relative-path' - relative path
#     '-shell-array' - shell-parseable evaluable array of arguments
#     '-shell-name' - portable shell-parseable name
#     '-shell-whitespace' - is "IFS white space" (<space>, <tab>, <newline>)
#     '-has-shell-whitespace' - contains "IFS white space" characters
#     .
# )
# <"$2"> - string
# ["$3"] - string
#! .uses:
# [()]
#! .rc:
# (0) true
# (1) false
# (2) false due to bad operand(s)
#! .ec:
# (255) bad input
#! .desc.ext:
# Empty input will assert false (return code `1`) by default; on string types
# with multiple input, `2` might be returned instead.
#
# For `-shell-array`, it is implementation-defined whether the array
# is evaluable, in part with what consists part of "IFS white space";
# the result of the assert is therefore made according to the locale in effect.
#
# For `-shell-whitespace` and `-has-shell-whitespace`, it is
# implementation-defined whether any other, in addition to
# the specified characters, consist part of "IFS white space";
# the result of the assert is therefore made according to the locale in effect.
#
# For more information, refer to:
# > "POSIX.1-2024, Volume: Base Definitions, Section: Definitions,
#   Subsection: Absolute Pathname".
# > "POSIX.1-2024, Volume: Base Definitions, Section: Definitions,
#   Subsection: Argument".
# > "POSIX.1-2024, Volume: Base Definitions, Section: Definitions,
#   Subsection: Name".
# > "POSIX.1-2024, Volume: Base Definitions, Section: Definitions,
#   Subsection: Portable Filename".
# > "POSIX.1-2024, Volume: Base Definitions, Section: Definitions,
#   Subsection: Portable Filename Character Set".
# > "POSIX.1-2024, Volume: Base Definitions, Section: Definitions,
#   Subsection: Relative Pathname".
# > "POSIX.1-2024, Volume: Base Definitions, Section: Definitions,
#   Subsection: User Name".
# > "POSIX.1-2024, Volume: Base Definitions, Section: General Concepts,
#   Subsection: Pathname Resolution".
# > "POSIX.1-2024, Volume: Base Definitions, Section: Regular Expressions,
#   Subsection: RE Bracket Expression".
# > "POSIX.1-2024, Volume: Shell & Utilities, Section: Shell Command Language,
#   Subsection: Escape Character (Backslash)".
# > "POSIX.1-2024, Volume: Shell & Utilities, Section: Shell Command Language,
#   Subsection: eval".
# > "POSIX.1-2024, Volume: Shell & Utilities, Section: Shell Command Language,
#   Subsection: Field Splitting".
# > "POSIX.1-2024, Volume: Shell & Utilities, Section: Shell Command Language,
#   Subsection: Quoting".
# > "POSIX.1-2024, Volume: Shell & Utilities, Section: Shell Command Language,
#   Subsection: set".
# > "POSIX.1-2024, Volume: Shell & Utilities, Section: Shell Command Language,
#   Subsection: Single-Quotes".
#.
assert() {
    case "$1" in
        # Assert $2 is a valid single-quote-escaped argument.
        #
        # A valid single-quote-escaped argument is a shell-parseable string
        # enclosed in single quotes. A single-quote inside
        # a single-quote-escaped argument is escaped
        # with the syntactical expression `'\''`.
        #
        # This string is semantically safe for `eval`.
        '-single-quote-escaped-argument')
            set -- "$2"; while [ "$1" ] || return 1; do
                [ "${1#\'}" != "$1" ] && set -- "${1#\'}" || return 1

                while [ "$1" ]; do
                    case "${1#*\'}" in
                        \\\'\'*) set -- "${1#*\'\\\'\'}"; continue ;;
                        '') return 0 ;;
                    esac

                    return 1
                done
            done
        ;;
        # Assert $2 is a valid single-quotes array of arguments.
        #
        # A valid single-quotes array is a shell-parseable string consisting
        # of at least one argument, each enclosed in single quotes
        # and delimited by <space>. A single-quote inside
        # a single-quote-escaped argument is escaped
        # with the syntactical expression `'\''`.
        #
        # This string is semantically safe for `eval`.
        '-single-quotes-array')
            set -- "${2%"${2##*[! ]}"}"; while [ "$1" ] || return 1; do
                set -- "${1#"${1%%[! ]*}"}"

                [ "${1#\'}" != "$1" ] && set -- "${1#\'}" || return 1

                while [ "$1" ]; do
                    case "${1#*\'}" in
                        \\\'\'*) set -- "${1#*\'\\\'\'}"; continue ;;
                        \ *) set -- "${1#*\'}"; continue 2 ;;
                        '') return 0 ;;
                    esac

                    return 1
                done
            done
        ;;
        # Assert $2 is a number that represents a valid bit.
        #
        # A valid bit is a natural number that represents a specific bit
        # position in a bitmask and is always a power of 2 (`1`, `2`, `4`, `8`,
        # ...). This is also known as "valid bit position".
        #
        # A number is a power of 2 if performing bitwise AND in the expression
        # `N & (N - 1)` results in zero (the binary representation turns to all
        # zeroes due to the single 1-bit being flipped off, given N is
        # a positive integer that is a power of 2).
        '-bit')
            assert -natural-n "$2" || return 2

            [ "$(($2 & ($2 - 1)))" = 0 ] || return 1
        ;;
        # Assert $2 is a number equal to $3.
        #
        # Leading zeroes are ignored, except `[0] -eq [0]` is true. This
        # comparison essentially emulates the behavior of operator `-eq` of
        # `test` in POSIX shells, just with support for extremely large
        # numbers. This comparison is also known as
        # "lexicographical numeric comparison".
        '-eq')
            assert -n "$2" || return 2
            assert -n "$3" || return 2

            set -- "${2#"${2%%[!0]*}"}" "${3#"${3%%[!0]*}"}"

            [ "$1" = "$2" ] || return 1
        ;;
        # Assert $2 is a number maximum of $3.
        #
        # Leading zeroes are ignored, except `[0] -eq [0]` is true. This
        # comparison essentially emulates the behavior of operator `-le` of
        # `test` in POSIX shells, just with support for extremely large
        # numbers. This comparison is also known as
        # "lexicographical numeric comparison".
        '-max')
            assert -lower-n "$2" "$3" || \
            assert -eq "$2" "$3" || \
            return "$?"
        ;;
        # Assert $2 is a number minimum of $3.
        #
        # Leading zeroes are ignored, except `[0] -eq [0]` is true. This
        # comparison essentially emulates the behavior of operator `-ge` of
        # `test` in POSIX shells, just with support for extremely large
        # numbers. This comparison is also known as
        # "lexicographical numeric comparison".
        '-min')
            assert -greater-n "$2" "$3" || \
            assert -eq "$2" "$3" || \
            return "$?"
        ;;
        # Assert $2 is a number (`0`, `1`, `00`, `01`, ...).
        #
        # A number is any string consisting only of digits. This is also
        # well known as "integer".
        '-n')
            case "${2:-0}${2#*[!0123456789]}" in
                "$2$2") return 0 ;;
            esac

            return 1
        ;;
        # Assert $2 is a number greater than $3.
        #
        # To determine which number is greater, leading zeroes are removed,
        # and the numbers are first compared by length, followed by
        # digit comparison if the lengths are the same. This comparison
        # essentially emulates the behavior of operator `-gt` of `test`
        # in POSIX shells, just with support for extremely large
        # numbers. This comparison is also known as
        # "lexicographical numeric comparison".
        '-greater-n')
            assert -n "$2" && assert -n "$3" || return 2

            set -- "${2#"${2%%[!0]*}"}" "${3#"${3%%[!0]*}"}"

            [ ! "$1" = "$2" ] && [ ! "${#1}" -lt "${#2}" ] || return 1
            [ ! "${#1}" -gt "${#2}" ] || return 0

            while [ "$1" ]; do
                case "$1" in
                    "${2%"${2#?}"}"*) set -- "${1#?}" "${2#?}"; continue ;;
                esac

                if [ "${1%"${1#?}"}" -gt "${2%"${2#?}"}" ]; then
                    return 0
                fi

                return 1
            done
        ;;
        # Assert $2 is a number lower than $3.
        #
        # To determine which number is lower, leading zeroes are removed,
        # and the numbers are first compared by length, followed by
        # digit comparison if the lengths are the same. This comparison
        # essentially emulates the behavior of operator `-lt` of `test`
        # in POSIX shells, just with support for extremely large
        # numbers. This comparison is also known as
        # "lexicographical numeric comparison".
        '-lower-n')
            assert -n "$2" && assert -n "$3" || return 2

            set -- "${2#"${2%%[!0]*}"}" "${3#"${3%%[!0]*}"}"

            [ ! "$1" = "$2" ] && [ ! "${#1}" -gt "${#2}" ] || return 1
            [ ! "${#1}" -lt "${#2}" ] || return 0

            while [ "$1" ]; do
                case "$1" in
                    "${2%"${2#?}"}"*) set -- "${1#?}" "${2#?}"; continue ;;
                esac

                if [ "${1%"${1#?}"}" -lt "${2%"${2#?}"}" ]; then
                    return 0
                fi

                return 1
            done
        ;;
        # Assert $2 is a natural number (`1`, `2`, ...).
        #
        # A natural number is any string consisting only of digits,
        # of which the first is not `0`. Also known as "positive integer"
        # in the POSIX standard.
        '-natural-n')
            case "${2:-0}${2#*[!0123456789]}" in
                0*) return 1 ;;
                "$2$2") return 0 ;;
            esac

            return 1
        ;;
        # Assert $2 is a whole number (`0`, `1`, `2`, ...).
        #
        # A whole number is `0` and any string consisting only of digits,
        # of which the first is not `0`. Also known as "non-negative integer"
        # in the POSIX standard.
        '-whole-n')
            assert -natural-n "$2" || \
            assert -eq "$2" 0 || \
            return "$?"
        ;;
        # Assert $2 is a portable ("Portable Filename") name.
        #
        # A portable name is a string composed of the characters in
        # the portable filename character set,
        # with the following exceptions:
        #
        # - Should not begin with a <hyphen-minus> character. This exception
        #   is currently not being asserted.
        #
        # The character classes have been intentionally expanded to be
        # locale-independent.
        '-portable-name')
            case "$2" in
                *[!0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_\.\-]*)
                    return 1
                ;;
            esac

            [ "$2" ] || return 1
        ;;
        # Assert $2 is an absolute (/*) path.
        #
        # An absolute path is any string of which the first character
        # is `/`.
        '-absolute-path')
            case "$2" in
                '/'*) return 0 ;;
            esac

            return 1
        ;;
        # Assert $2 is a lexically canonical (assertable) path.
        #
        # A canonical path is largely implementation-defined string that
        # refers to the normalized absolute path. Therefore,
        # a lexical canonical path is:
        #
        # - Assertive: Multiple consecutive slashes (`//`) are removed,
        #   `.` and `..` are resolved. The only exception is two consecutive
        #   slashes (`//`) at the beginning of the string, which is specified
        #   by the POSIX standard as an "implementation-defined" exception.
        #
        # - Absolute: The path is always rooted from `/`.
        '-canonical-path')
            case "$2" in
                '//'*) set -- "${2#/}" ;;
                *) set -- "$2" ;;
            esac

            case "$1" in
                *'//'*) return 1 ;;
                '/'*) : ;;
                *) return 1 ;;
            esac

            case "$1/" in
                *'/./'* | *'/../'*) return 1 ;;
            esac

            return 0
        ;;
        # Assert $2 is a directory (directory-resolving) path.
        #
        # A directory path is any string containing at least one non-<slash>
        # (`/`) character and that ends with one or more trailing <slash>
        # characters.
        '-directory-path')
            case "$2" in
                *[!/]*/) return 0 ;;
            esac

            return 1
        ;;
        # Assert $2 is a file (file-resolving) path.
        #
        # A file path is any string containing at least one non-<slash>
        # (`/`) character and that does not end with trailing <slash>
        # characters.
        '-file-path')
            case "$2" in
                *[!/]*/) return 1 ;;
                *[!/]*) return 0 ;;
            esac

            return 1
        ;;
        # Assert $2 is a semantically canonical (assertable) path.
        #
        # A canonical path is largely implementation-defined string that
        # refers to the normalized absolute path. Therefore,
        # a semantic canonical path is:
        #
        # - Semantic: Neither the path nor its segments are a symbolic link on
        #   the filesystem. The actual existence of the path or its segments is
        #   ignored.
        #
        # - Assertive: Multiple consecutive slashes (`//`) are removed,
        #   `.` and `..` are resolved.
        #
        # - Absolute: The path is always rooted from `/`.
        '-fs-canonical-path')
            case "$2" in
                '/') return 0 ;;
                *'//'*) return 1 ;;
                '/'*) set -- "${2%/}/" ;;
                *) return 1 ;;
            esac

            case "$1" in
                *'/./'* | *'/../'*) return 1 ;;
            esac

            while [ ! -h "${1%/}" ] || return 1; do
                [ "${1%/*/}" ] && set -- "${1%/*/}/" || return 0
            done
        ;;
        # Assert $2 is a relative (partial) path.
        #
        # A relative path is any string of which the first character
        # is not `/`.
        '-relative-path')
            case "$2" in
                '/'*) return 1 ;;
            esac

            [ "$2" ] || return 1
        ;;
        # Assert $2 is a shell-parseable evaluable array of arguments.
        #
        # A valid shell-parseable evaluable array is a parseable,
        # according to the shell grammar, whole string consisting of
        # at least one argument.
        #
        # This string is semantically safe for `eval`.
        '-shell-array')
            [ "$2" ] && ( eval set -- "$2" && [ "$#" -ge 1 ]; ) || return 1
        ;;
        # Assert $2 is a portable shell-parseable name.
        #
        # A portable shell-parseable name is a string composed of
        # the characters in the portable filename character set,
        # with the following exceptions:
        #
        # - Cannot begin with a digit.
        # - Cannot contain a <hyphen-minus> character.
        # - Cannot contain a <period> character.
        #
        # The character classes have been intentionally expanded to be
        # locale-independent.
        '-shell-name')
            case "$2" in
                [0123456789]*)
                    return 1
                ;;
                *[!0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_]*)
                    return 1
                ;;
            esac

            [ "$2" ] || return 1
        ;;
        # Assert $2 consists of "IFS white space" (<space>, <tab>, <newline>)
        # characters.
        '-shell-whitespace')
            [ "$2" ] && set -- $2 && [ "$#" -eq 0 ] || return 1
        ;;
        # Assert $2 contains "IFS white space" (<space>, <tab>, <newline>)
        # characters.
        '-has-shell-whitespace')
            [ "$2" ] && set -- .$2. && [ "$#" -ne 1 ] || return 1
        ;;
        *)
            exit 255
        ;;
    esac
}

#! .desc:
# Print bytes in human-readable fmt: "N" "X"iB / "N" "X"B
#! .params:
# <$1> - bytes
#! .rc:
# (0) success
# (*) error
# (255) bad input
#.
bytes_size() {
    assert -eq "$#" 1 || return 255

    awk -v 'bytes'="$1" '
	function hsize(x, base) {
		basesuf = (base == "1024") ? "iB" : "B"

		s = "BKMGTEPYZ"
		while (x >= base && length(s) > 1)
			{x /= base; s = substr(s, 2)}
		s = substr(s, 1, 1)

		xf = (s == "B") ? "%d" : "%.2f"

		if (s != "B")
			s = s basesuf

		printf((xf " %s"), x, s)
	}

	BEGIN {
		printf hsize(bytes, 1024)
		printf " / "
		print hsize(bytes, 1000)
	}
    ' 2> /dev/null
}

#! .desc:
# Remove the filesystem flag protection of a physical file
#! .params:
# <"$1"> - absolute path
#! .rc:
# (0) success
# (*) error
# (255) bad input
#.
chattr_remove() {
    assert -eq "$#" 1 || return 255

    cmd 'chattr' || return 0

    { [ -f "$1" ] && [ ! -h "$1" ]; } || return 0

    chattr -ia "$1" 2> /dev/null || :
}

#! .desc:
# Process each populated IFS field split with a function
#! .params:
# <"$1"> - string
# <$2> - function name
# ["$3"]+ - function argument
#! .uses.var:
# <IFS> $ - environment variable;
#           list of characters that is used for field splitting
#! .sets:
# <set +f>;
#! .rc:
# (0) success
# (*) error
#! .rc.fn:
# ($2) (*) error
#! .desc.ext:
# > "POSIX.1-2024, Volume: Shell & Utilities, Section: Shell Command Language,
#   Subsection: Field Splitting".
# > "POSIX.1-2024, Volume: Shell & Utilities, Section: Shell Command Language,
#   Subsection: set".
# > "POSIX.1-2024, Volume: Shell & Utilities, Section: Shell Command Language,
#   Subsection: Shell Variables".
#.
ifs_map() {
    set -f && _str="$1" && shift && for _field in $_str; do
        [ "$_field" ] || continue

        "$@" "$_field" || { set -- "$?"; set +f; return "$?"; }
    done && set +f
}

#! .desc:
# Create the parents of a file/directory
#! .params:
# <"$1"> - absolute path
#! .rc:
# (0) success
# (*) error
# (255) bad input
#.
mkdir_parents() {
    assert -eq "$#" 1 || return 255

    if str_sfix '/' "$1"; then
        set -- "${1%?}"
    fi

    if dir "${1%/*}"; then
        return 0
    fi

    # Shall consider implementing 'mkdir -p' within the shell by path
    # traversing the function argument and passing separate consequental
    # arguments to mkdir. Important to note that in such situation, error
    # handling would be on us, including the handling of race conditions.
    mkdir -p "${1%/*}" 2> /dev/null
}

#! .desc:
# Convert an octal sequence into ASCII characters
#! .params:
# <"$1"> - octal sequence
#! .rc:
# (0) success
# (*) error
# (255) bad input
#.
octal_decode() {
    assert -eq "$#" 1 || return 255

    IFS_save;

    IFS="$LF"' '; for _octal in $1; do
        printf "%b" "\\$_octal"
    done

    IFS_restore;
}

#! .desc:
# Print the return code of a command
#! .params:
# <"$1"> - command
# ["$2"+] - arguments
#! .rc:
# (0) success
# (127) command does not exist
# (255) bad input
#.
rc() {
    assert -min "$#" 1 || return 255

    if cmd "$1"; then
        "$@" > /dev/null 2>&1
        printf "%d" "$?"
    else
        return 127
    fi

    return 0
}

#! .desc:
# Replace a specific character with character(s) in a string using PE
#! .params:
# ["$1"] - specific character
# ["$2"] - character(s)
# ["$3"] - string
#! .uses.fn:
# <assert> ('-max' '${#1}' '1');
#          Assert a string
#! .gives:
# (0) <"$_str"> - [string];
#                 [modified <$3>]
#! .rc:
# (0) success
# (*) error
#! .rc.fn:
# (assert) (255) bad input
#! .desc.ext:
# Multi-byte and multiple characters are not supported and error code `255`
# (bad input) will be returned.
#
# For more information, refer to:
# > "POSIX.1-2024, Volume: Shell & Utilities, Section: Shell Command Language,
#   Subsection: Parameter Expansion".
#.
replchar_posix() {
    assert -max "${#1}" 1 || return 255

    # Traverse $3 (string), replacing the occurrences of $1 with $2.
    _str=; _a="$3"; while [ "$1" ]; do case "$_a" in
        *"$1"*)
            # Example character, replacement character, and string:
            # `a` `A` `ddaabcd`
            # $_b: `dd`
            # $_c: `aabcd`
            # $_d: `aa`
            # $_a: `bcd`
            _b="${_a%%"$1"*}"
            _c="${_a#"$_b"}"
            _d="${_c%%[!"$1"]*}"
            _a="${_a#"$_b$_d"}"

            # ${#_d}: `2`
            # $_chars: `AA`
            _chars=; _i=0; until [ "$_i" = "${#_d}" ]; do
                _chars="$_chars$2"; _i=$((_i + 1))
            done

            # $_str: `ddAA`
            _str="$_str$_b$_chars"
        ;;
        *)
            # $_str: `ddAAbcd`
            _str="$_str$_a"; break
        ;;
    esac done
}

#! .desc:
# Execute 'umount' on a directory
#! .params:
# <"$1"> - directory
#! .rc:
# (0) success
# (255) bad input
#.
unmount() {
    assert -eq "$#" 1 || return 255

    cmd 'umount' && exist "$1" && dir "$1" || return 0

    umount -Rf "$1" > /dev/null 2>&1 || :
}

# END utility_functions
# START std_err_functions

#! .desc:
# EPERM: "Operation not permitted"
#! .rc:
# 1
#.
EPERM() { _err -red -- 'EPERM:'; }

#! .desc:
# ENOENT: "No such file or directory"
#! .rc:
# 2
#.
ENOENT() { _err -red - 'ENOENT:'; }

#! .desc:
# EERROR: "General operation error"
#! .params:
# <"$1"+> - error
#! .rc:
# (1)
# (255) bad input
#.
EERROR() {
    assert -eq "$#" 1 || return 255

    _err -red - "EERROR: $1"; exit 1
}

#! .desc:
# EEXIST: "Already exists"
#! .params:
# <"$1"+> - absolute path
#! .rc:
# (17)
# (255) bad input
#.
EEXIST() {
    assert -min "$#" 1 || return 255

    _err -red - 'EEXIST:'

    while [ "$1" ]; do
        ftype "$1" -err || :
        err - - " $1"

        shift
    done

    exit 17
}

#! .desc:
# ENOTDIR: "Not a directory"
#! .params:
# <"$1"+> - absolute path
#! .rc:
# (20)
# (255) bad input
#.
ENOTDIR() {
    assert -min "$#" 1 || return 255

    _err -red - 'ENOTDIR:'

    while [ "$1" ]; do
        ftype "$1" -err || :
        err - - " $1"

        shift
    done

    exit 20
}

#! .desc:
# EISDIR: "Is a directory"
#! .params:
# <"$1"+> - absolute path
#! .rc:
# (21)
# (255) bad input
#.
EISDIR() {
    assert -min "$#" 1 || return 255

    _err -red - 'EISDIR:'

    while [ "$1" ]; do
        ftype "$1" -err || :
        err - - " $1"

        shift
    done

    exit 21
}

#! .desc:
# EINVAL: "Invalid argument"
#! .rc:
# 22
#.
EINVAL() { _err -red - 'EINVAL:'; }

# END std_err_functions

#! .desc:
# Modify a file in-place according to format
# A - anywhere; E - exact; P - prefix; S - suffix
# + - add; - - remove; ~ - replace
#! .params (<2+>):
# <$1> - type(
#     '+' - {+} pre-line
#     '+0' - {E} pre-line & {+} post-line
#     '+1' - {P} pre-line & {+} post-line
#     '+2' - {S} pre-line & {+} post-line
#     '+3' - {A} pre-line & {+} post-line
#     '-0' - {E} pre-line & {-}
#     '-1' - {P} pre-line & {-}
#     '-2' - {S} pre-line & {-}
#     '-3' - {A} pre-line & {-}
#     '~0' - {E} pre-line {~} post-line
#     '~1' - {P} pre-line {~} post-line
#     '~2' - {S} pre-line {~} post-line
#     '~3' - {A} pre-line {~} post-line
#     '~~1' - {P} pre-line {~} post-line | {+} post-line
#     '~~2' - {S} pre-line {~} post-line | {+} post-line
#     '~~3' - {A} pre-line {~} post-line | {+} post-line
#     '~~~1' - {P} pre-line & match {~} post-line
#         {
#             <"$1"> - match
#         }
#     '~~~2' - {S} pre-line & match {~} post-line
#         {
#             <"$1"> - match
#         }
#     '~~~3' - {A} pre-line & match {~} post-line
#         {
#             <"$1"> - match
#         }
#     .
# )
# {["$1"] - pre-line
# ["$2"]}+ - post-line
#! .uses (<1+>):
# [FILE] $ - an already parsed file
# [FILE_PATH] $ - absolute path
#! .rc:
# (0) success
# (*) error
# (255) bad input/usage
#.
libfile() {
    assert -min "$#" 2 || return 255

    if [ ! "$FILE" ]; then
        if ! __FILE_PATH_preload; then
            return 0
        fi
    fi

    line_add() {
        while IFS= read -r line; do
            i=$((i + 1))

            # In a later stage, log writing can be made an internal
            # setting, effectively increasing the number of conditional
            # checks to a total of two. This way, specific line additions
            # can be abbreviated (or not) as desired in the log file,
            # without disabling the logging of other line additions.
            LOG_write 1 "$i" "$line"

            printf "%s\n" "$line"
        done <<EOF
$1
EOF
    }

    line_replace() {
        # Here, $l is used to determine the current iteration of line.
        l=0; while IFS= read -r line; do
            l=$((l + 1))

            # If $l is 1, it means we are in the first iteration. For the
            # first iteration we do not increment the file line counter
            # because we are simply replacing the line. For the following
            # iterations we increment the file line counter because we are
            # adding lines.
            if [ "$l" -ne 1 ]; then
                i=$((i + 1))
            fi

            # If $l is 1, it means we are in the first iteration. For the
            # first iteration we log line replace, for the following
            # iterations we log line addition.
            if [ "$l" -eq 1 ]; then
                if [ "$LINE" != "$line" ]; then
                    LOG_write 3 "$i" "$LINE" "$line"
                fi
            else
                LOG_write 1 "$i" "$line"
            fi

            printf "%s\n" "$line"
        done <<EOF
$1
EOF
    }

    parse_args() {
        j=0; m=0; while [ "$#" -ge 2 ]; do case "$1" in
            # + - {+} pre-line; $2
            '+')
                # The following variable helps to later compare and
                # determine which lines requsted to be added should
                # actually be added. It does this by noting the current
                # iteration of lines requsted to be added.
                j=$((j + 1))

                case "$LINE" in
                    "$2")
                        # The line requested to be added already exists.
                        # Note it in the following variable to later
                        # compare and add any missing requested lines, if
                        # any. The comma character is used as a delimiter
                        # between the numbers for easy and fail-safe number
                        # grep.
                        k="${k},${j},"

                        printf "%s\n" "$LINE"

                        return;
                    ;;
                    *)
                        shift 2
                    ;;
                esac
            ;;
            # +0 - {E} pre-line & {+} post-line; $2 & $3 respectively
            # +1 - {P} pre-line & {+} post-line; $2 & $3 respectively
            # +2 - {S} pre-line & {+} post-line; $2 & $3 respectively
            # +3 - {A} pre-line & {+} post-line; $2 & $3 respectively
            '+0'|'+1'|'+2'|'+3')
                assert -min "$#" 3 || exit 255

                case "$2" in
                    *"$LF"*) exit 255 ;;
                esac

                case "$1$LINE" in
                    "+0$2" | \
                    "+1$2"* | \
                    '+2'*"$2" | \
                    '+3'*"$2"*)
                        printf "%s\n" "$LINE"

                        # Properly print $3 and increment the file line
                        # counter if $3 contains newlines, i.e. if $3 is
                        # multiple lines in one string. This function
                        # automatically writes the relevant details to the
                        # log file.
                        line_add "$3"

                        return;
                    ;;
                    *)
                        shift 3
                    ;;
                esac
            ;;
            # -0 - {E} pre-line & {-}; $2 & $LINE respectively
            # -1 - {P} pre-line & {-}; $2 & $LINE respectively
            # -2 - {S} pre-line & {-}; $2 & $LINE respectively
            # -3 - {A} pre-line & {-}; $2 & $LINE respectively
            '-0'|'-1'|'-2'|'-3')
                case "$2" in
                    *"$LF"*) exit 255 ;;
                esac

                case "$1$LINE" in
                    "-0$2" | \
                    "-1$2"* | \
                    '-2'*"$2" | \
                    '-3'*"$2"*)
                        LOG_write 2 "$i" "$LINE"

                        i=$((i - 1))

                        return;
                    ;;
                    *)
                        shift 2
                    ;;
                esac
            ;;
            # ~0 - {E} pre-line {~} post-line; $2 & $3 respectively
            # ~1 - {P} pre-line {~} post-line; $2 & $3 respectively
            # ~2 - {S} pre-line {~} post-line; $2 & $3 respectively
            # ~3 - {A} pre-line {~} post-line; $2 & $3 respectively
            '~0'|'~1'|'~2'|'~3')
                assert -min "$#" 3 || exit 255

                case "$2" in
                    *"$LF"*) exit 255 ;;
                esac

                case "$1$LINE" in
                    "~0$2" | \
                    "~1$2"* | \
                    '~2'*"$2" | \
                    '~3'*"$2"*)
                        # Properly replace the line with $3 and increment
                        # the file line counter if $3 contains newlines,
                        # i.e. if $3 is multiple lines in one string. This
                        # function automatically writes the relevant
                        # details to the log file.
                        line_replace "$3"

                        return;
                    ;;
                    *)
                        shift 3
                    ;;
                esac
            ;;
            # ~~1 - {P} pre-line {~} post-line | {+} post-line; $2 & $3
            # ~~2 - {S} pre-line {~} post-line | {+} post-line; $2 & $3
            # ~~3 - {A} pre-line {~} post-line | {+} post-line; $2 & $3
            '~~1'|'~~2'|'~~3')
                assert -min "$#" 3 || exit 255

                case "$2" in
                    *"$LF"*) exit 255 ;;
                esac

                m=$((m + 1))

                case "$1$LINE" in
                    "~~1$2"* | \
                    '~~2'*"$2" | \
                    '~~3'*"$2"*)
                        n="${n},${m},"

                        # Properly replace the line with $3 and increment
                        # the file line counter if $3 contains newlines,
                        # i.e. if $3 is multiple lines in one string. This
                        # function automatically writes the relevant
                        # details to the log file.
                        line_replace "$3"

                        return;
                    ;;
                    *)
                        shift 3
                    ;;
                esac
            ;;
            # ~~~1 - {P} pre-line & match {~} post-line; $3 & $2 & $4
            # ~~~2 - {S} pre-line & match {~} post-line; $3 & $2 & $4
            # ~~~3 - {A} pre-line & match {~} post-line; $3 & $2 & $4
            '~~~1'|'~~~2'|'~~~3')
                assert -min "$#" 4 || exit 255

                case "$2$3" in
                    *"$LF"*) exit 255 ;;
                esac

                case "$1$LINE" in
                    "~~~1$3"* | \
                    '~~~2'*"$3" | \
                    '~~~3'*"$3"*)
                        case "$LINE" in
                            *"$2"*) : ;;
                            *) shift 4 && continue ;;
                        esac

                        # Properly replace the line with $4 and increment
                        # the file line counter if $4 contains newlines,
                        # i.e. if $4 is multiple lines in one string. This
                        # function automatically writes the relevant
                        # details to the log file.
                        line_replace "$4"

                        return;
                    ;;
                    *)
                        shift 4
                    ;;
                esac
            ;;
            *)
                exit 255
            ;;
        esac; done

        assert -eq "$#" 0 || exit 255

        # Print the line as-is since no match was found.
        printf "%s\n" "$LINE"
    }

    parse_args_post() {
        j=0; m=0; while [ "$#" -ge 2 ]; do case "$1" in
            '+')
                j=$((j + 1))

                case "$k" in
                    *",${j},"*)
                        : # line already added
                    ;;
                    *)
                        # Properly print $2 and increment the file line counter
                        # if $2 contains newlines, i.e. if $2 is multiple lines
                        # in one string. This function automatically writes the
                        # relevant details to the log file.
                        line_add "$2"
                    ;;
                esac

                shift 2
            ;;
            '~~1'|'~~2'|'~~3')
                assert -min "$#" 3 || exit 255

                case "$2" in
                    *"$LF"*) exit 255 ;;
                esac

                m=$((m + 1))

                case "$n" in
                    *",${m},"*)
                        : # line already replaced
                    ;;
                    *)
                        # Properly print $3 and increment the file line counter
                        # if $3 contains newlines, i.e. if $3 is multiple lines
                        # in one string. This function automatically writes the
                        # relevant details to the log file.
                        line_add "$3"
                    ;;
                esac

                shift 3
            ;;
            '-0'|'-1'|'-2'|'-3')
                shift 2
            ;;
            '+0'|'+1'|'+2'|'+3'|'~0'|'~1'|'~2'|'~3')
                shift 3
            ;;
            '~~~1'|'~~~2'|'~~~3')
                shift 4
            ;;
            *)
                exit 255
            ;;
        esac; done

        assert -eq "$#" 0 || exit 255
    }

    FILE=$(
        # It is almost always preferred that any lines added by us are placed
        # distinguishably, i.e. they are separated by our newline. This has the
        # added benefit of standardizing the process of line addition as the
        # count of trailing newlines in the original file, be it zero or more
        # than one, will not matter. This could be made configurable at a later
        # stage.
        case "${FILE#"${FILE%??}"}" in
            "$LF$LF") : ;;
            *"$LF") FILE="$FILE$LF" ;;
            *) FILE="$FILE$LF$LF" ;;
        esac

        i=0; printf "%s" "$FILE" | { while IFS= read -r LINE; do
            i=$((i + 1)); parse_args "$@"
        done

        # Add lines remaining to be added, if any.
        parse_args_post "$@"; }
    )

    # Add a newline, as the command substitution removed all trailing ones.
    FILE="$FILE$LF"
}

#! .desc:
# Clear the log file ($logf)
#! .uses:
# <logf> $ - the absolute path of the log file
#! .rc:
# (0) success
# (*) error
# (255) bad call
#.
LOG_clear() {
    file "$logf" || return 255
    writable "$logf" || return 255

    { : > "$logf"; } 2> /dev/null
}

#! .desc:
# Print the log file ($logf)
#! .uses:
# <logf> $ - the absolute path of the log file
#! .rc:
# (0) success
# (*) error
# (255) bad call
#.
LOG_print() {
    file "$logf" || return 255
    readable "$logf" || return 255

    ( . "$logf"; ) 2> /dev/null
}

#! .desc:
# Write to the log file ($logf)
#! .params:
# <$1> - type(
#     '0' - raw string
#         {
#             <"$1"> - string
#         }
#     '1' - file in-place string addition
#         {
#             <$1> - line number
#             <"$2"> - string
#         }
#     '2' - file in-place string removal
#         {
#             <$1> - line number
#             <"$2"> - string
#         }
#     '3' - file in-place string change
#         {
#             <$1> - line number
#             <"$2"> - string from
#             <"$3"> - string to
#         }
#     .
# )
#! .uses:
# <logf> $ - the absolute path of the log file
#! .rc:
# (0) success
# (*) error
# (255) bad call | bad input
#.
LOG_write() {
    assert -min "$#" 2 || return 255

    if [ "$1" = 1 ] || [ "$1" = 2 ]; then
        assert -eq "$#" 3 || return 255

        # Check if $2 is a natural number
        case "$2:${2#*[!0123456789]}" in
            : | 0*) return 255 ;;
            "$2:$2") : ;;
            *) return 255 ;;
        esac
    elif [ "$1" = 3 ]; then
        assert -eq "$#" 4 || return 255

        # Check if $2 is a natural number
        case "$2:${2#*[!0123456789]}" in
            : | 0*) return 255 ;;
            "$2:$2") : ;;
            *) return 255 ;;
        esac
    fi

    file "$logf" || return 255
    writable "$logf" || return 255

    case $1 in
        0)
            replchar_posix \' \'\\\'\' "$2"; set -- "$_str"

            printf "'printf' %s %s\n" \
                   "'%s\n'" \
                   "'$1'" \
                   >> "$logf"
        ;;
        1)
            replchar_posix \' \'\\\'\' "$3"; set -- "$2" "$_str"

            printf "'printf' %s %s %s\n" \
                   "'%b%s%b%s\n'" \
                   "'\033[1;32m' '${1}+ ' '\033[0m'" \
                   "'$2'" \
                   >> "$logf"
        ;;
        2)
            replchar_posix \' \'\\\'\' "$3"; set -- "$2" "$_str"

            printf "'printf' %s %s %s\n" \
                   "'%b%s%b%s\n'" \
                   "'\033[1;31m' '${1}- ' '\033[0m'" \
                   "'$2'" \
                   >> "$logf"
        ;;
        3)
            replchar_posix \' \'\\\'\' "$3"; set -- "$2" "$_str" "$4"
            replchar_posix \' \'\\\'\' "$3"; set -- "$1" "$2" "$_str"

            {
                printf "'printf' %s %s %s\n" \
                       "'%b%s%b%s\n'" \
                       "'\033[1;31m' '${1}- ' '\033[0m'" \
                       "'$2'"
                printf "'printf' %s %s %s\n" \
                       "'%b%s%b%s\n'" \
                       "'\033[1;32m' '${1}+ ' '\033[0m'" \
                       "'$3'"
            } >> "$logf"
        ;;
    esac
}

#! .desc:
# Check if the log file ($logf) contains stuff
#! .uses:
# <logf> $ - the absolute path of the log file
#! .rc:
# (0) yes
# (1) no
#.
LOG_written() {
    [ -s "$logf" ]
}

#! .desc:
# Read STDIN into $FILE
#! .gives:
# (0) <"$FILE"> - the content of STDIN
#! .rc:
# (0) success
# (*) error
#.
FILE() {
    { while IFS= read -r _line; do
        FILE="$FILE$_line
"
    done; FILE="$FILE$_line"; } 2> /dev/null
}

#! .desc:
# Read a file into $FILE
#! .params:
# <"$1"> - absolute path
#! .gives:
# (0) <"$FILE"> - the content of the file
#! .rc:
# (0) success
# (*) error
# (255) bad input
#.
FILE_preload() {
    assert -eq "$#" 1 || return 255

    file "$1" || return 255
    readable "$1" || return 255

    FILE=$(
        while IFS= read -r _line; do
            printf "%s\n" "$_line"
        done < "$1"; printf "%s" "$_line"

        printf "%s" ' '
    ) 2> /dev/null; FILE="${FILE%?}"
}

#! .desc:
# Read STDIN into $FILE_PATH
#! .gives:
# (0) <"$FILE_PATH"> - the content of STDIN
#! .rc:
# (0) success
# (*) error
#.
FILE_PATH() {
    FILE=; FILE_PATH=; FILE_PATH_TARGET=

    { while IFS= read -r _line; do
        FILE_PATH="$FILE_PATH$_line
"
    done; FILE_PATH="${FILE_PATH%?}$_line"; } 2> /dev/null
}

#! .desc:
# Read STDIN into $FILE_PATH_TARGET
#! .gives:
# (0) <"$FILE_PATH_TARGET"> - the content of STDIN
#! .rc:
# (0) success
# (*) error
#.
FILE_PATH_TARGET() {
    FILE_PATH_TARGET=

    { while IFS= read -r _line; do
        FILE_PATH_TARGET="$FILE_PATH_TARGET$_line
"
    done; FILE_PATH_TARGET="${FILE_PATH_TARGET%?}$_line"; } 2> /dev/null
}

#! .desc:
# Check if a file matches a given octal sequence
#! .params:
# <"$1"> - absolute path
# <"$2"> - octal sequence
#! .rc:
# (0) yes
# (1) no
# (255) bad input
#.
bin_equiv() {
    assert -eq "$#" 2 || return 255

    file "$1" || return 255

    {
        set -- "$(od -to1 -An "$1")" "$2" && \
        set -- "${1%"${1##*[0123456789]}"}" "${2%"${2##*[0123456789]}"}" && \
        set -- "${1#"${1%%[0123456789]*}"}" "${2#"${2%%[0123456789]*}"}"
    } 2> /dev/null || return 255

    [ "$1" = "$2" ]
}

#! .desc:
# Copy a given directory at a path
#! .params:
# <"$1"> - absolute path of the directory
# <"$2"> - absolute path to copy the directory at
#! .rc:
# (0) success
# (*) error
# (255) bad input
#.
dir_write() {
    assert -eq "$#" 2 || return 255

    dir "$1" || return 255

    if exist "$2"; then
        chattr_remove "$2"
        unmount "$2"

        rm -rf "$2" 2> /dev/null
    fi

    mkdir_parents "$2"

    cp -R "$1" "$2" 2> /dev/null
}

#! .desc:
# Copy a given file at a path
#! .params:
# <"$1"> - absolute path of the file
# <"$2"> - absolute path to copy the file at
#! .rc:
# (0) success
# (*) error
# (255) bad input
#.
file_copy() {
    assert -eq "$#" 2 || return 255

    file "$1" || return 255

    if exist "$2"; then
        chattr_remove "$2"
        unmount "$2"

        rm -rf "$2" 2> /dev/null
    fi

    mkdir_parents "$2"

    cp "$1" "$2" 2> /dev/null
}

#! .desc:
# Check if a file matches a given string
#! .params:
# <"$1"> - absolute path
# <"$2"> - string
#! .rc:
# (0) yes
# (1) no
# (*) error
# (255) bad input
#.
file_equiv() {
    assert -eq "$#" 2 || return 255

    file "$1" || return 255

    {
        _file= && while IFS= read -r _line; do
            _file="$_file$_line
"
        done < "$1"; _file="$_file$_line"
    } 2> /dev/null

    [ "$_file" = "$2" ]
}

#! .desc:
# Write a given string at a path
#! .params:
# <"$1"> - absolute path
# <"$2"> - string
#! .rc:
# (0) success
# (*) error
# (255) bad input
#.
file_write() {
    assert -eq "$#" 2 || return 255

    if exist "$1"; then
        chattr_remove "$1"
        unmount "$1"

        rm -rf "$1" 2> /dev/null
    fi

    mkdir_parents "$1"

    { printf "%s" "$2" > "$1"; } 2> /dev/null
}

#! .desc:
# Write a given octal sequence at a path
#! .params:
# <"$1"> - absolute path
# <"$2"> - octal sequence
#! .rc:
# (0) success
# (*) error
# (255) bad input
#.
file_write_octal() {
    assert -eq "$#" 2 || return 255

    if exist "$1"; then
        chattr_remove "$1"
        unmount "$1"

        rm -rf "$1" 2> /dev/null
    fi

    set -- "$1" "${2%"${2##*[0123456789]}"}"
    set -- "$1" "${2#"${2%%[0123456789]*}"}"

    mkdir_parents "$1"
    { octal_decode "$2" > "$1"; } || { rm -f "$1"; return 1; }
}

#! .desc:
# Check if a file matches a given file
#! .params:
# <"$1"> - absolute path
# <"$2"> - absolute path
#! .rc:
# (0) yes
# (1) no
# (*) error
# (255) bad input
#.
files_equiv() {
    assert -eq "$#" 2 || return 255

    file "$1" || return 255
    file "$2" || return 255
    readable "$1" || return 255
    readable "$2" || return 255

    cmp -s "$1" "$2" 2> /dev/null
}

#! .desc:
# Permanently delete a file/directory
#! .params:
# <"$1"> - absolute path
#! .rc:
# (0) success
# (*) error
# (255) bad $1
#.
loc_delete() {
    assert -eq "$#" 1 || return 255

    exist "$1" || return 0

    chattr_remove "$1"
    unmount "$1"

    rm -rf "$1" 2> /dev/null
}

#! .desc:
# Create a symbolic link of an object
#! .params:
# <"$1"> - absolute path of the object
# <"$2"> - absolute path to create the link at
#! .rc:
# (0) success
# (*) error
# (255) bad input
#.
loc_link() {
    assert -eq "$#" 2 || return 255

    { [ -e "$1" ] || [ -h "$1" ]; } || return 255

    if exist "$2"; then
        chattr_remove "$2"
        unmount "$2"
    fi

    mkdir_parents "$2"

    ln -sf "$1" "$2" 2> /dev/null
}

#! .desc:
# Create a hard link of a file
#! .params:
# <"$1"> - absolute path of the file
# <"$2"> - absolute path to create the link at
#! .rc:
# (0) success
# (*) error
# (255) bad input
#.
loc_link_ptr() {
    assert -eq "$#" 2 || return 255

    if file "$1"; then
        :
    else
        return 255
    fi

    if exist "$2"; then
        chattr_remove "$2"
        unmount "$2"
    fi

    mkdir_parents "$2"

    ln -f "$1" "$2" 2> /dev/null
}

#! .desc:
# Set $user as owner of an object and its parents in $home
#! .params:
# <"$1"> - absolute path
#! .uses:
# [gid] $ - the numerical user primary group ID
# [home] $ - the user directory
# [uid] $ - the numerical user ID
#! .rc:
# (0) success
# (*) error
# (255) bad input
#.
loc_own_user() {
    assert -eq "$#" 1 || return 255

    set -- "${1%"${1##*[!/]}"}"

    exist "$1" && str_pfix "$home"/ "$1" || return 0

    chattr_remove "$1"

    if dir "$1"; then
        chown -RP -- "$uid":"$gid" "$1"
    else
        chown -P -- "$uid":"$gid" "$1"
    fi

    set -- "${1%/*}"
    set -- "${1%"${1##*[!/]}"}"
    until [ "$1" = "$home" ]; do
        chown -P -- "$uid":"$gid" "$1"

        set -- "${1%/*}"
        set -- "${1%"${1##*[!/]}"}"
    done
}

#! .desc:
# Write a binary file at the specified path
#! .uses:
# <FILE> $ - the octal sequence of the file
# <FILE_PATH> $ - the path to write the file at
#! .rc:
# (0) success
# (*) error
# (255) bad usage
#.
__bin_write() {
    if [ ! "$FILE_PATH" ]; then
        _err -red - 'Missing FILE_PATH.'
        return 255
    fi

    if [ ! "$FILE" ]; then
        _info -white - 'Empty FILE. File write cancelled:'
        ftype "$FILE_PATH" -info || :
        info - - " $FILE_PATH"
        return 0
    fi

    if ! is_octal "$FILE"; then
        _err -red - 'Bad FILE; expected octal.'
        return 255
    fi

    while :; do
        if [ "$always_write" = 0 ]; then
            if bin_equiv "$FILE_PATH" "$FILE"; then
                _info -white - 'File write avoided:'
                ftype "$FILE_PATH" -info || :
                info - - " $FILE_PATH"
                break
            fi
        fi

        if [ "$force_write" = 1 ]; then
            loc_delete "$FILE_PATH"
        fi

        if exist "$FILE_PATH"; then
            EEXIST "$FILE_PATH"
        fi

        _info -white - 'Will write a file:'
        ftype "$FILE_PATH" -info || :
        info - - " $FILE_PATH"

        (
            IFS="$LF"' '
            CC=0; for _octal in $FILE; do CC=$((CC + 1)); done
            info -white -- 'CC: '; info - - "$CC"
            info -white -- 'SIZE: '; bytes_size "$CC"
        )

        if ! file_write_octal "$FILE_PATH" "$FILE"; then
            _err -red - 'File write error:'
            ftype "$FILE_PATH" -err || :
            err - - " $FILE_PATH"
            exit 1
        fi
    break; done

    if ! loc_own_user "$FILE_PATH"; then
        EERROR 'Failed to set user permissions.'
    fi
}

#! .desc:
# Write a binary file at the specified path (overwrite path)
#! .uses:
# <FILE> $ - the octal sequence of the file
# <FILE_PATH> $ - the path to write the file at
#! .rc:
# (0) success
# (*) error
# (255) bad usage
#.
__bin_write_overwrite() {
    if [ ! "$FILE_PATH" ]; then
        _err -red - 'Missing FILE_PATH.'
        return 255
    fi

    if [ ! "$FILE" ]; then
        _info -white - 'Empty FILE. File write cancelled:'
        ftype "$FILE_PATH" -info || :
        info - - " $FILE_PATH"
        return 0
    fi

    if ! is_octal "$FILE"; then
        _err -red - 'Bad FILE; expected octal.'
        return 255
    fi

    while :; do
        if [ "$always_write" = 0 ]; then
            if bin_equiv "$FILE_PATH" "$FILE"; then
                _info -white - 'File write avoided:'
                ftype "$FILE_PATH" -info || :
                info - - " $FILE_PATH"
                break
            fi
        fi

        _info -white - 'Will write a file:'
        ftype "$FILE_PATH" -info || :
        info - - " $FILE_PATH"

        (
            IFS="$LF"' '
            CC=0; for _octal in $FILE; do CC=$((CC + 1)); done
            info -white -- 'CC: '; info - - "$CC"
            info -white -- 'SIZE: '; bytes_size "$CC"
        )

        if ! file_write_octal "$FILE_PATH" "$FILE"; then
            _err -red - 'File write error:'
            ftype "$FILE_PATH" -err || :
            err - - " $FILE_PATH"
            exit 1
        fi
    break; done

    if ! loc_own_user "$FILE_PATH"; then
        EERROR 'Failed to set user permissions.'
    fi
}

#! .desc:
# Run a command
#! .params:
# <"$1"> - command
# <"$2">+ -  arguments
#! .rc:
# (0) success
# (*) error
# (255) bad usage
#.
__cmd() {
    cmd "$1" || {
        _err -red - 'Missing command:'

        err -white -- '`'
        err - -- "$1"
        err -white - '`'

        exit 127
    }

    _info -white - 'Running command:'

    info -white -- '`'
    info - -- "$@"
    info -white - '`'

    if [ "$silent_cmd" = 1 ]; then
        command "$@" > /dev/null || return "$?"
    else
        command "$@" || return "$?"
    fi
}

#! .desc:
# Run a command and store output in $FILE
#! .params:
# <"$1"> - command
# <"$2">+ -  arguments
#! .rc:
# (0) success
# (*) error
# (255) bad usage
#.
__FILE_cmd() {
    cmd "$1" || {
        _err -red - 'Missing command:'

        err -white -- '`'
        err - -- "$1"
        err -white - '`'

        exit 127
    }

    _info -white - 'Running command:'

    info -white -- '`'
    info - -- "$@"
    info -white - '`'

    FILE=$(command "$@")
}

#! .desc:
# Copy a directory at the specified path
#! .uses:
# <FILE_PATH> $ - the directory
# <FILE_PATH_TARGET> $ - the path to write the directory at
#! .rc:
# (0) success
# (*) error
# (255) bad usage
#.
__dir_target_write() {
    if [ ! "$FILE_PATH" ]; then
        _err -red - 'Missing FILE_PATH.'
        return 255
    fi

    if [ ! "$FILE_PATH_TARGET" ]; then
        _err -red - 'Missing FILE_PATH_TARGET.'
        return 255
    fi

    if ! exist "$FILE_PATH"; then
        ENOENT;
        ftype "$FILE_PATH" -err || :
        err - - " $FILE_PATH"
        exit 2
    fi

    dir "$FILE_PATH" && readable "$FILE_PATH" || {
        EINVAL;
        ftype "$FILE_PATH" -err || :
        err - - " $FILE_PATH"
        exit 22
    }

    while :; do
        if [ "$force_write" = 1 ]; then
            loc_delete "$FILE_PATH_TARGET"
        fi

        if exist "$FILE_PATH_TARGET"; then
            EEXIST "$FILE_PATH_TARGET"
        fi

        _info -white - 'Will copy from/to:'
        ftype "$FILE_PATH" -info || :
        info - - " $FILE_PATH"
        ftype "$FILE_PATH_TARGET" -info || :
        info - - " $FILE_PATH_TARGET"

        info -white -- '> '
        find "$FILE_PATH"//. ! -name . | grep -c // 2> /dev/null | \
            while IFS= read -r _line0; do
                printf "%s, " "$_line0"

                info -white -- 'D '
                find "$FILE_PATH"//. ! -name . -type d | \
                    grep -c // 2> /dev/null | \
                        while IFS= read -r _line1; do
                            printf "%s, " "$_line1"

                            info -white -- 'F '
                            info - - "$((_line0 - _line1))"
                        done
            done

        if ! dir_write "$FILE_PATH" "$FILE_PATH_TARGET"; then
            _err -red - 'Directory write error:'
            ftype "$FILE_PATH_TARGET" -err || :
            err - - " $FILE_PATH_TARGET"
            exit 1
        fi
    break; done

    if ! loc_own_user "$FILE_PATH_TARGET"; then
        EERROR 'Failed to set user permissions.'
    fi
}

#! .desc:
# Copy a directory at the specified path (overwrite path)
#! .uses:
# <FILE_PATH> $ - the directory
# <FILE_PATH_TARGET> $ - the path to write the directory at
#! .rc:
# (0) success
# (*) error
# (255) bad usage
#.
__dir_target_write_overwrite() {
    if [ ! "$FILE_PATH" ]; then
        _err -red - 'Missing FILE_PATH.'
        return 255
    fi

    if [ ! "$FILE_PATH_TARGET" ]; then
        _err -red - 'Missing FILE_PATH_TARGET.'
        return 255
    fi

    if ! exist "$FILE_PATH"; then
        ENOENT;
        ftype "$FILE_PATH" -err || :
        err - - " $FILE_PATH"
        exit 2
    fi

    dir "$FILE_PATH" && readable "$FILE_PATH" || {
        EINVAL;
        ftype "$FILE_PATH" -err || :
        err - - " $FILE_PATH"
        exit 22
    }

    while :; do
        _info -white - 'Will copy from/to:'
        ftype "$FILE_PATH" -info || :
        info - - " $FILE_PATH"
        ftype "$FILE_PATH_TARGET" -info || :
        info - - " $FILE_PATH_TARGET"

        info -white -- '> '
        find "$FILE_PATH"//. ! -name . | grep -c // 2> /dev/null | \
            while IFS= read -r _line0; do
                printf "%s, " "$_line0"

                info -white -- 'D '
                find "$FILE_PATH"//. ! -name . -type d | \
                    grep -c // 2> /dev/null | \
                        while IFS= read -r _line1; do
                            printf "%s, " "$_line1"

                            info -white -- 'F '
                            info - - "$((_line0 - _line1))"
                        done
            done

        if ! dir_write "$FILE_PATH" "$FILE_PATH_TARGET"; then
            _err -red - 'Directory write error:'
            ftype "$FILE_PATH_TARGET" -err || :
            err - - " $FILE_PATH_TARGET"
            exit 1
        fi
    break; done

    if ! loc_own_user "$FILE_PATH_TARGET"; then
        EERROR 'Failed to set user permissions.'
    fi
}

#! .desc:
# Preload FILE_PATH into FILE
#! .uses:
# <FILE> $
# <FILE_PATH> $ - the file to preload
#! .rc:
# (0) success
# (*) error
# (255) bad usage
#.
__FILE_PATH_preload() {
    if [ ! "$FILE_PATH" ]; then
        _err -red - 'Missing FILE_PATH.'
        return 255
    fi

    if ! exist "$FILE_PATH"; then
        ENOENT;
        ftype "$FILE_PATH" -err || :
        err - - " $FILE_PATH"
        exit 2
    fi

    FILE_preload "$FILE_PATH" || {
        _err -red - 'Error reading file:'
        ftype "$FILE_PATH" -err || :
        err - - " $FILE_PATH"
        exit 1
    }
}

#! .desc:
# Set the executable bits on a file
#! .uses:
# <FILE_PATH> $ - the file
#! .rc:
# (0) success
# (*) error
# (255) bad usage
#.
__file_executable() {
    if [ ! "$FILE_PATH" ]; then
        _err -red - 'Missing FILE_PATH.'
        return 255
    fi

    if ! exist "$FILE_PATH"; then
        ENOENT;
        ftype "$FILE_PATH" -err || :
        err - - " $FILE_PATH"
        exit 2
    fi

    file "$FILE_PATH" || {
        EINVAL;
        ftype "$FILE_PATH" -err || :
        err - - " $FILE_PATH"
        exit 22
    }

    __cmd chmod +x "$FILE_PATH"
}

#! .desc:
# Write a file at the specified path
#! .uses:
# <FILE> $ - the file
# <FILE_PATH> $ - the path to write the file at
#! .rc:
# (0) success
# (*) error
# (255) bad usage
#.
__file_write() {
    if [ ! "$FILE_PATH" ]; then
        _err -red - 'Missing FILE_PATH.'
        return 255
    fi

    if [ ! "$FILE" ]; then
        _info -white - 'Empty FILE. File write cancelled:'
        ftype "$FILE_PATH" -info || :
        info - - " $FILE_PATH"
        return 0
    fi

    while :; do
        if [ "$always_write" = 0 ]; then
            if file_equiv "$FILE_PATH" "$FILE"; then
                _info -white - 'File write avoided:'
                ftype "$FILE_PATH" -info || :
                info - - " $FILE_PATH"
                break
            fi
        fi

        if [ "$force_write" = 1 ]; then
            loc_delete "$FILE_PATH"
        fi

        if exist "$FILE_PATH"; then
            EEXIST "$FILE_PATH"
        fi

        if LOG_written; then
            _info -white - 'File changes:'
            ftype "$FILE_PATH" -info || :
            info - - " $FILE_PATH"
            LOG_print;
        else
            _info -white - 'Will write a file:'
            ftype "$FILE_PATH" -info || :
            info - - " $FILE_PATH"
            if [ "$silent_write" = 0 ]; then
                info -white - '0:'; info - -- "$FILE"
            fi
        fi

        if ! file_write "$FILE_PATH" "$FILE"; then
            _err -red - 'File write error:'
            ftype "$FILE_PATH" -err || :
            err - - " $FILE_PATH"
            exit 1
        fi
    break; done

    if ! loc_own_user "$FILE_PATH"; then
        EERROR 'Failed to set user permissions.'
    fi

    if ! LOG_clear; then
        _err -r - 'Log clear error.'
        exit 1
    fi
}

#! .desc:
# Write a file at the specified path (overwrite path)
#! .uses:
# <FILE> $ - the file
# <FILE_PATH> $ - the path to write the file at
#! .rc:
# (0) success
# (*) error
# (255) bad usage
#.
__file_write_overwrite() {
    if [ ! "$FILE_PATH" ]; then
        _err -red - 'Missing FILE_PATH.'
        return 255
    fi

    if [ ! "$FILE" ]; then
        _info -white - 'Empty FILE. File write cancelled:'
        ftype "$FILE_PATH" -info || :
        info - - " $FILE_PATH"
        return 0
    fi

    while :; do
        if [ "$always_write" = 0 ]; then
            if file_equiv "$FILE_PATH" "$FILE"; then
                _info -white - 'File write avoided:'
                ftype "$FILE_PATH" -info || :
                info - - " $FILE_PATH"
                break
            fi
        fi

        if LOG_written; then
            _info -white - 'File changes:'
            ftype "$FILE_PATH" -info || :
            info - - " $FILE_PATH"
            LOG_print;
        else
            _info -white - 'Will write a file:'
            ftype "$FILE_PATH" -info || :
            info - - " $FILE_PATH"
            if [ "$silent_write" = 0 ]; then
                info -white - '0:'; info - -- "$FILE"
            fi
        fi

        if ! file_write "$FILE_PATH" "$FILE"; then
            _err -red - 'File write error:'
            ftype "$FILE_PATH" -err || :
            err - - " $FILE_PATH"
            exit 1
        fi
    break; done

    if ! loc_own_user "$FILE_PATH"; then
        EERROR 'Failed to set user permissions.'
    fi

    if ! LOG_clear; then
        _err -red - 'Log clear error.'
        exit 1
    fi
}

#! .desc:
# Copy a file at the specified path
#! .uses:
# <FILE_PATH> $ - the directory
# <FILE_PATH_TARGET> $ - the path to write the directory at
#! .rc:
# (0) success
# (*) error
# (255) bad usage
#.
__file_target_write() {
    if [ ! "$FILE_PATH" ]; then
        _err -red - 'Missing FILE_PATH.'
        return 255
    fi

    if [ ! "$FILE_PATH_TARGET" ]; then
        _err -red - 'Missing FILE_PATH_TARGET.'
        return 255
    fi

    if ! exist "$FILE_PATH"; then
        ENOENT;
        ftype "$FILE_PATH" -err || :
        err - - " $FILE_PATH"
        exit 2
    fi

    file "$FILE_PATH" && readable "$FILE_PATH" || {
        EINVAL;
        ftype "$FILE_PATH" -err || :
        err - - " $FILE_PATH"
        exit 22
    }

    while :; do
        if [ "$always_write" = 0 ]; then
            if files_equiv "$FILE_PATH" "$FILE_PATH_TARGET"; then
                _info -white - 'File write avoided:'
                ftype "$FILE_PATH_TARGET" -info || :
                info - - " $FILE_PATH_TARGET"
                break
            fi
        fi

        if [ "$force_write" = 1 ]; then
            loc_delete "$FILE_PATH_TARGET"
        fi

        if exist "$FILE_PATH_TARGET"; then
            EEXIST "$FILE_PATH_TARGET"
        fi

        _info -white - 'Will copy from/to:'
        ftype "$FILE_PATH" -info || :
        info - - " $FILE_PATH"
        ftype "$FILE_PATH_TARGET" -info || :
        info - - " $FILE_PATH_TARGET"

        if ! file_copy "$FILE_PATH" "$FILE_PATH_TARGET"; then
            _err -red - 'File write error:'
            ftype "$FILE_PATH_TARGET" -err || :
            err - - " $FILE_PATH_TARGET"
            exit 1
        fi
    break; done

    if ! loc_own_user "$FILE_PATH_TARGET"; then
        EERROR 'Failed to set user permissions.'
    fi
}

#! .desc:
# Copy a file at the specified path (overwrite path)
#! .uses:
# <FILE_PATH> $ - the directory
# <FILE_PATH_TARGET> $ - the path to write the directory at
#! .rc:
# (0) success
# (*) error
# (255) bad usage
#.
__file_target_write_overwrite() {
    if [ ! "$FILE_PATH" ]; then
        _err -red - 'Missing FILE_PATH.'
        return 255
    fi

    if [ ! "$FILE_PATH_TARGET" ]; then
        _err -red - 'Missing FILE_PATH_TARGET.'
        return 255
    fi

    if ! exist "$FILE_PATH"; then
        ENOENT;
        ftype "$FILE_PATH" -err || :
        err - - " $FILE_PATH"
        exit 2
    fi

    file "$FILE_PATH" && readable "$FILE_PATH" || {
        EINVAL;
        ftype "$FILE_PATH" -err || :
        err - - " $FILE_PATH"
        exit 22
    }

    while :; do
        if [ "$always_write" = 0 ]; then
            if files_equiv "$FILE_PATH" "$FILE_PATH_TARGET"; then
                _info -white - 'File write avoided:'
                ftype "$FILE_PATH_TARGET" -info || :
                info - - " $FILE_PATH_TARGET"
                break
            fi
        fi

        _info -white - 'Will copy from/to:'
        ftype "$FILE_PATH" -info || :
        info - - " $FILE_PATH"
        ftype "$FILE_PATH_TARGET" -info || :
        info - - " $FILE_PATH_TARGET"

        if ! file_copy "$FILE_PATH" "$FILE_PATH_TARGET"; then
            _err -red - 'File write error:'
            ftype "$FILE_PATH_TARGET" -info || :
            err - - " $FILE_PATH_TARGET"
            exit 1
        fi
    break; done

    if ! loc_own_user "$FILE_PATH_TARGET"; then
        EERROR 'Failed to set user permissions.'
    fi
}

#! .desc:
# Set filesystem flags on a file/directory
#! .params:
# <$1> - flag(s) to set
#! .uses:
# <FILE_PATH> $ - the file/directory
#! .rc:
# (0) success
# (*) error
# (255) bad input/usage
#.
__loc_chattr() {
    assert -eq "$#" 1 || return 255

    cmd 'chattr' || return 0

    if [ ! "$FILE_PATH" ]; then
        _err -red - 'Missing FILE_PATH.'
        return 255
    fi

    if ! exist "$FILE_PATH"; then
        ENOENT;
        ftype "$FILE_PATH" -err || :
        err - - " $FILE_PATH"
        exit 2
    fi

    if dir "$FILE_PATH"; then
        :
    elif file "$FILE_PATH"; then
        :
    else
        EINVAL;
        ftype "$FILE_PATH" -err || :
        err - - " $FILE_PATH"
        exit 22
    fi

    __cmd chattr +"$1" "$FILE_PATH"
}

#! .desc:
# Set permissions on a file/directory
#! .params:
# <$1> - octal mode
#! .uses:
# <FILE_PATH> $ - the file/directory
#! .rc:
# (0) success
# (*) error
# (255) bad input/usage
#.
__loc_chmod() {
    assert -eq "$#" 1 || return 255

    if [ ! "$FILE_PATH" ]; then
        _err -red - 'Missing FILE_PATH.'
        return 255
    fi

    if ! exist "$FILE_PATH"; then
        ENOENT;
        ftype "$FILE_PATH" -err || :
        err - - " $FILE_PATH"
        exit 2
    fi

    if dir "$FILE_PATH"; then
        :
    elif file "$FILE_PATH"; then
        :
    else
        EINVAL;
        ftype "$FILE_PATH" -err || :
        err - - " $FILE_PATH"
        exit 22
    fi

    chattr_remove "$FILE_PATH"

    __cmd chmod "$1" "$FILE_PATH"
}

#! .desc:
# Set owner of a file/directory
#! .params:
# <$1> - owner
#! .uses:
# <FILE_PATH> $ - the file/directory
#! .rc:
# (0) success
# (*) error
# (255) bad input/usage
#.
__loc_chown() {
    assert -eq "$#" 1 || return 255

    if [ ! "$FILE_PATH" ]; then
        _err -red - 'Missing FILE_PATH.'
        return 255
    fi

    if ! exist "$FILE_PATH"; then
        ENOENT;
        ftype "$FILE_PATH" -err || :
        err - - " $FILE_PATH"
        exit 2
    fi

    if dir "$FILE_PATH"; then
        :
    elif file "$FILE_PATH"; then
        :
    else
        EINVAL;
        ftype "$FILE_PATH" -err || :
        err - - " $FILE_PATH"
        exit 22
    fi

    chattr_remove "$FILE_PATH"

    __cmd chown -R "$uid":"$gid" "$FILE_PATH"
}

#! .desc:
# Delete a file/directory from the specified path
#! .uses:
# <FILE_PATH> $ - the file/directory
#! .rc:
# (0) success
# (*) error
# (255) bad usage
#.
__loc_delete() {
    if [ ! "$FILE_PATH" ]; then
        _err -red - 'Missing FILE_PATH.'
        return 255
    fi

    if ! exist "$FILE_PATH"; then
        _info -white - 'Already deleted:'
        ftype "$FILE_PATH" -info || :
        info - - " $FILE_PATH"
        return 0
    fi

    _info -white - 'Will delete:'
    ftype "$FILE_PATH" -info || :
    info - - " $FILE_PATH"

    if ! loc_delete "$FILE_PATH"; then
        _err -red - 'Removal error:'
        ftype "$FILE_PATH" -err || :
        err - - " $FILE_PATH"
        exit 1
    fi
}

#! .desc:
# Truncate/empty a file/directory on the specified path
#! .uses:
# <FILE_PATH> $ - the file/directory
#! .rc:
# (0) success
# (*) error
# (255) bad usage
#.
__loc_empty() {
    if [ ! "$FILE_PATH" ]; then
        _err -red - 'Missing FILE_PATH.'
        return 255
    fi

    if dir "$FILE_PATH"; then
        :
    elif file "$FILE_PATH"; then
        :
    elif exist "$FILE_PATH"; then
        EINVAL;
        ftype "$FILE_PATH" -err || :
        err - - " $FILE_PATH"
        exit 22
    fi

    if dir "$FILE_PATH"; then
        _info -white - 'Will empty:'
        ftype "$FILE_PATH" -info || :
        info - - " $FILE_PATH"

        __cmd rm -rf "$FILE_PATH"/*
    else
        if exist "$FILE_PATH"; then
            _info -white - 'Will truncate:'
        else
            _info -white - 'Will create a file:'
        fi
        ftype "$FILE_PATH" -info || :
        info - - " $FILE_PATH"

        if ! { : > "$FILE_PATH"; }; then
            if exist "$FILE_PATH"; then
                _err -red - 'Truncation error:'
            else
                _err -red - 'File creation error:'
            fi
            ftype "$FILE_PATH" -err || :
            err - - " $FILE_PATH"
            exit 1
        fi
    fi
}

#! .desc:
# Create a symbolic link of an object at the specified path (overwrite)
#! .uses:
# <FILE_PATH> $ - the object
# <FILE_PATH_TARGET> $ - the path to write the symbolic link at
#! .rc:
# (0) success
# (*) error
# (255) bad usage
#.
__loc_target_link_overwrite() {
    if [ ! "$FILE_PATH" ]; then
        _err -red - 'Missing FILE_PATH.'
        return 255
    fi

    if [ ! "$FILE_PATH_TARGET" ]; then
        _err -red - 'Missing FILE_PATH_TARGET.'
        return 255
    fi

    if ! { exist "$FILE_PATH" || [ -h "$FILE_PATH" ]; }; then
        ENOENT;
        ftype "$FILE_PATH" -err || :
        err - - " $FILE_PATH"
        exit 2
    fi

    while :; do
        _info -white - 'Will symbolic link source/target:'
        ftype "$FILE_PATH" -info || :
        info - - " $FILE_PATH"
        ftype "$FILE_PATH_TARGET" -info || :
        info - - " $FILE_PATH_TARGET"

        if ! loc_link "$FILE_PATH" "$FILE_PATH_TARGET"; then
            _err -red - 'Symbolic linking error:'
            ftype "$FILE_PATH_TARGET" -err || :
            err - - " $FILE_PATH_TARGET"
            exit 1
        fi
    break; done

    if ! loc_own_user "$FILE_PATH_TARGET"; then
        EERROR 'Failed to set user permissions.'
    fi
}

#! .desc:
# Clone a git repository to $tmpd
#! .params:
# <"$1"> - URL
#! .rc:
# (0) success
# (*) error
# (255) bad input
#.
__git_get() {
    assert -eq "$#" 1 || return 255

    set -- "$@" '--depth' '1'

    if str '/' "$1"; then
        set -- "$@" "$tmpd/${1#"${1%/*}"?}"
    else
        set -- "$@" "$tmpd/$1"
    fi

    __cmd git clone "$@"
}

# $m533ia assertion:
#
# Use laptop's sound card ALC256 instead of HDMI by default
# Fixes: no sound in some applications/games.
#
# [m533ia]$ aplay -l:
# card 0: Generic [HD-Audio Generic], device 3: HDMI 0 [HDMI 0]
#   Subdevices: 1/1
#   Subdevice #0: subdevice #0
# card 1: Generic_1 [HD-Audio Generic], device 0: ALC256 Analog [ALC256 Analog]
#   Subdevices: 1/1
#   Subdevice #0: subdevice #0
_alsa_conf() {
    FILE_PATH \
<<'ASOUND_CONF'
/etc/asound.conf
ASOUND_CONF

    if [ "$audio_hq_resamp" = 1 ]; then
        FILE \
<<'ASOUND_CONF'
defaults.pcm.rate_converter "speexrate_best"
ASOUND_CONF
    else
        FILE \
<<'ASOUND_CONF'
defaults.pcm.rate_converter "speexrate_medium"
ASOUND_CONF
    fi

    if [ "$m533ia" = 1 ]; then
        FILE \
<<'ASOUND_CONF'
defaults.pcm.card 1
defaults.ctl.card 1
ASOUND_CONF
    fi

    __file_write;
}

# "WantedBy", default.target, ensures systemd will try to start the service on
# boot. Since no other services on the system specifies our, moc.service, we
# essentially tell systemd that default.target "wants us" using WantedBy;
# default.target is equal to runlevel 5 in sysvinit if it is an alias for
# graphical.target, otherwise 3-5 if multi-user.target.
# Symlink is created because the service will not be started if there isn't a
# symlink under a directory with name composed of the WantedBy string +
# '.wants' appended.
#
# Without a symbolic link, the service will be ready to start, but
# it will not be started automatically unless manually started or something
# specifies its start.
#
# Sources:
# https://unix.stackexchange.com/a/506374/431300
#
# Hard dependency mark in systemd:
# Requires=<service>
#
# Hard dependency mark + runtime mark in systemd:
# Requires=<service>
# After=<service>
#
# Soft dependency mark in systemd:
# Wants=<service>
#
# Soft dependency mark + runtime mark in systemd:
# Wants=<service>
# After=<service>
#
# In respect to dependencies, `WantedBy=` string will still be respected
# in all cases.
#
# An alternative to systemd shall be considered.
_autostart() {
    if [ "$init" = systemd ]; then
        if [ "$bluetooth" = 1 ]; then
            FILE_PATH \
<<'BLUETOOTH_SERVICE'
/etc/systemd/system/bluetooth.service
BLUETOOTH_SERVICE

            FILE \
<<'BLUETOOTH_SERVICE'
[Unit]
Description=Bluetooth service
Requires=dbus.service
After=dbus.service

[Service]
Type=dbus
BusName=org.bluez
ExecStart=/usr/lib/bluetooth/bluetoothd
TimeoutStopSec=3

[Install]
WantedBy=multi-user.target
BLUETOOTH_SERVICE

            __file_write;

            FILE_PATH \
<<'BLUETOOTH_SERVICE'
/etc/systemd/system/bluetooth.service
BLUETOOTH_SERVICE

            FILE_PATH_TARGET \
<<'BLUETOOTH_SERVICE'
/etc/systemd/system/multi-user.target.wants/bluetooth.service
BLUETOOTH_SERVICE

            __loc_target_link_overwrite;
        else
            FILE_PATH \
<<'BLUETOOTH_SERVICE'
/etc/systemd/system/bluetooth.service
BLUETOOTH_SERVICE

            __loc_delete;

            FILE_PATH \
<<'BLUETOOTH_SERVICE'
/etc/systemd/system/multi-user.target.wants/bluetooth.service
BLUETOOTH_SERVICE

            __loc_delete;
        fi

        if [ "$dns" = localhost ]; then
            if [ "$dns0" = dnsmasq ]; then
                FILE_PATH \
<<'DNSMASQ_SERVICE'
/etc/systemd/system/dnsmasq.service
DNSMASQ_SERVICE

                FILE \
<<'DNSMASQ_SERVICE'
[Unit]
Description=Caching DNS server
Wants=dbus.service

[Service]
Type=simple
ExecStart=/usr/bin/dnsmasq -k --user=dnsmasq
TimeoutStopSec=3

[Install]
WantedBy=multi-user.target
DNSMASQ_SERVICE

                __file_write;

                FILE_PATH \
<<'DNSMASQ_SERVICE'
/etc/systemd/system/dnsmasq.service
DNSMASQ_SERVICE

                FILE_PATH_TARGET \
<<'DNSMASQ_SERVICE'
/etc/systemd/system/multi-user.target.wants/dnsmasq.service
DNSMASQ_SERVICE

                __loc_target_link_overwrite;
            elif [ "dns0" = none ] || [ ! "$dns0" ]; then
                FILE_PATH \
<<'DNSMASQ_SERVICE'
/etc/systemd/system/dnsmasq.service
DNSMASQ_SERVICE

                __loc_delete;

                FILE_PATH \
<<'DNSMASQ_SERVICE'
/etc/systemd/system/multi-user.target.wants/dnsmasq.service
DNSMASQ_SERVICE

                __loc_delete;
            fi
        elif [ "dns" = none ] || [ ! "$dns" ]; then
            FILE_PATH \
<<'DNSMASQ_SERVICE'
/etc/systemd/system/dnsmasq.service
DNSMASQ_SERVICE

            __loc_delete;

            FILE_PATH \
<<'DNSMASQ_SERVICE'
/etc/systemd/system/multi-user.target.wants/dnsmasq.service
DNSMASQ_SERVICE

            __loc_delete;
        fi

        if [ "$m533ia" = 1 ]; then
            FILE_PATH \
<<'EVTEST_GRAB_SERVICE'
/etc/systemd/system/evtest-grab.service
EVTEST_GRAB_SERVICE

            FILE \
<<'EVTEST_GRAB_SERVICE'
[Unit]
Description=Grab m533ia keyboard at startup

[Service]
Type=simple
ExecStart=/bin/bash -c '\
device="$(/usr/bin/awk '\''\
/AT Translated Set 2 keyboard/ { found=1; next } \
found && /Handlers=/ { \
  for (i=1; i<=NF; i++) \
    if ($i ~ /^event[0-9]+$/) { \
      print "/dev/input/" $i; exit \
    } \
}'\'' /proc/bus/input/devices)"; \
exec /usr/bin/evtest --grab "$device"'
User=root
StandardOutput=null

[Install]
WantedBy=multi-user.target
EVTEST_GRAB_SERVICE

            __file_write;

            FILE_PATH \
<<'EVTEST_GRAB_SERVICE'
/etc/systemd/system/evtest-grab.service
EVTEST_GRAB_SERVICE

            FILE_PATH_TARGET \
<<'EVTEST_GRAB_SERVICE'
/etc/systemd/system/multi-user.target.wants/evtest-grab.service
EVTEST_GRAB_SERVICE

            __loc_target_link_overwrite;
        else
            FILE_PATH \
<<'EVTEST_GRAB_SERVICE'
/etc/systemd/system/evtest-grab.service
EVTEST_GRAB_SERVICE

            __loc_delete;

            FILE_PATH \
<<'EVTEST_GRAB_SERVICE'
/etc/systemd/system/multi-user.target.wants/evtest-grab.service
EVTEST_GRAB_SERVICE

            __loc_delete;
        fi

        if [ "$wland" = iwd ]; then
            FILE_PATH \
<<'IWD_SERVICE'
/etc/systemd/system/iwd.service
IWD_SERVICE

            FILE \
<<'IWD_SERVICE'
[Unit]
Description=Wireless service

[Service]
ExecStart=/usr/lib/iwd/iwd

[Install]
WantedBy=multi-user.target
IWD_SERVICE

            __file_write;

            FILE_PATH \
<<'IWD_SERVICE'
/etc/systemd/system/iwd.service
IWD_SERVICE

            FILE_PATH_TARGET \
<<'IWD_SERVICE'
/etc/systemd/system/multi-user.target.wants/iwd.service
IWD_SERVICE

            __loc_target_link_overwrite;
        elif [ "wland" = none ] || [ ! "$wland" ]; then
            FILE_PATH \
<<'IWD_SERVICE'
/etc/systemd/system/iwd.service
IWD_SERVICE

            __loc_delete;

            FILE_PATH \
<<'IWD_SERVICE'
/etc/systemd/system/multi-user.target.wants/iwd.service
IWD_SERVICE

            __loc_delete;
        fi

        if [ "$audio_playerd" = moc ]; then
            FILE_PATH \
<<MOC_SERVICE
$home/.config/systemd/user/moc.service
MOC_SERVICE

            FILE \
<<'MOC_SERVICE'
[Unit]
Description=MOC server

[Service]
RemainAfterExit=yes
ExecStart=/usr/bin/mocp -S
ExecStop=/usr/bin/mocp -x
TimeoutStopSec=3

[Install]
WantedBy=default.target
MOC_SERVICE

            __file_write;

            FILE_PATH \
<<MOC_SERVICE
$home/.config/systemd/user/moc.service
MOC_SERVICE

            FILE_PATH_TARGET \
<<MOC_SERVICE
$home/.config/systemd/user/default.target.wants/moc.service
MOC_SERVICE

            __loc_target_link_overwrite;
        elif [ "audio_playerd" = none ] || [ ! "$audio_playerd" ]; then
            FILE_PATH \
<<MOC_SERVICE
$home/.config/systemd/user/moc.service
MOC_SERVICE

            __loc_delete;

            FILE_PATH \
<<MOC_SERVICE
$home/.config/systemd/user/default.target.wants/moc.service
MOC_SERVICE

            __loc_delete;
        fi

        if [ "$audio_server" = pipewire ]; then
            FILE_PATH \
<<PIPEWIRE_SERVICE
$home/.config/systemd/user/pipewire.service
PIPEWIRE_SERVICE

            FILE \
<<'PIPEWIRE_SERVICE'
[Unit]
Description=PipeWire Multimedia Service

[Service]
ExecStart=/usr/bin/pipewire

[Install]
WantedBy=default.target
PIPEWIRE_SERVICE

            __file_write;

            FILE_PATH \
<<PIPEWIRE_SERVICE
$home/.config/systemd/user/pipewire.service
PIPEWIRE_SERVICE

            FILE_PATH_TARGET \
<<PIPEWIRE_SERVICE
$home/.config/systemd/user/default.target.wants/pipewire.service
PIPEWIRE_SERVICE

            __loc_target_link_overwrite;

            if [ "$pipewire_manager" = pipewire ]; then
                FILE_PATH \
<<PIPEWIRE_MEDIA_SESSION_SERVICE
$home/.config/systemd/user/pipewire-media-session.service
PIPEWIRE_MEDIA_SESSION_SERVICE

                FILE \
<<'PIPEWIRE_MEDIA_SESSION_SERVICE'
[Unit]
Description=PipeWire Media Session Manager
After=pipewire.service
BindsTo=pipewire.service

[Service]
ExecStartPre=/usr/bin/sleep 2
ExecStart=/usr/bin/pipewire-media-session

[Install]
WantedBy=pipewire.service
PIPEWIRE_MEDIA_SESSION_SERVICE

                __file_write;

                FILE_PATH \
<<PIPEWIRE_MEDIA_SESSION_SERVICE
$home/.config/systemd/user/pipewire-media-session.service
PIPEWIRE_MEDIA_SESSION_SERVICE

                FILE_PATH_TARGET \
<<PIPEWIRE_MEDIA_SESSION_SERVICE
$home/.config/systemd/user/pipewire.service.wants/pipewire-media-session.service
PIPEWIRE_MEDIA_SESSION_SERVICE

                __loc_target_link_overwrite;
            elif [ "pipewire_manager" = none ] || [ ! "$pipewire_manager" ]; then
                FILE_PATH \
<<PIPEWIRE_MEDIA_SESSION_SERVICE
$home/.config/systemd/user/pipewire-media-session.service
PIPEWIRE_MEDIA_SESSION_SERVICE

                __loc_delete;

                FILE_PATH \
<<PIPEWIRE_MEDIA_SESSION_SERVICE
$home/.config/systemd/user/pipewire.service.wants/pipewire-media-session.service
PIPEWIRE_MEDIA_SESSION_SERVICE

                __loc_delete;
            fi

            FILE_PATH \
<<PIPEWIRE_PULSE_SERVICE
$home/.config/systemd/user/pipewire-pulse.service
PIPEWIRE_PULSE_SERVICE

            FILE \
<<'PIPEWIRE_PULSE_SERVICE'
[Unit]
Description=PipeWire PulseAudio
After=pipewire.service
BindsTo=pipewire.service

[Service]
ExecStart=/usr/bin/pipewire-pulse

[Install]
WantedBy=pipewire.service
PIPEWIRE_PULSE_SERVICE

            __file_write;

            FILE_PATH \
<<PIPEWIRE_PULSE_SERVICE
$home/.config/systemd/user/pipewire-pulse.service
PIPEWIRE_PULSE_SERVICE

            FILE_PATH_TARGET \
<<PIPEWIRE_PULSE_SERVICE
$home/.config/systemd/user/pipewire.service.wants/pipewire-pulse.service
PIPEWIRE_PULSE_SERVICE

            __loc_target_link_overwrite;
        elif [ "audio_server" = none ] || [ ! "$audio_server" ]; then
            FILE_PATH \
<<PIPEWIRE_SERVICE
$home/.config/systemd/user/pipewire.service
PIPEWIRE_SERVICE

            __loc_delete;

            FILE_PATH \
<<PIPEWIRE_SERVICE
$home/.config/systemd/user/default.target.wants/pipewire.service
PIPEWIRE_SERVICE

            __loc_delete;

            FILE_PATH \
<<PIPEWIRE_MEDIA_SESSION_SERVICE
$home/.config/systemd/user/pipewire-media-session.service
PIPEWIRE_MEDIA_SESSION_SERVICE

            __loc_delete;

            FILE_PATH \
<<PIPEWIRE_MEDIA_SESSION_SERVICE
$home/.config/systemd/user/pipewire.service.wants/pipewire-media-session.service
PIPEWIRE_MEDIA_SESSION_SERVICE

            __loc_delete;

            FILE_PATH \
<<PIPEWIRE_PULSE_SERVICE
$home/.config/systemd/user/pipewire-pulse.service
PIPEWIRE_PULSE_SERVICE

            __loc_delete;

            FILE_PATH \
<<PIPEWIRE_PULSE_SERVICE
$home/.config/systemd/user/pipewire.service.wants/pipewire-pulse.service
PIPEWIRE_PULSE_SERVICE

            __loc_delete;
        fi

        if [ "$portal" = 1 ]; then
            FILE_PATH \
<<XDG_DESKTOP_PORTAL_SERVICE
$home/.config/systemd/user/xdg-desktop-portal.service
XDG_DESKTOP_PORTAL_SERVICE

            FILE \
<<'XDG_DESKTOP_PORTAL_SERVICE'
[Unit]
Description=Portal service
PartOf=graphical-session.target

[Service]
Type=dbus
BusName=org.freedesktop.portal.Desktop
ExecStart=/usr/lib/xdg-desktop-portal
Slice=session.slice
XDG_DESKTOP_PORTAL_SERVICE

            __file_write;

            FILE_PATH \
<<XDG_DESKTOP_PORTAL_GTK_SERVICE
$home/.config/systemd/user/xdg-desktop-portal-gtk.service
XDG_DESKTOP_PORTAL_GTK_SERVICE

            FILE \
<<'XDG_DESKTOP_PORTAL_GTK_SERVICE'
[Unit]
Description=Portal service (GTK/GNOME implementation)
PartOf=graphical-session.target

[Service]
Type=dbus
BusName=org.freedesktop.impl.portal.desktop.gtk
ExecStart=/usr/lib/xdg-desktop-portal-gtk
Slice=session.slice
XDG_DESKTOP_PORTAL_GTK_SERVICE

            __file_write;

            FILE_PATH \
<<XDG_DESKTOP_PORTAL_WLR_SERVICE
$home/.config/systemd/user/xdg-desktop-portal-wlr.service
XDG_DESKTOP_PORTAL_WLR_SERVICE

            FILE \
<<'XDG_DESKTOP_PORTAL_WLR_SERVICE'
[Unit]
Description=Portal service (wlroots implementation)
PartOf=graphical-session.target

[Service]
Type=dbus
BusName=org.freedesktop.impl.portal.desktop.wlr
ExecStart=/usr/lib/xdg-desktop-portal-wlr
Slice=session.slice
XDG_DESKTOP_PORTAL_WLR_SERVICE

            __file_write;

            FILE_PATH \
<<XDG_DOCUMENT_PORTAL_SERVICE
$home/.config/systemd/user/xdg-document-portal.service
XDG_DOCUMENT_PORTAL_SERVICE

            FILE \
<<'XDG_DOCUMENT_PORTAL_SERVICE'
[Unit]
Description=flatpak document portal service
PartOf=graphical-session.target

[Service]
Type=dbus
BusName=org.freedesktop.portal.Documents
ExecStart=/usr/lib/xdg-document-portal
Slice=session.slice
XDG_DOCUMENT_PORTAL_SERVICE

            __file_write;

            FILE_PATH \
<<XDG_PERMISSION_STORE_SERVICE
$home/.config/systemd/user/xdg-permission-store.service
XDG_PERMISSION_STORE_SERVICE

            FILE \
<<'XDG_PERMISSION_STORE_SERVICE'
[Unit]
Description=sandboxed app permission store
PartOf=graphical-session.target

[Service]
Type=dbus
BusName=org.freedesktop.impl.portal.PermissionStore
ExecStart=/usr/lib/xdg-permission-store
Slice=session.slice
XDG_PERMISSION_STORE_SERVICE

            __file_write;
        else
            FILE_PATH \
<<XDG_DESKTOP_PORTAL_SERVICE
$home/.config/systemd/user/xdg-desktop-portal.service
XDG_DESKTOP_PORTAL_SERVICE

            __loc_delete;

            FILE_PATH \
<<XDG_DESKTOP_PORTAL_GTK_SERVICE
$home/.config/systemd/user/xdg-desktop-portal-gtk.service
XDG_DESKTOP_PORTAL_GTK_SERVICE

            __loc_delete;

            FILE_PATH \
<<XDG_DESKTOP_PORTAL_WLR_SERVICE
$home/.config/systemd/user/xdg-desktop-portal-wlr.service
XDG_DESKTOP_PORTAL_WLR_SERVICE

            __loc_delete;

            FILE_PATH \
<<XDG_DOCUMENT_PORTAL_SERVICE
$home/.config/systemd/user/xdg-document-portal.service
XDG_DOCUMENT_PORTAL_SERVICE

            __loc_delete;

            FILE_PATH \
<<XDG_PERMISSION_STORE_SERVICE
$home/.config/systemd/user/xdg-permission-store.service
XDG_PERMISSION_STORE_SERVICE

            __loc_delete;
        fi

        if [ "$arch_linux" = 1 ]; then
            FILE_PATH \
<<'NULL'
/dev/null
NULL

            FILE_PATH_TARGET \
<<'RTKIT_DAEMON_SERVICE'
/etc/systemd/system/rtkit-daemon.service
RTKIT_DAEMON_SERVICE

            __loc_target_link_overwrite;

            FILE_PATH \
<<'NULL'
/dev/null
NULL

            FILE_PATH_TARGET \
<<AT_SPI_DBUS_BUS_SERVICE
$home/.config/systemd/user/at-spi-dbus-bus.service
AT_SPI_DBUS_BUS_SERVICE

            __loc_target_link_overwrite;

            FILE_PATH \
<<'NULL'
/dev/null
NULL

            if [ "$audio_server" = pipewire ]; then
                FILE_PATH_TARGET \
<<PIPEWIRE_SOCKET
$home/.config/systemd/user/pipewire.socket
PIPEWIRE_SOCKET

                __loc_target_link_overwrite;

                FILE_PATH \
<<'NULL'
/dev/null
NULL

                FILE_PATH_TARGET \
<<PIPEWIRE_PULSE_SOCKET
$home/.config/systemd/user/pipewire-pulse.socket
PIPEWIRE_PULSE_SOCKET

                __loc_target_link_overwrite;
            elif [ "audio_server" = none ] || [ ! "$audio_server" ]; then
                FILE_PATH \
<<PIPEWIRE_SOCKET
$home/.config/systemd/user/pipewire.socket
PIPEWIRE_SOCKET

                __loc_delete;

                FILE_PATH \
<<PIPEWIRE_PULSE_SOCKET
$home/.config/systemd/user/pipewire-pulse.socket
PIPEWIRE_PULSE_SOCKET

                __loc_delete;
            fi

            FILE_PATH \
<<ORG_FREEDESKTOP_IMPL_PORTAL_DESKTOP_GTK_SERVICE
$home/.local/share/dbus-1/services/org.freedesktop.impl.portal.desktop.gtk.service
ORG_FREEDESKTOP_IMPL_PORTAL_DESKTOP_GTK_SERVICE

            FILE \
<<'ORG_FREEDESKTOP_IMPL_PORTAL_DESKTOP_GTK_SERVICE'
[D-BUS Service]
Name=org.freedesktop.impl.portal.desktop.gtk
Exec=/usr/bin/true
ORG_FREEDESKTOP_IMPL_PORTAL_DESKTOP_GTK_SERVICE

            __file_write;

            FILE_PATH \
<<ORG_FREEDESKTOP_IMPL_PORTAL_DESKTOP_WLR_SERVICE
$home/.local/share/dbus-1/services/org.freedesktop.impl.portal.desktop.wlr.service
ORG_FREEDESKTOP_IMPL_PORTAL_DESKTOP_WLR_SERVICE

            FILE \
<<'ORG_FREEDESKTOP_IMPL_PORTAL_DESKTOP_WLR_SERVICE'
[D-BUS Service]
Name=org.freedesktop.impl.portal.desktop.wlr
Exec=/usr/bin/true
ORG_FREEDESKTOP_IMPL_PORTAL_DESKTOP_WLR_SERVICE

            __file_write;

            FILE_PATH \
<<ORG_FREEDESKTOP_IMPL_PORTAL_PERMISSIONSTORE_SERVICE
$home/.local/share/dbus-1/services/org.freedesktop.impl.portal.PermissionStore.service
ORG_FREEDESKTOP_IMPL_PORTAL_PERMISSIONSTORE_SERVICE

            FILE \
<<'ORG_FREEDESKTOP_IMPL_PORTAL_PERMISSIONSTORE_SERVICE'
[D-BUS Service]
Name=org.freedesktop.impl.portal.PermissionStore
Exec=/usr/bin/true
ORG_FREEDESKTOP_IMPL_PORTAL_PERMISSIONSTORE_SERVICE

            __file_write;

            FILE_PATH \
<<ORG_FREEDESKTOP_PORTAL_DESKTOP_SERVICE
$home/.local/share/dbus-1/services/org.freedesktop.portal.Desktop.service
ORG_FREEDESKTOP_PORTAL_DESKTOP_SERVICE

            FILE \
<<'ORG_FREEDESKTOP_PORTAL_DESKTOP_SERVICE'
[D-BUS Service]
Name=org.freedesktop.portal.Desktop
Exec=/usr/bin/true
ORG_FREEDESKTOP_PORTAL_DESKTOP_SERVICE

            __file_write;

            FILE_PATH \
<<ORG_FREEDESKTOP_PORTAL_DOCUMENTS_SERVICE
$home/.local/share/dbus-1/services/org.freedesktop.portal.Documents.service
ORG_FREEDESKTOP_PORTAL_DOCUMENTS_SERVICE

            FILE \
<<'ORG_FREEDESKTOP_PORTAL_DOCUMENTS_SERVICE'
[D-BUS Service]
Name=org.freedesktop.portal.Documents
Exec=/usr/bin/true
ORG_FREEDESKTOP_PORTAL_DOCUMENTS_SERVICE

            __file_write;
        else
            FILE_PATH \
<<'RTKIT_DAEMON_SERVICE'
/etc/systemd/system/rtkit-daemon.service
RTKIT_DAEMON_SERVICE

            __loc_delete;

            FILE_PATH \
<<AT_SPI_DBUS_BUS_SERVICE
$home/.config/systemd/user/at-spi-dbus-bus.service
AT_SPI_DBUS_BUS_SERVICE

            __loc_delete;

            FILE_PATH \
<<PIPEWIRE_SOCKET
$home/.config/systemd/user/pipewire.socket
PIPEWIRE_SOCKET

            __loc_delete;

            FILE_PATH \
<<PIPEWIRE_PULSE_SOCKET
$home/.config/systemd/user/pipewire-pulse.socket
PIPEWIRE_PULSE_SOCKET

            __loc_delete;

            FILE_PATH \
<<ORG_FREEDESKTOP_IMPL_PORTAL_DESKTOP_GTK_SERVICE
$home/.local/share/dbus-1/services/org.freedesktop.impl.portal.desktop.gtk.service
ORG_FREEDESKTOP_IMPL_PORTAL_DESKTOP_GTK_SERVICE

            __loc_delete;

            FILE_PATH \
<<ORG_FREEDESKTOP_IMPL_PORTAL_DESKTOP_WLR_SERVICE
$home/.local/share/dbus-1/services/org.freedesktop.impl.portal.desktop.wlr.service
ORG_FREEDESKTOP_IMPL_PORTAL_DESKTOP_WLR_SERVICE

            __loc_delete;

            FILE_PATH \
<<ORG_FREEDESKTOP_IMPL_PORTAL_PERMISSIONSTORE_SERVICE
$home/.local/share/dbus-1/services/org.freedesktop.impl.portal.PermissionStore.service
ORG_FREEDESKTOP_IMPL_PORTAL_PERMISSIONSTORE_SERVICE

            __loc_delete;

            FILE_PATH \
<<ORG_FREEDESKTOP_PORTAL_DESKTOP_SERVICE
$home/.local/share/dbus-1/services/org.freedesktop.portal.Desktop.service
ORG_FREEDESKTOP_PORTAL_DESKTOP_SERVICE

            __loc_delete;

            FILE_PATH \
<<ORG_FREEDESKTOP_PORTAL_DOCUMENTS_SERVICE
$home/.local/share/dbus-1/services/org.freedesktop.portal.Documents.service
ORG_FREEDESKTOP_PORTAL_DOCUMENTS_SERVICE

            __loc_delete;
        fi
    elif [ "init" = none ] || [ ! "$init" ]; then
        FILE_PATH \
<<'BLUETOOTH_SERVICE'
/etc/systemd/system/bluetooth.service
BLUETOOTH_SERVICE

        __loc_delete;

        FILE_PATH \
<<'BLUETOOTH_SERVICE'
/etc/systemd/system/multi-user.target.wants/bluetooth.service
BLUETOOTH_SERVICE

        __loc_delete;

        FILE_PATH \
<<'DNSMASQ_SERVICE'
/etc/systemd/system/dnsmasq.service
DNSMASQ_SERVICE

        __loc_delete;

        FILE_PATH \
<<'DNSMASQ_SERVICE'
/etc/systemd/system/multi-user.target.wants/dnsmasq.service
DNSMASQ_SERVICE

        __loc_delete;

        FILE_PATH \
<<'EVTEST_GRAB_SERVICE'
/etc/systemd/system/evtest-grab.service
EVTEST_GRAB_SERVICE

        __loc_delete;

        FILE_PATH \
<<'EVTEST_GRAB_SERVICE'
/etc/systemd/system/multi-user.target.wants/evtest-grab.service
EVTEST_GRAB_SERVICE

        __loc_delete;

        FILE_PATH \
<<'IWD_SERVICE'
/etc/systemd/system/iwd.service
IWD_SERVICE

        __loc_delete;

        FILE_PATH \
<<'IWD_SERVICE'
/etc/systemd/system/multi-user.target.wants/iwd.service
IWD_SERVICE

        __loc_delete;

        FILE_PATH \
<<MOC_SERVICE
$home/.config/systemd/user/moc.service
MOC_SERVICE

        __loc_delete;

        FILE_PATH \
<<MOC_SERVICE
$home/.config/systemd/user/default.target.wants/moc.service
MOC_SERVICE

        __loc_delete;

        FILE_PATH \
<<PIPEWIRE_SERVICE
$home/.config/systemd/user/pipewire.service
PIPEWIRE_SERVICE

        __loc_delete;

        FILE_PATH \
<<PIPEWIRE_SERVICE
$home/.config/systemd/user/default.target.wants/pipewire.service
PIPEWIRE_SERVICE

        __loc_delete;

        FILE_PATH \
<<PIPEWIRE_MEDIA_SESSION_SERVICE
$home/.config/systemd/user/pipewire-media-session.service
PIPEWIRE_MEDIA_SESSION_SERVICE

        __loc_delete;

        FILE_PATH \
<<PIPEWIRE_MEDIA_SESSION_SERVICE
$home/.config/systemd/user/pipewire.service.wants/pipewire-media-session.service
PIPEWIRE_MEDIA_SESSION_SERVICE

        __loc_delete;

        FILE_PATH \
<<PIPEWIRE_PULSE_SERVICE
$home/.config/systemd/user/pipewire-pulse.service
PIPEWIRE_PULSE_SERVICE

        __loc_delete;

        FILE_PATH \
<<PIPEWIRE_PULSE_SERVICE
$home/.config/systemd/user/pipewire.service.wants/pipewire-pulse.service
PIPEWIRE_PULSE_SERVICE

        __loc_delete;

        FILE_PATH \
<<XDG_DESKTOP_PORTAL_SERVICE
$home/.config/systemd/user/xdg-desktop-portal.service
XDG_DESKTOP_PORTAL_SERVICE

        __loc_delete;

        FILE_PATH \
<<XDG_DESKTOP_PORTAL_GTK_SERVICE
$home/.config/systemd/user/xdg-desktop-portal-gtk.service
XDG_DESKTOP_PORTAL_GTK_SERVICE

        __loc_delete;

        FILE_PATH \
<<XDG_DESKTOP_PORTAL_WLR_SERVICE
$home/.config/systemd/user/xdg-desktop-portal-wlr.service
XDG_DESKTOP_PORTAL_WLR_SERVICE

        __loc_delete;

        FILE_PATH \
<<XDG_DOCUMENT_PORTAL_SERVICE
$home/.config/systemd/user/xdg-document-portal.service
XDG_DOCUMENT_PORTAL_SERVICE

        __loc_delete;

        FILE_PATH \
<<XDG_PERMISSION_STORE_SERVICE
$home/.config/systemd/user/xdg-permission-store.service
XDG_PERMISSION_STORE_SERVICE

        __loc_delete;

        FILE_PATH \
<<'RTKIT_DAEMON_SERVICE'
/etc/systemd/system/rtkit-daemon.service
RTKIT_DAEMON_SERVICE

        __loc_delete;

        FILE_PATH \
<<AT_SPI_DBUS_BUS_SERVICE
$home/.config/systemd/user/at-spi-dbus-bus.service
AT_SPI_DBUS_BUS_SERVICE

        __loc_delete;

        FILE_PATH \
<<PIPEWIRE_SOCKET
$home/.config/systemd/user/pipewire.socket
PIPEWIRE_SOCKET

        __loc_delete;

        FILE_PATH \
<<PIPEWIRE_PULSE_SOCKET
$home/.config/systemd/user/pipewire-pulse.socket
PIPEWIRE_PULSE_SOCKET

        __loc_delete;

        FILE_PATH \
<<ORG_FREEDESKTOP_IMPL_PORTAL_DESKTOP_GTK_SERVICE
$home/.local/share/dbus-1/services/org.freedesktop.impl.portal.desktop.gtk.service
ORG_FREEDESKTOP_IMPL_PORTAL_DESKTOP_GTK_SERVICE

        __loc_delete;

        FILE_PATH \
<<ORG_FREEDESKTOP_IMPL_PORTAL_DESKTOP_WLR_SERVICE
$home/.local/share/dbus-1/services/org.freedesktop.impl.portal.desktop.wlr.service
ORG_FREEDESKTOP_IMPL_PORTAL_DESKTOP_WLR_SERVICE

        __loc_delete;

        FILE_PATH \
<<ORG_FREEDESKTOP_IMPL_PORTAL_PERMISSIONSTORE_SERVICE
$home/.local/share/dbus-1/services/org.freedesktop.impl.portal.PermissionStore.service
ORG_FREEDESKTOP_IMPL_PORTAL_PERMISSIONSTORE_SERVICE

        __loc_delete;

        FILE_PATH \
<<ORG_FREEDESKTOP_PORTAL_DESKTOP_SERVICE
$home/.local/share/dbus-1/services/org.freedesktop.portal.Desktop.service
ORG_FREEDESKTOP_PORTAL_DESKTOP_SERVICE

        __loc_delete;

        FILE_PATH \
<<ORG_FREEDESKTOP_PORTAL_DOCUMENTS_SERVICE
$home/.local/share/dbus-1/services/org.freedesktop.portal.Documents.service
ORG_FREEDESKTOP_PORTAL_DOCUMENTS_SERVICE

        __loc_delete;
    fi
}

_bash_conf() {
    FILE_PATH \
<<_BASH_FUNCTIONS
$home/.bash_functions
_BASH_FUNCTIONS

    FILE \
<<'_BASH_FUNCTIONS'
# System management
sys_pwr_fw() { pwr_fw; }
sys_pwr_off() { pwr_off "$@"; }
sys_pwr_reset() { pwr_reset "$@"; }
sys_pkg_get() { pkg_get "$@"; }
sys_pkg_rm() { pkg_rm "$@"; }
sys_pkg_rmF() { pkg_rmF "$@"; }
sys_pkg_pip_get() { pkg_pip_get "$@"; }
sys_pkg_pip_get_req() { pkg_pip_get_req "$@"; }
sys_pkg_pip_rm() { pkg_pip_rm "$@"; }
sys_up() { up; }
sys_upF() { upF; }

# Package management
pkg_get() (
    case ":$1" in
        :)
            printf "%bERROR:%b No package(s) specified.\n" \
                   "\033[1;31m" "\033[0m"
            exit 2
        ;;
    esac

    ARGS='--sync'

    while [ "$1" ]; do
        ARGS="$ARGS"" \"$1\""
        shift
    done

    eval "su -c 'pacman ${ARGS}'"
)
pkg_rm() (
    case ":$1" in
        :)
            printf "%bERROR:%b No package(s) specified.\n" \
                   "\033[1;31m" "\033[0m"
            exit 2
        ;;
    esac

    ARGS='--remove'
    ARGS="$ARGS"' --nosave'
    ARGS="$ARGS"' --recursive'

    while [ "$1" ]; do
        ARGS="$ARGS"" \"$1\""
        shift
    done

    eval "su -c 'pacman ${ARGS}'"
)
pkg_rmF() (
    case ":$1" in
        :)
            printf "%bERROR:%b No package(s) specified.\n" \
                   "\033[1;31m" "\033[0m"
            exit 2
        ;;
    esac

    ARGS='--remove'
    ARGS="$ARGS"' --nosave'
    ARGS="$ARGS"' --recursive'
    ARGS="$ARGS"' -dd'

    while [ "$1" ]; do
        ARGS="$ARGS"" \"$1\""
        shift
    done

    eval "su -c 'pacman ${ARGS}'"
)
pkg_pip_get() (
    case ":$1" in
        :)
            printf "%bERROR:%b No package(s) specified.\n" \
                   "\033[1;31m" "\033[0m"
            exit 2
        ;;
    esac

    ARGS='-m pip'
    ARGS="$ARGS"' install'
    ARGS="$ARGS"' --user'
    ARGS="$ARGS"' --break-system-packages'

    while [ "$1" ]; do
        ARGS="$ARGS"" \"$1\""
        shift
    done

    eval "python ${ARGS}"
)
pkg_pip_get_req() (
    case ":$1" in
        :)
            printf "%bERROR:%b No file(s) specified.\n" \
                   "\033[1;31m" "\033[0m"
            exit 2
        ;;
    esac

    ARGS='-m pip'
    ARGS="$ARGS"' install'
    ARGS="$ARGS"' --user'
    ARGS="$ARGS"' --break-system-packages'

    while [ "$1" ]; do
        ARGS="$ARGS"" --requirement \"$1\""
        shift
    done

    eval "python ${ARGS}"
)
pkg_pip_rm() (
    case ":$1" in
        :)
            printf "%bERROR:%b No package(s) specified.\n" \
                   "\033[1;31m" "\033[0m"
            exit 2
        ;;
    esac

    ARGS='-m pip'
    ARGS="$ARGS"' uninstall'
    ARGS="$ARGS"' --yes'

    while [ "$1" ]; do
        ARGS="$ARGS"" \"$1\""
        shift
    done

    eval "python ${ARGS}"
)

# Power management
pwr_fw() (
    su -c 'systemctl reboot --firmware-setup'
)
pwr_off() (
    case ":$1" in
        :) su -c 'shutdown -P now' ;;
        *) su -c "shutdown -P $1" ;;
    esac
)
pwr_reset() (
    case ":$1" in
        :) su -c 'shutdown -r now' ;;
        *) su -c "shutdown -r $1" ;;
    esac
)

# Update management
up() (
    ARGS='--sync'
    ARGS="$ARGS"' --refresh'
    ARGS="$ARGS"' --sysupgrade'

    eval "su -c 'pacman ${ARGS}'"
)
upF() (
    ARGS='--sync'
    ARGS="$ARGS"' -yyuu'

    eval "su -c 'pacman ${ARGS}'"
)

# Other management
ramfs_c() (
    su -c "
        [ ! -e /mnt/ramdisk ] || {
            echo 'fail: /mnt/ramdisk already exists'; exit 0
        }
        mkdir /mnt/ramdisk 2> /dev/null
        mount -t ramfs ramfs /mnt/ramdisk && \
        chown $USER:$USER /mnt/ramdisk && \
        chmod 700 /mnt/ramdisk
    "
)
ramfs_d() (
    su -c "
        [ -e /mnt/ramdisk ] || {
            echo 'fail: /mnt/ramdisk does not exist'; exit 0
        }
        umount /mnt/ramdisk && \
        rm -rf /mnt/ramdisk
    "
)

# ffmpeg
ffmpeg_a_get_from() (
    { # Variables expected to be present: OUT, FILENAME.
        handle_err() {
            trap - EXIT
            [ -d "$TMP_DIR" ] && rm -rf "$TMP_DIR"
            [ -d "$DIR" ] && cd "$DIR"
            exit $1
        }; handle_exit() {
            case $1 in
                0) : ;;
                *) handle_err $1 ;;
            esac
            case ":$OUT" in
                :) set -- * ;;
                *) set -- "$OUT" ;;
            esac
            case ":$FILENAME" in
                :)
                    mv "$TMP_DIR"/"$1" "$DIR"/"$1"
                    printf "%bFILE:%b %b%s%b\n" \
                           "\033[1;32m" "\033[0m" "\033[1;37m" \
                           "$DIR/$1" "\033[0m"
                ;;
                *)
                    mv "$TMP_DIR"/"$1" "$DIR"/"${FILENAME}${1#"${1%.*}"}"
                    printf "%bFILE:%b %b%s%b\n" \
                           "\033[1;32m" "\033[0m" "\033[1;37m" \
                           "$DIR/${FILENAME}${1#"${1%.*}"}" "\033[0m"
                ;;
            esac
            [ -d "$TMP_DIR" ] && rm -rf "$TMP_DIR"
            [ -d "$DIR" ] && cd "$DIR"
        }; work() {
            DIR="$PWD"; TMP_DIR="$HOME"/.b81y7yt73627iyqguo9v3ryrand0mstr1ng
            [ -d "$TMP_DIR" ] && rm -rf "$TMP_DIR"
            mkdir "$TMP_DIR"; cd "$TMP_DIR"
        }
        trap "handle_err \$?" INT TERM
        trap "handle_exit \$?" EXIT
        set -e
        work;
    } # Provided variables: DIR; TMP_DIR.

    case ":$1" in
        :)
            printf "%bERROR:%b No time specified.\n" \
                   "\033[1;31m" "\033[0m"
            exit 2
        ;;
    esac
    case ":$2" in
        :)
            printf "%bERROR:%b No file specified.\n" \
                   "\033[1;31m" "\033[0m"
            exit 2
        ;;
    esac

    FROM="$1"
    [ -f "$2" ] && IN="$2" || IN="$DIR/$2"

    if [ ! -f "$IN" ]; then
        printf "%bERROR:%b No file found.\n" \
               "\033[1;31m" "\033[0m"
        exit 2
    fi

    OUT=$(
        printf "%s" "${IN##*/}"
    )

    ARGS="-i \"$IN\" -ss $FROM"
    ARGS="$ARGS"' -c:a copy'
    ARGS="$ARGS"" \"$OUT\""

    eval "ffmpeg ${ARGS}"
)
ffmpeg_a_get_to() (
    { # Variables expected to be present: OUT, FILENAME.
        handle_err() {
            trap - EXIT
            [ -d "$TMP_DIR" ] && rm -rf "$TMP_DIR"
            [ -d "$DIR" ] && cd "$DIR"
            exit $1
        }; handle_exit() {
            case $1 in
                0) : ;;
                *) handle_err $1 ;;
            esac
            case ":$OUT" in
                :) set -- * ;;
                *) set -- "$OUT" ;;
            esac
            case ":$FILENAME" in
                :)
                    mv "$TMP_DIR"/"$1" "$DIR"/"$1"
                    printf "%bFILE:%b %b%s%b\n" \
                           "\033[1;32m" "\033[0m" "\033[1;37m" \
                           "$DIR/$1" "\033[0m"
                ;;
                *)
                    mv "$TMP_DIR"/"$1" "$DIR"/"${FILENAME}${1#"${1%.*}"}"
                    printf "%bFILE:%b %b%s%b\n" \
                           "\033[1;32m" "\033[0m" "\033[1;37m" \
                           "$DIR/${FILENAME}${1#"${1%.*}"}" "\033[0m"
                ;;
            esac
            [ -d "$TMP_DIR" ] && rm -rf "$TMP_DIR"
            [ -d "$DIR" ] && cd "$DIR"
        }; work() {
            DIR="$PWD"; TMP_DIR="$HOME"/.b81y7yt73627iyqguo9v3ryrand0mstr1ng
            [ -d "$TMP_DIR" ] && rm -rf "$TMP_DIR"
            mkdir "$TMP_DIR"; cd "$TMP_DIR"
        }
        trap "handle_err \$?" INT TERM
        trap "handle_exit \$?" EXIT
        set -e
        work;
    } # Provided variables: DIR; TMP_DIR.

    case ":$1" in
        :)
            printf "%bERROR:%b No time specified.\n" \
                   "\033[1;31m" "\033[0m"
            exit 2
        ;;
    esac
    case ":$2" in
        :)
            printf "%bERROR:%b No file specified.\n" \
                   "\033[1;31m" "\033[0m"
            exit 2
        ;;
    esac

    TO="$1"
    [ -f "$2" ] && IN="$2" || IN="$DIR/$2"

    if [ ! -f "$IN" ]; then
        printf "%bERROR:%b No file found.\n" \
               "\033[1;31m" "\033[0m"
        exit 2
    fi

    OUT=$(
        printf "%s" "${IN##*/}"
    )

    ARGS="-t $TO"
    ARGS="$ARGS"" -i \"$IN\""
    ARGS="$ARGS"' -c:a copy'
    ARGS="$ARGS"" \"$OUT\""

    eval "ffmpeg ${ARGS}"
)
ffmpeg_a_get_fromto() (
    { # Variables expected to be present: OUT, FILENAME.
        handle_err() {
            trap - EXIT
            [ -d "$TMP_DIR" ] && rm -rf "$TMP_DIR"
            [ -d "$DIR" ] && cd "$DIR"
            exit $1
        }; handle_exit() {
            case $1 in
                0) : ;;
                *) handle_err $1 ;;
            esac
            case ":$OUT" in
                :) set -- * ;;
                *) set -- "$OUT" ;;
            esac
            case ":$FILENAME" in
                :)
                    mv "$TMP_DIR"/"$1" "$DIR"/"$1"
                    printf "%bFILE:%b %b%s%b\n" \
                           "\033[1;32m" "\033[0m" "\033[1;37m" \
                           "$DIR/$1" "\033[0m"
                ;;
                *)
                    mv "$TMP_DIR"/"$1" "$DIR"/"${FILENAME}${1#"${1%.*}"}"
                    printf "%bFILE:%b %b%s%b\n" \
                           "\033[1;32m" "\033[0m" "\033[1;37m" \
                           "$DIR/${FILENAME}${1#"${1%.*}"}" "\033[0m"
                ;;
            esac
            [ -d "$TMP_DIR" ] && rm -rf "$TMP_DIR"
            [ -d "$DIR" ] && cd "$DIR"
        }; work() {
            DIR="$PWD"; TMP_DIR="$HOME"/.b81y7yt73627iyqguo9v3ryrand0mstr1ng
            [ -d "$TMP_DIR" ] && rm -rf "$TMP_DIR"
            mkdir "$TMP_DIR"; cd "$TMP_DIR"
        }
        trap "handle_err \$?" INT TERM
        trap "handle_exit \$?" EXIT
        set -e
        work;
    } # Provided variables: DIR; TMP_DIR.

    case ":$1" in
        :)
            printf "%bERROR:%b No FROM time specified.\n" \
                   "\033[1;31m" "\033[0m"
            exit 2
        ;;
    esac
    case ":$2" in
        :)
            printf "%bERROR:%b No TO time specified.\n" \
                   "\033[1;31m" "\033[0m"
            exit 2
        ;;
    esac
    case ":$3" in
        :)
            printf "%bERROR:%b No file specified.\n" \
                   "\033[1;31m" "\033[0m"
            exit 2
        ;;
    esac

    FROM="$1"
    TO="$2"
    [ -f "$3" ] && IN="$3" || IN="$DIR/$3"
    

    if [ ! -f "$IN" ]; then
        printf "%bERROR:%b No file found.\n" \
               "\033[1;31m" "\033[0m"
        exit 2
    fi

    OUT=$(
        printf "%s" "${IN##*/}"
    )

    ARGS="-ss $FROM"
    ARGS="$ARGS"" -t $TO"
    ARGS="$ARGS"" -i \"$IN\""
    ARGS="$ARGS"' -c:a copy'
    ARGS="$ARGS"" \"$OUT\""

    eval "ffmpeg ${ARGS}"
)
ffmpeg_merge() (
    { # Variables expected to be present: OUT, FILENAME.
        handle_err() {
            trap - EXIT
            [ -d "$TMP_DIR" ] && rm -rf "$TMP_DIR"
            [ -d "$DIR" ] && cd "$DIR"
            exit $1
        }; handle_exit() {
            case $1 in
                0) : ;;
                *) handle_err $1 ;;
            esac
            case ":$OUT" in
                :) set -- * ;;
                *) set -- "$OUT" ;;
            esac
            case ":$FILENAME" in
                :)
                    mv "$TMP_DIR"/"$1" "$DIR"/"$1"
                    printf "%bFILE:%b %b%s%b\n" \
                           "\033[1;32m" "\033[0m" "\033[1;37m" \
                           "$DIR/$1" "\033[0m"
                ;;
                *)
                    mv "$TMP_DIR"/"$1" "$DIR"/"${FILENAME}${1#"${1%.*}"}"
                    printf "%bFILE:%b %b%s%b\n" \
                           "\033[1;32m" "\033[0m" "\033[1;37m" \
                           "$DIR/${FILENAME}${1#"${1%.*}"}" "\033[0m"
                ;;
            esac
            [ -d "$TMP_DIR" ] && rm -rf "$TMP_DIR"
            [ -d "$DIR" ] && cd "$DIR"
        }; work() {
            DIR="$PWD"; TMP_DIR="$HOME"/.b81y7yt73627iyqguo9v3ryrand0mstr1ng
            [ -d "$TMP_DIR" ] && rm -rf "$TMP_DIR"
            mkdir "$TMP_DIR"; cd "$TMP_DIR"
        }
        trap "handle_err \$?" INT TERM
        trap "handle_exit \$?" EXIT
        set -e
        work;
    } # Provided variables: DIR; TMP_DIR.

    case ":$1" in
        :)
            printf "%bERROR:%b No audio file specified.\n" \
                   "\033[1;31m" "\033[0m"
            exit 2
        ;;
    esac
    case ":$2" in
        :)
            printf "%bERROR:%b No video file specified.\n" \
                   "\033[1;31m" "\033[0m"
            exit 2
        ;;
    esac
    case ":$3" in
        :)
            printf "%bERROR:%b No output name specified.\n" \
                   "\033[1;31m" "\033[0m"
            exit 2
        ;;
    esac

    AUDIO_IN="$DIR/$1"
    VIDEO_IN="$DIR/$2"

    OUT="$3"

    ARGS="-i \"$VIDEO_IN\""
    ARGS="$ARGS"" -i \"$AUDIO_IN\""
    ARGS="$ARGS"' -c:v copy -c:a copy -map 0:v:0 -map 1:a:0'
    ARGS="$ARGS"" \"$OUT\""

    eval "ffmpeg ${ARGS}"
)
ffmpeg_merge_mp4() (
    { # Variables expected to be present: OUT, FILENAME.
        handle_err() {
            trap - EXIT
            [ -d "$TMP_DIR" ] && rm -rf "$TMP_DIR"
            [ -d "$DIR" ] && cd "$DIR"
            exit $1
        }; handle_exit() {
            case $1 in
                0) : ;;
                *) handle_err $1 ;;
            esac
            case ":$OUT" in
                :) set -- * ;;
                *) set -- "$OUT" ;;
            esac
            case ":$FILENAME" in
                :)
                    mv "$TMP_DIR"/"$1" "$DIR"/"$1"
                    printf "%bFILE:%b %b%s%b\n" \
                           "\033[1;32m" "\033[0m" "\033[1;37m" \
                           "$DIR/$1" "\033[0m"
                ;;
                *)
                    mv "$TMP_DIR"/"$1" "$DIR"/"${FILENAME}${1#"${1%.*}"}"
                    printf "%bFILE:%b %b%s%b\n" \
                           "\033[1;32m" "\033[0m" "\033[1;37m" \
                           "$DIR/${FILENAME}${1#"${1%.*}"}" "\033[0m"
                ;;
            esac
            [ -d "$TMP_DIR" ] && rm -rf "$TMP_DIR"
            [ -d "$DIR" ] && cd "$DIR"
        }; work() {
            DIR="$PWD"; TMP_DIR="$HOME"/.b81y7yt73627iyqguo9v3ryrand0mstr1ng
            [ -d "$TMP_DIR" ] && rm -rf "$TMP_DIR"
            mkdir "$TMP_DIR"; cd "$TMP_DIR"
        }
        trap "handle_err \$?" INT TERM
        trap "handle_exit \$?" EXIT
        set -e
        work;
    } # Provided variables: DIR; TMP_DIR.

    case ":$1" in
        :)
            printf "%bERROR:%b No audio file specified.\n" \
                   "\033[1;31m" "\033[0m"
            exit 2
        ;;
    esac
    case ":$2" in
        :)
            printf "%bERROR:%b No video file specified.\n" \
                   "\033[1;31m" "\033[0m"
            exit 2
        ;;
    esac

    AUDIO_IN="$DIR/$1"
    VIDEO_IN="$DIR/$2"

    if [ "$3" ]; then
        case "$OUT" in
            *'.mp4') OUT="$3" ;;
            *) OUT="${3}.mp4" ;;
        esac
    else
        case "$2" in
            *'.mp4') OUT="$2" ;;
            *) OUT="${2}.mp4" ;;
        esac
    fi

    ARGS="-i \"$VIDEO_IN\""
    ARGS="$ARGS"" -i \"$AUDIO_IN\""
    ARGS="$ARGS"' -c:v copy -c:a copy -map 0:v:0 -map 1:a:0'
    ARGS="$ARGS"" \"$OUT\""

    eval "ffmpeg ${ARGS}"
)

# gpg
gpg_d() {
    gpg -o "${1%.gpg}" -d "$1"
}
gpg_e() {
    gpg -r 7D1F56FAD6FB86652A60BEE65BC3343816EAB179 --compress-algo none -e "$1"
}

# steam
:

# tar
tar_c() {
    tar --numeric-owner -cvpf "$1".tar "$1"
}
tar_e() {
    if [ ! -e "$1" ] && [ -e "$1".tar ]; then
        set -- "$1".tar
    fi

    tar --numeric-owner -xvpf "$1"
}

# youtube-dl
:

# yt-dlp
#
# Audio:
# --format 338 - opus/aac[?] ambisonic audio, contained in webm/mp4(m4a)[?]
# --format 258 - 384 kbps 5.1 aac, contained in mp4(m4a)
# --format 327 - 256 kbps 5.1 aac, contained in mp4(m4a)
# --format 141 - 256 kbps aac, contained in mp4(m4a); premium accounts only
# --format 256 - 192 kbps 5.1 aac, contained in mp4(m4a)
# --format 251 - normal opus, contained in webm
# --format 140 - 128 kbps aac, contained in mp4(m4a)
# --format 22  - {128|192} kbps aac premuxed 720p mp4
#
# Video:
# --format ::: - 4320p60 HDR vp9(.2), contained in webm
# --format ::: - 4320p60 HDR av1, contained in mp4
# --format ::: - 4320p30 HDR vp9(.2), contained in webm
# --format ::: - 4320p30 HDR av1, contained in webm
# --format ::: - 4320p60 vp9, contained in webm
# --format ::: - 4320p60 av1, contained in mp4
# --format ::: - 4320p30 vp9, contained in webm
# --format ::: - 4320p30 av1, contained in webm

# --format ::: - 2160p60 HDR vp9(.2), contained in webm
# --format ::: - 2160p60 HDR av1, contained in mp4
# --format ::: - 2160p30 HDR vp9(.2), contained in webm
# --format ::: - 2160p30 HDR av1, contained in webm
# --format ::: - 2160p60 vp9, contained in webm
# --format ::: - 2160p60 av1, contained in mp4
# --format ::: - 2160p30 vp9, contained in webm
# --format ::: - 2160p30 av1, contained in webm

# --format ::: - 1440p60 HDR vp9(.2), contained in webm
# --format ::: - 1440p60 HDR av1, contained in mp4
# --format ::: - 1440p30 HDR vp9(.2), contained in webm
# --format ::: - 1440p30 HDR av1, contained in webm
# --format ::: - 1440p60 vp9, contained in webm
# --format ::: - 1440p60 av1, contained in mp4
# --format ::: - 1440p30 vp9, contained in webm
# --format ::: - 1440p30 av1, contained in webm

# --format ::: - 1080p60 HDR vp9(.2), contained in webm
# --format ::: - 1080p60 HDR av1, contained in mp4
# --format ::: - 1080p30 HDR vp9(.2), contained in webm
# --format ::: - 1080p30 HDR av1, contained in webm
# --format ::: - 1080p60 vp9, contained in webm
# --format ::: - 1080p60 av1, contained in mp4
# --format ::: - 1080p60 avc1, contained in mp4
# --format ::: - 1080p30 vp9, contained in webm
# --format ::: - 1080p30 av1, contained in webm
# --format ::: - 1080p30 avc1, contained in mp4

# --format ::: - 720p60 HDR vp9(.2), contained in webm
# --format ::: - 720p60 HDR av1, contained in mp4
# --format ::: - 720p30 HDR vp9(.2), contained in webm
# --format ::: - 720p30 HDR av1, contained in webm
# --format ::: - 720p60 vp9, contained in webm
# --format ::: - 720p60 av1, contained in mp4
# --format ::: - 720p60 avc1, contained in mp4
# --format ::: - 720p30 vp9, contained in webm
# --format ::: - 720p30 av1, contained in webm
# --format ::: - 720p30 avc1, contained in mp4

# --format ::: - 480p60 HDR vp9(.2), contained in webm
# --format ::: - 480p60 HDR av1, contained in mp4
# --format ::: - 480p30 HDR vp9(.2), contained in webm
# --format ::: - 480p30 HDR av1, contained in webm
# --format ::: - 480p60 vp9, contained in webm
# --format ::: - 480p60 av1, contained in mp4
# --format ::: - 480p60 avc1, contained in mp4
# --format ::: - 480p30 vp9, contained in webm
# --format ::: - 480p30 av1, contained in webm
# --format ::: - 480p30 avc1, contained in mp4

# --format ::: - 360p60 HDR vp9(.2), contained in webm
# --format ::: - 360p60 HDR av1, contained in mp4
# --format ::: - 360p30 HDR vp9(.2), contained in webm
# --format ::: - 360p30 HDR av1, contained in webm
# --format ::: - 360p60 vp9, contained in webm
# --format ::: - 360p60 av1, contained in mp4
# --format ::: - 360p60 avc1, contained in mp4
# --format ::: - 360p30 vp9, contained in webm
# --format ::: - 360p30 av1, contained in webm
# --format ::: - 360p30 avc1, contained in mp4

# --format ::: - 240p60 HDR vp9(.2), contained in webm
# --format ::: - 240p60 HDR av1, contained in mp4
# --format ::: - 240p30 HDR vp9(.2), contained in webm
# --format ::: - 240p30 HDR av1, contained in webm
# --format ::: - 240p60 vp9, contained in webm
# --format ::: - 240p60 av1, contained in mp4
# --format ::: - 240p60 avc1, contained in mp4
# --format ::: - 240p30 vp9, contained in webm
# --format ::: - 240p30 av1, contained in webm
# --format ::: - 240p30 avc1, contained in mp4

# --format ::: - 144p60 HDR vp9(.2), contained in webm
# --format ::: - 144p60 HDR av1, contained in mp4
# --format ::: - 144p30 HDR vp9(.2), contained in webm
# --format ::: - 144p30 HDR av1, contained in webm
# --format ::: - 144p60 vp9, contained in webm
# --format ::: - 144p60 av1, contained in mp4
# --format ::: - 144p60 avc1, contained in mp4
# --format ::: - 144p30 vp9, contained in webm
# --format ::: - 144p30 av1, contained in webm
# --format ::: - 144p30 avc1, contained in mp4
#
# Above formats are YouTube-specific.
# -> Audio formats ordered by quality;
#    when same quality, by psychoacoustic model (codec).
#    --
#    NOTE[1]: Opus should be better, so it is preferred over AAC when available.
# -> Video formats ordered by quality;
#    when same quality, by various parameters (codec).
#    --
#    NOTE[1]: VP9 has better color, so it is preferred over AV1 when available.
#             Source: my eyes + window-over-window comparison.
#    NOTE[2]: At testing phase (2018-????), AV1 had 10-20% better bitrate over
#             VP9. For such videos, AV1 might be the bettter choice overall.
#             Note 1 still stands, though.
#
# FFmpeg code references:
# https://trac.ffmpeg.org/wiki
# https://trac.ffmpeg.org/wiki/Encode/HighQualityAudio
# https://trac.ffmpeg.org/wiki/FFmpeg%20and%20the%20SoX%20Resampler
ytdlp_a() (
    { # Variables expected to be present: OUT, FILENAME.
        handle_err() {
            trap - EXIT
            [ -d "$TMP_DIR" ] && rm -rf "$TMP_DIR"
            [ -d "$DIR" ] && cd "$DIR"
            exit $1
        }; handle_exit() {
            case $1 in
                0) : ;;
                *) handle_err $1 ;;
            esac
            case ":$OUT" in
                :) set -- * ;;
                *) set -- "$OUT" ;;
            esac
            case ":$FILENAME" in
                :)
                    mv "$TMP_DIR"/"$1" "$DIR"/"$1"
                    printf "%bFILE:%b %b%s%b\n" \
                           "\033[1;32m" "\033[0m" "\033[1;37m" \
                           "$DIR/$1" "\033[0m"
                ;;
                *)
                    mv "$TMP_DIR"/"$1" "$DIR"/"${FILENAME}${1#"${1%.*}"}"
                    printf "%bFILE:%b %b%s%b\n" \
                           "\033[1;32m" "\033[0m" "\033[1;37m" \
                           "$DIR/${FILENAME}${1#"${1%.*}"}" "\033[0m"
                ;;
            esac
            [ -d "$TMP_DIR" ] && rm -rf "$TMP_DIR"
            [ -d "$DIR" ] && cd "$DIR"
        }; work() {
            DIR="$PWD"; TMP_DIR="$HOME"/.b81y7yt73627iyqguo9v3ryrand0mstr1ng
            [ -d "$TMP_DIR" ] && rm -rf "$TMP_DIR"
            mkdir "$TMP_DIR"; cd "$TMP_DIR"
        }
        trap "handle_err \$?" INT TERM
        trap "handle_exit \$?" EXIT
        set -e
        work;
    } # Provided variables: DIR; TMP_DIR.

    case ":$1" in
        :)
            printf "%bERROR:%b No URL specified.\n" \
                   "\033[1;31m" "\033[0m"
            exit 2
        ;;
    esac

    URL="$1";
    case ":$2" in
        :) : ;;
        *) FILENAME="$2" ;;
    esac

    yt-dlp_ --cookies-from-browser firefox \
            --extractor-args "youtube:formats=missing_pot" \
            --format 338/258/327/141/256/251/140/22 \
            "$URL"

    IN=$(
        set -- *
        printf "%s" "$1"
    )
    OUT=$(
        case "$IN" in
            *.webm) printf "%s" "${IN%.webm}.opus" ;;
            *.m4a|*.mp4) printf "%s" "${IN%.*}.aac" ;;
            *)
                printf "%bYOUTUBE DID SOMETHING UNEXPECTED.%b\n"
                       "\033[1;31m" "\033[0m" 1>&2
                exit 1
            ;;
        esac
    )

    ARGS='-vn'
    ARGS="$ARGS"' -c:a copy'

    ffmpeg -i "$IN" ${ARGS} "$OUT"
)
ytdlp_a_opus() (
    { # Variables expected to be present: OUT, FILENAME.
        handle_err() {
            trap - EXIT
            [ -d "$TMP_DIR" ] && rm -rf "$TMP_DIR"
            [ -d "$DIR" ] && cd "$DIR"
            exit $1
        }; handle_exit() {
            case $1 in
                0) : ;;
                *) handle_err $1 ;;
            esac
            case ":$OUT" in
                :) set -- * ;;
                *) set -- "$OUT" ;;
            esac
            case ":$FILENAME" in
                :)
                    mv "$TMP_DIR"/"$1" "$DIR"/"$1"
                    printf "%bFILE:%b %b%s%b\n" \
                           "\033[1;32m" "\033[0m" "\033[1;37m" \
                           "$DIR/$1" "\033[0m"
                ;;
                *)
                    mv "$TMP_DIR"/"$1" "$DIR"/"${FILENAME}${1#"${1%.*}"}"
                    printf "%bFILE:%b %b%s%b\n" \
                           "\033[1;32m" "\033[0m" "\033[1;37m" \
                           "$DIR/${FILENAME}${1#"${1%.*}"}" "\033[0m"
                ;;
            esac
            [ -d "$TMP_DIR" ] && rm -rf "$TMP_DIR"
            [ -d "$DIR" ] && cd "$DIR"
        }; work() {
            DIR="$PWD"; TMP_DIR="$HOME"/.b81y7yt73627iyqguo9v3ryrand0mstr1ng
            [ -d "$TMP_DIR" ] && rm -rf "$TMP_DIR"
            mkdir "$TMP_DIR"; cd "$TMP_DIR"
        }
        trap "handle_err \$?" INT TERM
        trap "handle_exit \$?" EXIT
        set -e
        work;
    } # Provided variables: DIR; TMP_DIR.

    :
)
OPUS_CODE_TMP() {
    AUDIO_IN=$(
        set -- *
        printf "%s" "$1"
    )

    case "$AUDIO_IN" in
        *.opus) exit 0 ;;
        *) AUDIO_OUT=$(printf "%s" "${AUDIO_IN%.*}.opus") ;;
    esac

    ARGS=

    ffmpeg -i "$AUDIO_IN" ${ARGS} "$AUDIO_OUT"
}
ytdlp_a_aac() (
    :
)
ytdlp_a_mp3() (
    :
)
ytdlp_a_wav() (
    :
)
ytdlp_a_flac() (
    :
)
ytdlp_s() (
    { # Variables expected to be present: OUT, FILENAME.
        handle_err() {
            trap - EXIT
            [ -d "$TMP_DIR" ] && rm -rf "$TMP_DIR"
            [ -d "$DIR" ] && cd "$DIR"
            exit $1
        }; handle_exit() {
            case $1 in
                0) : ;;
                *) handle_err $1 ;;
            esac
            case ":$OUT" in
                :) set -- * ;;
                *) set -- "$OUT" ;;
            esac
            case ":$FILENAME" in
                :)
                    mv "$TMP_DIR"/"$1" "$DIR"/"$1"
                    printf "%bFILE:%b %b%s%b\n" \
                           "\033[1;32m" "\033[0m" "\033[1;37m" \
                           "$DIR/$1" "\033[0m"
                ;;
                *)
                    mv "$TMP_DIR"/"$1" "$DIR"/"${FILENAME}${1#"${1%.*}"}"
                    printf "%bFILE:%b %b%s%b\n" \
                           "\033[1;32m" "\033[0m" "\033[1;37m" \
                           "$DIR/${FILENAME}${1#"${1%.*}"}" "\033[0m"
                ;;
            esac
            [ -d "$TMP_DIR" ] && rm -rf "$TMP_DIR"
            [ -d "$DIR" ] && cd "$DIR"
        }; work() {
            DIR="$PWD"; TMP_DIR="$HOME"/.b81y7yt73627iyqguo9v3ryrand0mstr1ng
            [ -d "$TMP_DIR" ] && rm -rf "$TMP_DIR"
            mkdir "$TMP_DIR"; cd "$TMP_DIR"
        }
        trap "handle_err \$?" INT TERM
        trap "handle_exit \$?" EXIT
        set -e
        work;
    } # Provided variables: DIR; TMP_DIR.

    case ":$1" in
        :)
            printf "%bERROR:%b No URL specified.\n" \
                   "\033[1;31m" "\033[0m"
            exit 2
        ;;
    esac

    URL="$1";
    case ":$2" in
        :) : ;;
        *) FILENAME="$2" ;;
    esac

    ARGS='--write-sub'
    ARGS="$ARGS"' --skip-download'

    yt-dlp ${ARGS} "$URL"
)
ytdlp_s_srt() (
    { # Variables expected to be present: OUT, FILENAME.
        handle_err() {
            trap - EXIT
            [ -d "$TMP_DIR" ] && rm -rf "$TMP_DIR"
            [ -d "$DIR" ] && cd "$DIR"
            exit $1
        }; handle_exit() {
            case $1 in
                0) : ;;
                *) handle_err $1 ;;
            esac
            case ":$OUT" in
                :) set -- * ;;
                *) set -- "$OUT" ;;
            esac
            case ":$FILENAME" in
                :)
                    mv "$TMP_DIR"/"$1" "$DIR"/"$1"
                    printf "%bFILE:%b %b%s%b\n" \
                           "\033[1;32m" "\033[0m" "\033[1;37m" \
                           "$DIR/$1" "\033[0m"
                ;;
                *)
                    mv "$TMP_DIR"/"$1" "$DIR"/"${FILENAME}${1#"${1%.*}"}"
                    printf "%bFILE:%b %b%s%b\n" \
                           "\033[1;32m" "\033[0m" "\033[1;37m" \
                           "$DIR/${FILENAME}${1#"${1%.*}"}" "\033[0m"
                ;;
            esac
            [ -d "$TMP_DIR" ] && rm -rf "$TMP_DIR"
            [ -d "$DIR" ] && cd "$DIR"
        }; work() {
            DIR="$PWD"; TMP_DIR="$HOME"/.b81y7yt73627iyqguo9v3ryrand0mstr1ng
            [ -d "$TMP_DIR" ] && rm -rf "$TMP_DIR"
            mkdir "$TMP_DIR"; cd "$TMP_DIR"
        }
        trap "handle_err \$?" INT TERM
        trap "handle_exit \$?" EXIT
        set -e
        work;
    } # Provided variables: DIR; TMP_DIR.

    case ":$1" in
        :)
            printf "%bERROR:%b No URL specified.\n" \
                   "\033[1;31m" "\033[0m"
            exit 2
        ;;
    esac

    URL="$1";
    case ":$2" in
        :) : ;;
        *) FILENAME="$2" ;;
    esac

    ARGS='--write-sub'
    ARGS="$ARGS"' --skip-download'

    yt-dlp ${ARGS} "$URL"

    IN=$(
        set -- *
        printf "%s" "$1"
    )
    OUT=$(
        printf "%s" "${IN%.*}.srt"
    )

    ffmpeg -i "$IN" "$OUT"
)
ytdlp_s_auto() (
    { # Variables expected to be present: OUT, FILENAME.
        handle_err() {
            trap - EXIT
            [ -d "$TMP_DIR" ] && rm -rf "$TMP_DIR"
            [ -d "$DIR" ] && cd "$DIR"
            exit $1
        }; handle_exit() {
            case $1 in
                0) : ;;
                *) handle_err $1 ;;
            esac
            case ":$OUT" in
                :) set -- * ;;
                *) set -- "$OUT" ;;
            esac
            case ":$FILENAME" in
                :)
                    mv "$TMP_DIR"/"$1" "$DIR"/"$1"
                    printf "%bFILE:%b %b%s%b\n" \
                           "\033[1;32m" "\033[0m" "\033[1;37m" \
                           "$DIR/$1" "\033[0m"
                ;;
                *)
                    mv "$TMP_DIR"/"$1" "$DIR"/"${FILENAME}${1#"${1%.*}"}"
                    printf "%bFILE:%b %b%s%b\n" \
                           "\033[1;32m" "\033[0m" "\033[1;37m" \
                           "$DIR/${FILENAME}${1#"${1%.*}"}" "\033[0m"
                ;;
            esac
            [ -d "$TMP_DIR" ] && rm -rf "$TMP_DIR"
            [ -d "$DIR" ] && cd "$DIR"
        }; work() {
            DIR="$PWD"; TMP_DIR="$HOME"/.b81y7yt73627iyqguo9v3ryrand0mstr1ng
            [ -d "$TMP_DIR" ] && rm -rf "$TMP_DIR"
            mkdir "$TMP_DIR"; cd "$TMP_DIR"
        }
        trap "handle_err \$?" INT TERM
        trap "handle_exit \$?" EXIT
        set -e
        work;
    } # Provided variables: DIR; TMP_DIR.

    case ":$1" in
        :)
            printf "%bERROR:%b No URL specified.\n" \
                   "\033[1;31m" "\033[0m"
            exit 2
        ;;
    esac

    URL="$1";
    case ":$2" in
        :) : ;;
        *) FILENAME="$2" ;;
    esac

    ARGS='--write-auto-sub'
    ARGS="$ARGS"' --skip-download'

    yt-dlp ${ARGS} "$URL"
)
ytdlp_s_auto_srt() (
    { # Variables expected to be present: OUT, FILENAME.
        handle_err() {
            trap - EXIT
            [ -d "$TMP_DIR" ] && rm -rf "$TMP_DIR"
            [ -d "$DIR" ] && cd "$DIR"
            exit $1
        }; handle_exit() {
            case $1 in
                0) : ;;
                *) handle_err $1 ;;
            esac
            case ":$OUT" in
                :) set -- * ;;
                *) set -- "$OUT" ;;
            esac
            case ":$FILENAME" in
                :)
                    mv "$TMP_DIR"/"$1" "$DIR"/"$1"
                    printf "%bFILE:%b %b%s%b\n" \
                           "\033[1;32m" "\033[0m" "\033[1;37m" \
                           "$DIR/$1" "\033[0m"
                ;;
                *)
                    mv "$TMP_DIR"/"$1" "$DIR"/"${FILENAME}${1#"${1%.*}"}"
                    printf "%bFILE:%b %b%s%b\n" \
                           "\033[1;32m" "\033[0m" "\033[1;37m" \
                           "$DIR/${FILENAME}${1#"${1%.*}"}" "\033[0m"
                ;;
            esac
            [ -d "$TMP_DIR" ] && rm -rf "$TMP_DIR"
            [ -d "$DIR" ] && cd "$DIR"
        }; work() {
            DIR="$PWD"; TMP_DIR="$HOME"/.b81y7yt73627iyqguo9v3ryrand0mstr1ng
            [ -d "$TMP_DIR" ] && rm -rf "$TMP_DIR"
            mkdir "$TMP_DIR"; cd "$TMP_DIR"
        }
        trap "handle_err \$?" INT TERM
        trap "handle_exit \$?" EXIT
        set -e
        work;
    } # Provided variables: DIR; TMP_DIR.

    case ":$1" in
        :)
            printf "%bERROR:%b No URL specified.\n" \
                   "\033[1;31m" "\033[0m"
            exit 2
        ;;
    esac

    URL="$1";
    case ":$2" in
        :) : ;;
        *) FILENAME="$2" ;;
    esac

    ARGS='--write-auto-sub'
    ARGS="$ARGS"' --skip-download'

    yt-dlp ${ARGS} "$URL"

    IN=$(
        set -- *
        printf "%s" "$1"
    )
    OUT=$(
        printf "%s" "${IN%.*}.srt"
    )

    ffmpeg -i "$IN" "$OUT"
)
ytdlp_ramfs() (
    [ -e /mnt/ramdisk ] || {
        echo 'fail: /mnt/ramdisk does not exist'; return 0
    }
    yt-dlp --no-part --no-cache-dir -P /mnt/ramdisk "$@"
)

# unfinished
ytdlp_v() (
    { # Variables expected to be present: OUT, FILENAME.
        handle_err() {
            trap - EXIT
            [ -d "$TMP_DIR" ] && rm -rf "$TMP_DIR"
            [ -d "$DIR" ] && cd "$DIR"
            exit $1
        }; handle_exit() {
            case $1 in
                0) : ;;
                *) handle_err $1 ;;
            esac
            case ":$OUT" in
                :) set -- * ;;
                *) set -- "$OUT" ;;
            esac
            case ":$FILENAME" in
                :)
                    mv "$TMP_DIR"/"$1" "$DIR"/"$1"
                    printf "%bFILE:%b %b%s%b\n" \
                           "\033[1;32m" "\033[0m" "\033[1;37m" \
                           "$DIR/$1" "\033[0m"
                ;;
                *)
                    mv "$TMP_DIR"/"$1" "$DIR"/"${FILENAME}${1#"${1%.*}"}"
                    printf "%bFILE:%b %b%s%b\n" \
                           "\033[1;32m" "\033[0m" "\033[1;37m" \
                           "$DIR/${FILENAME}${1#"${1%.*}"}" "\033[0m"
                ;;
            esac
            [ -d "$TMP_DIR" ] && rm -rf "$TMP_DIR"
            [ -d "$DIR" ] && cd "$DIR"
        }; work() {
            DIR="$PWD"; TMP_DIR="$HOME"/.b81y7yt73627iyqguo9v3ryrand0mstr1ng
            [ -d "$TMP_DIR" ] && rm -rf "$TMP_DIR"
            mkdir "$TMP_DIR"; cd "$TMP_DIR"
        }
        trap "handle_err \$?" INT TERM
        trap "handle_exit \$?" EXIT
        set -e
        work;
    } # Provided variables: DIR; TMP_DIR.

    :
)
V_CODE_TMP() {
    URL="$1"; [ "$2" ] && FILENAME="$2" || FILENAME=

    ARGS='--format'
    ARGS="$ARGS"' 338/258/327/141/256/251/140/22'

    yt-dlp ${ARGS} "$URL"

    AUDIO_IN=$(
        set -- *
        printf "%s" "$1"
    )
    AUDIO_OUT=$(
        case "$AUDIO_IN" in
            *.webm) printf "%s" "${AUDIO_IN%.webm}.opus" ;;
            *.m4a|*.mp4) printf "%s" "${AUDIO_IN%.*}.aac" ;;
            *)
                printf "%bYOUTUBE DID SOMETHING UNEXPECTED.%b\n" "\033[1;31m" \
                                                                 "\033[0m" 1>&2
                exit 1
            ;;
        esac
    )

    ARGS='-vn'
    ARGS="$ARGS"' -c:a copy'

    ffmpeg -i "$AUDIO_IN" ${ARGS} "$AUDIO_OUT"

    ARGS='--format'
    ARGS="$ARGS"' bestvideo'

    yt-dlp ${ARGS} "$URL"

    VIDEO_IN=$(
        set -- *
        [ "$1" = "$AUDIO_OUT" ] && printf "%s" "$2" || printf "%s" "$1"
    )
    VIDEO_OUT=$(
        :
    )

    :
}
ytdlp_v_1080() (
    :
)
ytdlp_v_webm() (
    :
)
ytdlp_v_webm_1080() (
    :
)
ytdlp_v_mp4() (
    :
)
ytdlp_v_mp4_1080() (
    :
)
ytdlp_v_mkv() (
    :
)
ytdlp_v_mkv_1080() (
    :
)
ytdlp_v_ogg() (
    :
)
ytdlp_v_ogg_1080() (
    :
)
steamwinerun() ( WINEPREFIX="$HOME"/.steam/root/steamapps/compatdata/$1/pfx wine "$2"; )
dgrd() (
    if [ ! "$1" ] || [ ! "$2" ]; then
        printf "%s\n" 'STEP (1-X) = $1'
        printf "%s\n" 'NAME = $2+'
        exit 2
    fi

    STEP="$1"; shift
    DIR=/var/cache/pacman/pkg
    OUT_FLAG=0

    while [ "$#" -ge 1 ]; do
        NAME="$1"
        FILES=$(
            find "$DIR" -name "$NAME"-[0123456789]*.zst -printf "%T+ %p\n" | \
            sort -r
        )

        if [ ! "$FILES" ]; then
            printf "%s\n" 'ERR NO FILES. NAME=%s' "$NAME"
            exit 1
        fi

        x=0; while IFS= read -r LINE; do
            [ "$x" = "$STEP" ] || { x=$((x + 1)); continue; }

            LINE="${LINE#* }"
            if [ "$OUT_FLAG" = 0 ]; then
                printf "%s\n" 'pacman -U \'
                OUT_FLAG=1
            fi
            if [ "$2" ]; then
                printf "%s %s\n" "$LINE" '\'
            else
                printf "%s\n" "$LINE"
            fi
            shift; continue 2
        done <<EOF
$FILES
EOF

        printf "ERR PKG DGRD STEP NO EXIST. x=%s\n" "$x"
        exit 1
    done
)
ytv() { youtube-dl --format bestvideo+bestaudio "$1"; }
ytv1080() { youtube-dl --format bestvideo[height<=1080]+bestaudio "$1"; }
ipv6disable() { su -c 'sysctl -w net.ipv6.conf.all.disable_ipv6=1; sysctl -w net.ipv6.conf.default.disable_ipv6=1'; }
ipv6enable() { su -c 'sysctl -w net.ipv6.conf.all.disable_ipv6=0; sysctl -w net.ipv6.conf.default.disable_ipv6=0'; }
_BASH_FUNCTIONS

    __file_write;

    FILE_PATH \
<<_BASHRC
$home/.bashrc
_BASHRC

    FILE \
<<'_BASHRC'
# Don't parse .bashrc if not running interactively
[[ $- != *i* ]] && return

PS1=\
'\[\033[1;32m\]['\
"\$(\
RC=\$?; \
[ "\$RC" -eq 0 ] \
    && printf "%s%d" '\[\033[1;32m\]' "\$RC" \
    || printf "%s%d" '\[\033[1;33m\]' "\$RC" \
)"' '\
'\[\033[1;36m\]\u@\h '\
'\[\033[1;31m\]\W\[\033[1;32m\]]\$\[\033[0m\] '

export HISTCONTROL=ignoreboth:erasedups
export PATH="${PATH}:$HOME/.local/bin:$HOME/scripts"
export EDITOR=nano

alias ls='ls --color'
alias grep='grep --color=always'
alias ip='ip --color'
alias clr='tput reset; stty -ixon susp undef'
alias gfix='git add .; git commit --amend --date="now" -s'
alias gfixf='git add .; git commit --amend --date="now" --no-edit -s'
alias gchk='git diff --check HEAD~10'

# Source useful custom functions
[ -f "$HOME"/.bash_functions ] && . "$HOME"/.bash_functions

# '-ixon': Disable "Ctrl + S"; WHY IS THIS STILL DEFAULT?
# 'susp undef': Disable "Ctrl + Z"
stty -ixon susp undef
_BASHRC

    __file_write;
}

_bluez_conf() {
    FILE_PATH \
<<'MAIN_CONF'
/etc/bluetooth/main.conf
MAIN_CONF

    FILE \
<<'MAIN_CONF'
[General]
Name = gUcciestBlueZ420
DiscoverableTimeout = 0
FastConnectable = true

[Policy]
AutoEnable=false
ReconnectAttempts=3
ReconnectIntervals=2,8,16
MAIN_CONF

    __file_write_overwrite;
}

# RTC clock sync using the closest NTP server (pool.ntp.org)
_clk_sync() {
    __cmd ntpd -gGLnq pool.ntp.org
    __cmd hwclock -w
}

# Software configuration - stage 1
#
# State-of-the-art config:
# > never overwrites or overwritten.
#
# Run stage 1 at any time of -- initial -- system configuration with:
# > the full filesystem mounted and user dir provided ($home; $user).
#
# The following functions shall -- only -- be defined in _conf_4() if they
# are influenced by utility switches; never to be defined in any other _conf_*()
# functions.
_conf_1() {
    _alsa_conf;
    _bash_conf;
    _doas_conf;
    _face_bin;
    _fontconfig_conf;
    _git_conf;
    _gtk_conf;
    _hostname;
    _imv_conf;
    _iwd_conf;
    _kitty_conf;
    _kvantum_conf;
    _moc_conf;
    _modprobe_conf;
    _mpv_conf;
    _mutt_conf;
    _nano_conf;
    _openal_conf;
    _pipewire_conf;
    _pipewire_media_session_conf;
    _ranger_conf;
    _sudo_conf;
    _sway_conf;
    _swaylock_conf;
    _sysctl_conf;
    _xdg_conf;
}

# Software configuration - stage 2
#
# Config might:
# > overwrite or be overwritten.
# > depend on installed software.
#
# Function might:
# > require $force_write
#
# Run stage 2 at any time of -- desired -- system configuration with:
# > the full filesystem mounted and user dir provided ($home; $user).
# > the output parsed to understand what is not yet being configured.
#
# The following functions shall -- only -- be defined in _conf_4() if they
# are influenced by utility switches; never to be defined in any other _conf_*()
# functions.
_conf_2() {
    _autostart;
    _env;
    _featherpad_conf;
    _hosts;
    _locale;
    _reflector;
    _resolv_conf;
    _sh;
    _tz;

    if file '/etc/dhcpcd.conf'; then
        _dhcpcd_conf;
    else
        _info -yellow - 'Skipped _dhcpcd_conf()'
    fi

    if file '/etc/dnsmasq.conf'; then
        _dnsmasq_conf;
    else
        _info -yellow - 'Skipped _dnsmasq_conf()'
    fi

    if file '/etc/gai.conf'; then
        _gai_conf;
    else
        _info -yellow - 'Skipped _gai_conf()'
    fi

    if cmd 'grub-install' && cmd 'grub-mkconfig'; then
        _grub;

        if file '/etc/default/grub'; then
            _grub_conf;
        else
            _info -yellow - 'Skipped _grub_conf()'
        fi
    else
        _info -yellow - 'Skipped _grub()'
        _info -yellow - 'Skipped _grub_conf()'
    fi

    if file '/etc/mkinitcpio.conf'; then
        _initramfs_conf;
    else
        _info -yellow - 'Skipped _initramfs_conf()'
    fi

    if file '/etc/makepkg.conf'; then
        _makepkg_conf;
    else
        _info -yellow - 'Skipped _makepkg_conf()'
    fi

    if file '/etc/pacman.conf'; then
        _pacman_conf;
    else
        _info -yellow - 'Skipped _pacman_conf()'
    fi

    if file '/etc/security/faillock.conf' && \
       file '/etc/login.defs' && \
       file '/etc/pam.d/su' && \
       file '/etc/pam.d/system-auth'; then
        _pam_conf;
    else
        _info -yellow - 'Skipped _pam_conf()'
    fi
}

# Software configuration - stage 3
#
# Config might:
# > overwrite or be overwritten.
# > depend on specific installed software.
# > depend on ever-executed software.
#
# Function might:
# > require $force_write
#
# Run stage 3 at any time of -- desired -- system configuration with:
# > the full filesystem mounted and user dir provided ($home; $user).
# > the output parsed to understand what is not yet being configured.
#
# The following functions shall -- only -- be defined in _conf_4() if they
# are influenced by utility switches; never to be defined in any other _conf_*()
# functions.
_conf_3() {
    if file '/etc/bluetooth/main.conf'; then
        _bluez_conf;
    else
        _info -yellow - 'Skipped _bluez_conf()'
    fi

    if file "$home"/'.mozilla/firefox/profiles.ini'; then
        _firefox_conf;
    else
        _info -yellow - 'Skipped _firefox_conf()'
    fi

    if file '/etc/fuse.conf'; then
        _fuse_conf;
    else
        _info -yellow - 'Skipped _fuse_conf()'
    fi
}

# Software configuration - stage 4
#
# Config is:
# > influenced by utility switches.
#
# Config might:
# > overwrite or be overwritten.
# > depend on specific installed software.
# > depend on ever-executed software.
#
# Function might:
# > require $force_write
#
# Run stage 4 at any time of -- desired -- system configuration with:
# > the full filesystem mounted and user dir provided ($home; $user).
# > the intent of reproducing the currently declared configuration.
_conf_4() {
    _alsa_conf;
    _autostart;
    _env;
    _hostname;
    _hosts;
    _iwd_conf;
    _pipewire_conf;
    _pipewire_media_session_conf;
    _reflector;
    _resolv_conf;
    _sh;
    _sway_conf;
    _tz;

    if file '/etc/dhcpcd.conf'; then
        _dhcpcd_conf;
    fi

    if file '/etc/dnsmasq.conf'; then
        _dnsmasq_conf;
    fi

    if file '/etc/gai.conf'; then
        _gai_conf;
    fi

    if cmd 'grub-mkconfig' && file '/etc/default/grub'; then
        _grub_conf;
    fi

    if file '/etc/mkinitcpio.conf'; then
        _initramfs_conf;
    fi
}

_dhcpcd_conf() {
    FILE_PATH \
<<'DHCPCD_CONF'
/etc/dhcpcd.conf
DHCPCD_CONF

    if [ "$ipv6" = 1 ]; then
        FILE \
<<'DHCPCD_CONF'
static domain_name_servers=::1 127.0.0.1
slaac private
duid
noipv4ll

DHCPCD_CONF
    else
        FILE \
<<'DHCPCD_CONF'
static domain_name_servers=127.0.0.1
slaac hwaddr
clientid
noipv6rs
noipv6

DHCPCD_CONF
    fi

    FILE \
<<'DHCPCD_CONF'
option classless_static_routes
option interface_mtu
option host_name
option rapid_commit
require dhcp_server_identifier
vendorclassid

noarp
nohook resolv.conf
DHCPCD_CONF

    __file_write_overwrite;
}

# DNS stub resolver configuration
_dnsmasq_conf() {
    FILE_PATH \
<<'DNSMASQ_CONF'
/etc/dnsmasq.conf
DNSMASQ_CONF

    FILE \
<<'DNSMASQ_CONF'
bind-interfaces
cache-size=2048
domain-needed
bogus-priv
no-resolv
no-poll
no-hosts
no-negcache
dnssec
dnssec-check-unsigned
trust-anchor=.,20326,8,2,E06D44B80B8F1D39A95C0B0D7C65D08458E880409BBC683457104237C7F8EC8D
trust-anchor=.,38696,8,2,683D2D0ACB8C9B712A1948B27F741219298D0A450D612C483AF444A4C0FB2B16
all-servers
DNSMASQ_CONF

    if [ "$ipv6" = 1 ]; then
        FILE \
<<'DNSMASQ_CONF'
listen-address=::1,127.0.0.1
server=2606:4700:4700::1111
server=2606:4700:4700::1001
server=2620:119:35::35
server=2620:119:53::53
server=2001:4860:4860::8888
server=2001:4860:4860::8844
server=2620:fe::fe
server=2620:fe::9
server=1.1.1.1
server=1.0.0.1
server=208.67.222.222
server=208.67.220.220
server=8.8.8.8
server=8.8.4.4
server=9.9.9.9
server=149.112.112.112
DNSMASQ_CONF
    else
        FILE \
<<'DNSMASQ_CONF'
listen-address=127.0.0.1
server=1.1.1.1
server=1.0.0.1
server=208.67.222.222
server=208.67.220.220
server=8.8.8.8
server=8.8.4.4
server=9.9.9.9
server=149.112.112.112
DNSMASQ_CONF
    fi

    __file_write_overwrite;
}

_doas_conf() {
    FILE_PATH \
<<'DOAS_CONF'
/etc/doas.conf
DOAS_CONF

    FILE \
<<'DOAS_CONF'
permit persist :wheel as root
DOAS_CONF

    __file_write;
    __loc_chmod '0400'
}

_env() {
    FILE_PATH \
<<BROWSER
$home/.syscfg_env/browser
BROWSER

    if [ "$browser" = firefox ] && [ "$display_server" = wayland ]; then
        FILE \
<<'BROWSER'
MOZ_ENABLE_WAYLAND=1
BROWSER

        __file_write_overwrite;
    elif [ "browser" = none ] || [ ! "$browser" ] || \
        [ "display_server" = none ] || [ ! "$display_server" ]; then
        __loc_delete;
    fi

    FILE_PATH \
<<QT_THEME
$home/.syscfg_env/qt_theme
QT_THEME

    if [ "$qt_theme" = kvantum ]; then
        FILE \
<<'QT_THEME'
QT_STYLE_OVERRIDE=kvantum
QT_THEME

        __file_write_overwrite;
    elif [ "qt_theme" = none ] || [ ! "$qt_theme" ]; then
        __loc_delete;
    fi

    FILE_PATH \
<<DISPLAY_SERVER
$home/.syscfg_env/display_server
DISPLAY_SERVER

    if [ "$display_server" = wayland ]; then
        FILE \
<<'DISPLAY_SERVER'
QT_QPA_PLATFORM=wayland
QT_WAYLAND_DISABLE_WINDOWDECORATION=1
SDL_VIDEODRIVER=wayland
GDK_BACKEND=wayland
DISPLAY_SERVER

        if [ "$portal" = 1 ]; then
            FILE \
<<'DISPLAY_SERVER'
GTK_USE_PORTAL=1
DISPLAY_SERVER
        else
            FILE \
<<'DISPLAY_SERVER'
GTK_USE_PORTAL=0
DISPLAY_SERVER
        fi

        __file_write_overwrite;
    elif [ "$display_server" = none ] || [ ! "$display_server" ]; then
        __loc_delete;
    fi

    FILE_PATH \
<<WM
$home/.syscfg_env/wm
WM

    if [ "$wm" = sway ]; then
        FILE \
<<'WM'
XDG_CURRENT_DESKTOP=sway
XDG_SESSION_DESKTOP=sway
DESKTOP_SESSION=sway
WM

        __file_write_overwrite;
    elif [ "$wm" = none ] || [ ! "$wm" ]; then
        __loc_delete;
    fi

    FILE_PATH \
<<_BASH_PROFILE
$home/.bash_profile
_BASH_PROFILE

    FILE \
<<'_BASH_PROFILE'
set -a; for file in "$HOME"/.syscfg_env/*; do
    . "$file"
done; set +a
_BASH_PROFILE

    if [ "$wm" = sway ]; then
        FILE \
<<'_BASH_PROFILE'

if [ -z "$DISPLAY" ] && [ "$(tty)" = '/dev/tty1' ]; then
    if command -v sway > /dev/null 2>&1; then
        exec sway > /var/log/sway.log 2>&1
    fi
fi
_BASH_PROFILE
    fi

    __file_write;

    if [ "$wm" = sway ]; then
        FILE_PATH \
<<'SWAY_LOG'
/var/log/sway.log
SWAY_LOG

        __loc_empty;
        __loc_chmod '0644'
        __loc_chown "$user"
    else
        FILE_PATH \
<<'SWAY_LOG'
/var/log/sway.log
SWAY_LOG

        __loc_delete;
    fi
}

# .face png in $home (user $HOME); some applications use this file.
_face_bin() {
    FILE_PATH \
<<_FACE
$home/.face
_FACE

    FILE \
<<'_FACE'
 211 120 116 107 015 012 032 012 000 000 000 015 111 110 104 122
 000 000 000 144 000 000 000 144 010 002 000 000 000 377 200 002
 003 000 000 000 003 163 102 111 124 010 010 010 333 341 117 340
 000 000 010 010 111 104 101 124 170 234 355 235 117 150 023 117
 024 307 137 252 325 370 277 326 077 304 077 075 010 125 243 124
 232 050 005 251 010 332 136 104 004 053 036 104 301 322 256 005
 017 005 351 101 017 036 212 207 212 050 071 064 170 116 215 030
 355 105 321 252 330 253 101 244 212 042 046 324 103 113 212 177
 132 264 242 025 135 250 156 252 326 375 035 346 327 141 234 375
 237 314 314 116 045 237 123 166 166 063 373 366 333 231 267 157
 346 315 244 001 135 327 241 204 073 312 374 066 140 066 121 022
 313 003 045 261 074 120 022 313 003 045 261 074 060 013 304 112
 247 323 175 175 175 176 133 001 060 053 304 112 245 122 207 016
 035 272 172 365 252 337 206 000 350 162 323 335 335 215 115 115
 046 223 376 032 043 173 313 032 031 031 301 237 133 133 133 375
 155 137 054 305 312 144 062 055 055 055 147 317 236 145 130 047
 205 317 172 261 155 250 065 065 065 000 120 133 133 313 252 302
 366 366 166 243 315 167 356 334 141 125 277 047 030 167 303 301
 301 301 171 363 346 145 263 331 160 070 314 266 146 222 267 157
 337 362 253 334 006 366 076 353 324 251 123 000 060 074 074 314
 111 057 105 121 072 072 072 170 324 354 010 173 261 142 261 130
 165 165 065 160 323 153 303 206 015 314 353 164 111 121 142 145
 062 031 323 160 061 227 313 141 275 366 356 335 133 314 055 244
 242 050 261 042 221 110 062 231 104 375 216 042 227 313 125 124
 124 000 100 072 235 276 161 343 106 061 167 261 047 036 217 007
 002 001 176 365 223 024 333 015 357 336 275 333 327 327 267 151
 323 046 143 304 360 365 353 327 271 163 347 002 000 127 027 063
 070 070 310 257 162 012 006 076 153 164 164 364 335 273 167 027
 057 136 154 153 153 243 116 041 231 046 046 046 166 355 332 125
 374 215 214 234 077 177 376 312 225 053 074 152 066 207 131 014
 122 126 006 146 021 026 352 214 000 160 374 370 361 002 252 065
 306 131 135 135 135 350 124 127 127 027 363 247 260 207 331 333
 160 172 172 072 020 010 144 263 331 225 053 127 222 345 270 063
 246 122 051 206 316 053 036 217 167 166 166 262 252 315 045 054
 103 207 077 177 376 000 300 227 057 137 202 301 040 131 216 175
 126 001 043 041 112 172 104 042 221 270 166 355 132 101 066 026
 005 343 070 113 327 165 000 230 232 232 042 365 212 305 142 353
 326 255 003 200 261 261 061 257 221 304 304 304 204 261 060 223
 311 274 174 371 262 070 113 013 201 175 120 212 365 132 270 160
 041 056 074 172 364 050 372 120 174 044 061 060 060 060 060 060
 120 114 015 205 303 311 027 242 312 053 052 052 160 011 152 134
 000 260 177 377 176 367 365 234 076 175 332 307 247 240 340 170
 033 024 053 256 130 261 002 035 222 217 175 375 372 165 367 365
 140 225 377 145 261 364 031 275 252 253 253 321 141 141 215 313
 164 226 306 027 261 370 316 224 176 370 360 001 000 106 106 106
 220 137 157 152 152 102 345 375 375 375 356 075 227 351 013 321
 027 370 212 025 012 205 132 133 133 001 040 235 116 267 265 265
 055 130 260 000 237 352 355 355 165 131 211 351 013 221 244 256
 256 256 140 013 275 041 240 365 342 111 225 023 047 116 220 016
 310 245 347 262 357 206 212 242 360 266 037 043 042 141 361 372
 365 353 245 113 227 002 100 117 117 317 326 255 133 161 271 313
 306 225 315 146 155 316 212 234 336 022 224 335 121 125 025 015
 036 037 075 172 204 013 135 172 256 071 163 346 330 234 135 274
 170 161 361 346 271 144 256 260 073 115 117 117 227 225 225 115
 115 115 221 205 157 336 274 161 374 242 225 317 332 261 143 307
 341 303 207 205 116 061 013 353 360 272 131 204 351 030 103 220
 111 126 222 140 060 070 076 076 056 306 154 214 350 214 364 242
 105 213 250 307 266 167 363 212 242 230 212 325 331 331 051 314
 146 214 150 261 352 353 353 251 307 306 363 123 106 056 135 272
 144 252 324 366 355 333 105 332 214 021 235 276 067 212 145 105
 076 237 267 352 203 113 226 054 141 147 221 007 104 213 025 213
 305 052 053 053 335 134 171 341 302 205 217 037 077 232 236 232
 077 177 076 123 243 334 342 303 302 020 074 135 143 317 373 367
 357 255 116 215 216 216 262 063 307 003 376 257 242 061 215 071
 343 361 270 115 046 142 150 150 150 150 150 210 247 121 346 370
 057 326 203 007 017 214 205 337 276 175 263 377 326 275 173 367
 370 230 143 207 377 142 151 232 266 173 367 156 257 337 372 371
 363 047 017 143 354 361 137 054 000 170 374 370 061 065 356 031
 033 033 363 313 030 033 244 020 013 376 036 124 333 073 054 304
 357 337 277 071 133 144 202 017 142 151 232 146 054 044 007 325
 246 316 073 032 215 222 207 317 237 077 347 141 233 003 202 203
 140 253 070 023 146 306 211 232 246 205 102 041 343 131 343 014
 237 247 211 174 046 210 233 165 100 220 013 152 051 120 343 032
 036 036 066 215 105 311 304 032 042 227 313 061 066 316 011 321
 142 331 323 333 333 153 332 254 140 046 035 111 202 126 005 210
 104 012 261 312 313 313 177 375 372 005 000 375 375 375 246 027
 050 212 162 346 314 231 055 133 266 210 265 213 106 264 203 067
 365 356 015 015 015 366 337 332 274 171 163 070 034 246 026 135
 212 177 041 012 025 313 064 046 120 024 005 255 251 264 042 030
 014 066 067 067 003 000 025 273 212 357 206 102 305 062 365 356
 216 031 207 366 366 166 344 310 326 256 135 113 226 377 343 055
 313 264 017 002 000 231 117 064 262 176 375 172 364 101 125 125
 262 034 255 160 022 212 260 040 305 052 302 102 063 245 126 013
 032 310 264 340 370 370 070 231 351 011 207 303 302 214 107 210
 153 131 126 021 026 312 145 341 314 076 005 331 111 103 241 320
 221 043 107 360 241 370 211 032 101 142 045 022 011 323 105 125
 216 333 045 250 264 340 306 215 033 311 103 301 023 065 202 304
 262 132 253 207 033 216 351 024 240 243 224 077 176 374 140 142
 236 113 104 210 145 325 254 200 150 070 224 363 106 124 125 125
 121 045 124 302 125 260 217 027 041 326 223 047 117 114 233 225
 143 303 061 106 122 324 362 243 313 227 057 347 363 371 342 055
 164 011 307 315 231 211 104 142 337 276 175 015 015 015 126 223
 123 216 021 226 061 222 242 032 240 252 252 075 075 075 205 332
 353 031 226 101 160 044 022 171 361 342 305 253 127 257 122 251
 124 115 115 315 247 117 237 154 326 024 107 243 321 110 044 142
 137 041 336 160 200 071 170 360 140 074 036 047 113 076 177 376
 134 260 301 236 141 036 214 240 325 105 216 120 211 350 155 333
 266 121 027 230 246 235 065 115 243 026 331 237 073 167 216 371
 043 130 301 336 147 251 252 352 250 027 325 254 022 211 204 261
 201 054 137 276 334 370 305 140 060 270 163 347 116 262 104 344
 010 221 213 203 167 324 253 271 271 371 300 201 003 350 163 046
 223 271 165 353 226 125 362 331 010 025 152 211 034 041 362 372
 263 250 252 272 152 325 052 352 115 037 215 106 053 053 053 033
 033 033 311 227 140 044 022 131 263 146 215 373 232 251 165 070
 102 243 007 256 235 274 251 251 251 256 256 256 161 206 373 367
 357 133 135 151 164 366 215 215 215 246 127 122 043 304 075 173
 366 160 063 237 106 226 137 014 061 256 262 265 022 113 327 365
 143 307 216 341 313 202 301 240 246 151 142 214 224 045 157 150
 144 365 352 325 126 247 110 267 225 317 347 237 076 175 052 304
 042 151 222 254 106 310 165 315 024 224 053 174 366 354 031 177
 163 000 344 021 313 323 066 212 362 362 162 362 160 162 162 222
 265 071 346 310 042 226 161 111 262 115 114 160 362 344 111 362
 120 330 010 121 026 261 214 330 104 233 124 246 107 330 010 121
 026 261 274 356 146 242 062 075 142 106 210 262 210 365 375 373
 167 117 327 123 356 137 314 240 107 026 261 360 076 152 214 375
 070 246 243 243 243 245 245 005 037 212 131 333 046 213 130 140
 310 131 070 066 226 144 062 211 365 272 171 363 046 047 253 110
 044 022 253 200 115 230 130 057 061 231 036 211 304 242 334 226
 313 351 004 254 227 210 114 217 230 121 225 113 226 055 133 206
 015 363 264 217 272 273 273 373 341 303 207 334 354 372 037 271
 304 242 266 215 211 137 333 147 217 104 335 020 014 357 104 067
 273 021 105 042 227 130 360 367 146 225 333 267 157 373 150 211
 011 176 067 155 023 012 330 164 056 006 351 132 026 374 335 270
 344 352 211 176 377 265 314 301 211 173 117 357 104 336 110 052
 226 116 154 020 226 247 047 312 330 015 021 223 223 223 150 304
 343 376 267 105 170 043 257 130 000 020 213 305 300 343 017 327
 360 305 357 246 355 000 032 312 124 125 125 371 155 210 256 313
 354 263 060 110 257 372 372 172 277 015 231 015 142 351 063 172
 025 366 343 235 014 231 035 142 351 063 172 371 373 146 224 142
 357 216 033 222 311 144 155 155 255 233 237 264 343 107 100 057
 375 143 065 327 110 035 072 310 106 111 054 017 224 304 362 100
 111 054 017 224 304 362 100 111 054 017 374 007 045 367 037 310
 075 064 164 315 000 000 000 000 111 105 116 104 256 102 140 202
_FACE

    __bin_write;
}

_featherpad_conf() {
    FILE_PATH \
<<FP_CONF
$home/.config/featherpad/fp.conf
FP_CONF

    FILE \
<<'FP_CONF'
[text]
appendEmptyLine=true
autoBracket=false
autoReplace=false
autoSave=false
autoSaveInterval=1
darkBgColorValue=30
darkColorScheme=true
dateFormat=
dictionaryPath=
executeCommand=
executeScripts=false
font="Source Code Pro,12,-1,5,50,0,0,0,0,0"
inertialScrolling=false
lightBgColorValue=255
lineNumbers=true
maxSHSize=2
noIndent=false
noSyntaxHighlighting=false
noWrap=false
pastePaths=false
recentFiles=
recentFilesNumber=10
recentOpened=false
removeTrailingSpaces=false
saveLastFilesList=false
saveUnmodified=false
scrollJumpWorkaround=false
selectionHighlighting=false
showEndings=false
showWhiteSpace=false
skipNonText=true
spellCheckFromStart=false
textMargin=false
textTabSize=8
thickCursor=false
vLineDistance=80

[window]
closeWithLastTab=false
disableMenubarAccel=false
fullscreen=false
hideSearchbar=false
hideSingleTab=false
max=true
menubarTitle=false
nativeDialog=true
noMenubar=false
noToolbar=true
openInWindows=false
position=none
prefSize=@Size(497 530)
sharedSearchHistory=false
showCursorPos=false
showLangSelector=false
showStatusbar=true
sidePaneMode=false
size=@Size(700 500)
splitterPos=20
startSize=@Size(700 500)
sysIcons=false
tabPosition=0
tabWrapAround=false
FP_CONF

    __file_write;
}

_firefox_conf() {
    FILE_PATH \
<<PROFILES_INI
$home/.mozilla/firefox/profiles.ini
PROFILES_INI

    __git_get 'https://github.com/mscalindt/firefox-profile-private'

    FILE_PATH \
<<IRA5808S_MSCALINDT
$tmpd/firefox-profile-private/ira5808s.mscalindt
IRA5808S_MSCALINDT

    FILE_PATH_TARGET \
<<IRA5808S_MSCALINDT
$home/.mozilla/firefox/ira5808s.mscalindt
IRA5808S_MSCALINDT

    __dir_target_write;

    FILE_PATH \
<<PROFILES_INI
$home/.mozilla/firefox/profiles.ini
PROFILES_INI

    __FILE_PATH_preload;

    FILE=$(
        line_add() {
            while IFS= read -r line; do
                i=$((i + 1))

                LOG_write 1 "$i" "$line"

                printf "%s\n" "$line"
            done <<EOF
$1
EOF
        }

        case "${FILE#"${FILE%??}"}" in
            "$LF$LF") : ;;
            *"$LF") FILE="$FILE$LF" ;;
            *) FILE="$FILE$LF$LF" ;;
        esac

        FLAG_PROFILE=0

        i=0; j=0; printf "%s" "$FILE" | { while IFS= read -r LINE; do
            i=$((i + 1))

            case "$LINE" in
                'Path=ira5808s.mscalindt')
                    FLAG_PROFILE=1
                ;;
                '[Profile'*']')
                    j=$((j + 1))
                ;;
            esac

            printf "%s\n" "$LINE"
        done

        while :; do
            if [ "$FLAG_PROFILE" = 0 ]; then
                FLAG_PROFILE=1

                line_add "[Profile${j}]"
                line_add 'Name=mscalindt'
                line_add 'IsRelative=1'
                line_add 'Path=ira5808s.mscalindt'
            else
                break
            fi
        done; }
    ); FILE="$FILE$LF"

    __file_write_overwrite;

    __git_get 'https://github.com/mscalindt/firefox-profiles'

    FILE_PATH \
<<499SH1EV_HARDENED
$tmpd/firefox-profiles/499sh1ev.HARDENED
499SH1EV_HARDENED

    FILE_PATH_TARGET \
<<499SH1EV_HARDENED
$home/.mozilla/firefox/499sh1ev.HARDENED
499SH1EV_HARDENED

    __dir_target_write;

    FILE_PATH \
<<PROFILES_INI
$home/.mozilla/firefox/profiles.ini
PROFILES_INI

    __FILE_PATH_preload;

    FILE=$(
        line_add() {
            while IFS= read -r line; do
                i=$((i + 1))

                LOG_write 1 "$i" "$line"

                printf "%s\n" "$line"
            done <<EOF
$1
EOF
        }

        case "${FILE#"${FILE%??}"}" in
            "$LF$LF") : ;;
            *"$LF") FILE="$FILE$LF" ;;
            *) FILE="$FILE$LF$LF" ;;
        esac

        FLAG_PROFILE=0

        i=0; j=0; printf "%s" "$FILE" | { while IFS= read -r LINE; do
            i=$((i + 1))

            case "$LINE" in
                'Path=499sh1ev.HARDENED')
                    FLAG_PROFILE=1
                ;;
                '[Profile'*']')
                    j=$((j + 1))
                ;;
            esac

            printf "%s\n" "$LINE"
        done

        while :; do
            if [ "$FLAG_PROFILE" = 0 ]; then
                FLAG_PROFILE=1

                line_add "[Profile${j}]"
                line_add 'Name=HARDENED'
                line_add 'IsRelative=1'
                line_add 'Path=499sh1ev.HARDENED'
            else
                break
            fi
        done; }
    ); FILE="$FILE$LF"

    __file_write_overwrite;
}

_fontconfig_conf() {
    FILE_PATH \
<<01_FONT_CONF
$home/.config/fontconfig/conf.d/01-font.conf
01_FONT_CONF

    FILE \
<<'01_FONT_CONF'
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE fontconfig SYSTEM "fonts.dtd">
<fontconfig>
  <alias>
    <family>serif</family>
    <prefer>
      <family>DejaVu Serif</family>
    </prefer>
  </alias>
  <alias>
    <family>DejaVu Serif</family>
    <default>
      <family>serif</family>
    </default>
  </alias>

  <alias>
    <family>sans-serif</family>
    <prefer>
      <family>Cantarell</family>
    </prefer>
  </alias>
  <alias>
    <family>Cantarell</family>
    <default>
      <family>sans-serif</family>
    </default>
  </alias>

  <alias>
    <family>monospace</family>
    <prefer>
      <family>Cantarell</family>
    </prefer>
  </alias>
  <alias>
    <family>Cantarell</family>
    <default>
      <family>monospace</family>
    </default>
  </alias>
</fontconfig>
01_FONT_CONF

    __file_write;
}

_fuse_conf() {
    FILE_PATH \
<<'FUSE_CONF'
/etc/fuse.conf
FUSE_CONF

    FILE \
<<'FUSE_CONF'
user_allow_other
FUSE_CONF

    __file_write_overwrite;
}

_gai_conf() {
    FILE_PATH \
<<'GAI_CONF'
/etc/gai.conf
GAI_CONF

    if [ "$ipv6" = 1 ]; then
        __loc_delete;
    else
        FILE \
<<'GAI_CONF'
precedence ::ffff:0:0/96  100
GAI_CONF

        __file_write_overwrite;
    fi
}

_git_conf() {
    FILE_PATH \
<<_GITCONFIG
$home/.gitconfig
_GITCONFIG

    FILE \
<<'_GITCONFIG'
[core]
	editor = nano
[credential]
	helper = cache --timeout=86400
[http]
	version = HTTP/2
[merge]
	log = 10000
[rerere]
	enabled = true
[sendemail]
        smtpuser = mscalindt@gmail.com
	smtpserver = smtp.gmail.com
	smtpencryption = tls
	smtpserverport = 587
[user]
	email = mscalindt@protonmail.com
	name = Dimitar Yurukov
	signingkey = 7D1F56FAD6FB86652A60BEE65BC3343816EAB179
[commit]
	gpgsign = 1
[color "diff"]
	old = red
	new = yellow
_GITCONFIG

    __file_write;
}

_gov_performance() {
    FILE_PATH \
<<'CPU'
/sys/devices/system/cpu
CPU

    if ! exist "$FILE_PATH"/cpu0/cpufreq/scaling_governor; then
        ENOENT;
        ftype "$FILE_PATH"/cpu0/cpufreq/scaling_governor -err || :
        err - - " $FILE_PATH"/cpu0/cpufreq/scaling_governor
        exit 2
    fi

    for core in "$FILE_PATH"/cpu*/cpufreq/scaling_governor; do
        FILE_PATH \
<<SCALING_GOVERNOR
$core
SCALING_GOVERNOR

        FILE \
<<'SCALING_GOVERNOR'
performance
SCALING_GOVERNOR

        __file_write_overwrite;
    done
}

_gov_schedutil() {
    FILE_PATH \
<<'CPU'
/sys/devices/system/cpu
CPU

    if ! exist "$FILE_PATH"/cpu0/cpufreq/scaling_governor; then
        ENOENT;
        ftype "$FILE_PATH"/cpu0/cpufreq/scaling_governor -err || :
        err - - " $FILE_PATH"/cpu0/cpufreq/scaling_governor
        exit 2
    fi

    for core in "$FILE_PATH"/cpu*/cpufreq/scaling_governor; do
        FILE_PATH \
<<SCALING_GOVERNOR
$core
SCALING_GOVERNOR

        FILE \
<<'SCALING_GOVERNOR'
schedutil
SCALING_GOVERNOR

        __file_write_overwrite;
    done
}

# "Removable" GRUB UEFI installation (NVRAM-less... when no NVRAM entries)
_grub() {
    is_uefi || EERROR 'Not in UEFI mode.'

    __cmd grub-install \
        --target=x86_64-efi \
        --efi-directory="$efi_mnt" \
        --boot-directory="$efi_mnt"/EFI/BOOT \
        --removable \
        --no-nvram

    __cmd grub-mkconfig -o "$efi_mnt"/EFI/BOOT/grub/grub.cfg
}

# To simulate a config file, we drop-in our replacement of /etc/default/grub,
# even though this shall usually only be done in a predefined environment
# (such as ours: 'syscfg grub grub-conf')
#
# As indicated by the above statement, GRUB is old and rather fixed on its
# configuration; that is, it does not provide the same flexibility as, for
# example, the configuration of rEFInd. rEFInd should be considered as a
# replacement.
_grub_conf() {
    is_uefi || EERROR 'Not in UEFI mode.'

    FILE_PATH \
<<'GRUB'
/etc/default/grub
GRUB

    FILE \
<<'GRUB'
GRUB_PRELOAD_MODULES="part_gpt"
GRUB_TIMEOUT_STYLE=menu
GRUB_TERMINAL_INPUT=console
GRUB_GFXMODE=auto
GRUB_GFXPAYLOAD_LINUX=keep
GRUB_DISABLE_RECOVERY=true
GRUB_DISABLE_OS_PROBER=false

GRUB_DEFAULT=0
GRUB_TIMEOUT=5
GRUB_CMDLINE_LINUX="\
loglevel=3 nowatchdog mitigations=off processor.ignore_ppc=1 \
usbhid.mousepoll=1 tsc=unstable \
GRUB

    if [ "$ipv6" != 1 ]; then
        FILE \
<<'GRUB'
ipv6.disable=1 \
GRUB
    fi

    FILE \
<<'GRUB'
"
GRUB

    if [ "$arch_linux" = 1 ]; then
        FILE \
<<'GRUB'
GRUB_DISTRIBUTOR="Arch"
GRUB
    fi

    __file_write_overwrite;

    __cmd grub-mkconfig -o "$efi_mnt"/EFI/BOOT/grub/grub.cfg
}

_gtk_conf() {
    FILE_PATH \
<<_GTKRC_2_0
$home/.gtkrc-2.0
_GTKRC_2_0

    FILE \
<<'_GTKRC_2_0'
gtk-cursor-theme-name="Breeze"
gtk-icon-theme-name="Papirus-Dark"
gtk-theme-name="Arc-Dark-solid"
gtk-font-name="Cantarell 12"
gtk-document-font-name="DejaVu Serif 12"
gtk-monospace-font-name="Cantarell 12"
gtk-cursor-theme-size=0
gtk-application-prefer-dark-theme=true
gtk-enable-primary-paste=false
gtk-toolbar-style=GTK_TOOLBAR_ICONS
gtk-toolbar-icon-size=GTK_ICON_SIZE_LARGE_TOOLBAR
gtk-button-images=1
gtk-menu-images=1
gtk-enable-event-sounds=0
gtk-enable-input-feedback-sounds=0
gtk-xft-antialias=1
gtk-xft-hinting=1
gtk-xft-hintstyle=hintfull
gtk-xft-rgba=rgb
_GTKRC_2_0

    __file_write;

    FILE_PATH \
<<GTK_CSS
$home/.config/gtk-3.0/gtk.css
GTK_CSS

    FILE \
<<'GTK_CSS'
.titlebar,
window {
	border-radius: 0;
	box-shadow: none;
}

decoration {
	box-shadow: none;
}

decoration:backdrop {
	box-shadow: none;
}
GTK_CSS

    __file_write;

    FILE_PATH \
<<SETTINGS_INI
$home/.config/gtk-3.0/settings.ini
SETTINGS_INI

    FILE \
<<'SETTINGS_INI'
[Settings]
gtk-cursor-theme-name="Breeze"
gtk-icon-theme-name="Papirus-Dark"
gtk-theme-name="Arc-Dark-solid"
gtk-font-name="Cantarell 12"
gtk-document-font-name="DejaVu Serif 12"
gtk-monospace-font-name="Cantarell 12"
gtk-cursor-theme-size=0
gtk-application-prefer-dark-theme=true
gtk-enable-primary-paste=false
gtk-toolbar-style=GTK_TOOLBAR_ICONS
gtk-toolbar-icon-size=GTK_ICON_SIZE_LARGE_TOOLBAR
gtk-button-images=1
gtk-menu-images=1
gtk-enable-event-sounds=0
gtk-enable-input-feedback-sounds=0
gtk-xft-antialias=1
gtk-xft-hinting=1
gtk-xft-hintstyle=hintfull
gtk-xft-rgba=rgb
SETTINGS_INI

    __file_write;
}

_hostname() {
    FILE_PATH \
<<'HOSTNAME'
/etc/hostname
HOSTNAME

    if [ "$m533ia" = 1 ]; then
        FILE \
<<'HOSTNAME'
m533ia
HOSTNAME
    else
        FILE \
<<HOSTNAME
$hostname
HOSTNAME
    fi

    __file_write;
}

_hosts() {
    FILE_PATH \
<<'HOSTS'
/etc/hosts
HOSTS

    if [ "$ipv6" = 1 ]; then
        FILE \
<<'HOSTS'
::1              localhost
127.0.0.1        localhost
HOSTS
    else
        FILE \
<<'HOSTS'
127.0.0.1        localhost
HOSTS
    fi

    if [ "$m533ia" = 1 ]; then
        FILE \
<<'HOSTS'
127.0.1.1        m533ia
HOSTS
    fi

    __file_write;
}

_imv_conf() {
    FILE_PATH \
<<CONFIG
$home/.config/imv/config
CONFIG

    FILE \
<<'CONFIG'
[options]
background = 696969
CONFIG

    __file_write;
}

_initramfs_conf() {
    if [ "$arch_linux" != 1 ]; then
        _info -white - 'Nothing to be done.'

        return 0
    fi

    FILE_PATH \
<<'MKINITCPIO_CONF'
/etc/mkinitcpio.conf
MKINITCPIO_CONF

    if [ "$m533ia" = 1 ]; then
        FILE \
<<'MKINITCPIO_CONF'
MODULES=(amdgpu pinctrl-amd)
MKINITCPIO_CONF
    else
        FILE \
<<'MKINITCPIO_CONF'
MODULES=()
MKINITCPIO_CONF
    fi

    FILE \
<<'MKINITCPIO_CONF'
BINARIES=()
FILES=()
HOOKS=(base udev autodetect microcode modconf keyboard block filesystems fsck)
MODULES_DECOMPRESS="yes"
MKINITCPIO_CONF

    __file_write_overwrite;

    __cmd mkinitcpio -P
}

_iwd_conf() {
    FILE_PATH \
<<'MAIN_CONF'
/etc/iwd/main.conf
MAIN_CONF

    FILE \
<<'MAIN_CONF'
[General]
EnableNetworkConfiguration=true
AddressRandomization=network
AddressRandomizationRange=nic

[Network]
MAIN_CONF

    if [ "$ipv6" = 1 ]; then
        FILE \
<<'MAIN_CONF'
EnableIPv6=true
MAIN_CONF
    else
        FILE \
<<'MAIN_CONF'
EnableIPv6=false
MAIN_CONF
    fi

    FILE \
<<'MAIN_CONF'
NameResolvingService=none

[Scan]
DisablePeriodicScan=true
MAIN_CONF

    __file_write;
}

_kitty_conf() {
    FILE_PATH \
<<KITTY_CONF
$home/.config/kitty/kitty.conf
KITTY_CONF

    FILE \
<<'KITTY_CONF'
font_family Source Code Pro
font_size 10.0
cursor_text_color background
cursor_shape beam
cursor_beam_thickness 1.0
cursor_stop_blinking_after 0.0
scrollback_lines 300000
wheel_scroll_multiplier 3.0
mouse_hide_wait 0.0
url_color #FFFFFF
url_style single
select_by_word_characters -A-Za-z0-9,./?%&#:_=+@~
enable_audio_bell no
remember_window_size no
initial_window_width 814
initial_window_height 498
hide_window_decorations yes
background_opacity 0.5
update_check_interval 0
shell_integration disabled
confirm_os_window_close 0
color0 #767676
color1 #f2201f
color2 #23fd00
color3 #fffd00
color4 #1a8fff
color5 #fd28ff
color6 #14ffff
color7 #ffffff
background #300924
map kitty_mod+a scroll_page_up
map kitty_mod+s scroll_page_down
map kitty_mod+z scroll_home
map kitty_mod+x scroll_end
KITTY_CONF

    __file_write;
}

_kvantum_conf() {
    FILE_PATH \
<<KVANTUM_KVCONFIG
$home/.config/Kvantum/kvantum.kvconfig
KVANTUM_KVCONFIG

    FILE \
<<'KVANTUM_KVCONFIG'
[General]
theme=KvArcDark#
KVANTUM_KVCONFIG

    __file_write;

    FILE_PATH \
<<KVARCDARK__KVCONFIG
$home/.config/Kvantum/KvArcDark#/KvArcDark#.kvconfig
KVARCDARK__KVCONFIG

    FILE \
<<'KVARCDARK__KVCONFIG'
[%General]
author=Tsu Jan
comment=A minimalistic dark theme inspired by the Arc GTK theme
x11drag=menubar_and_primary_toolbar
alt_mnemonic=true
left_tabs=true
attach_active_tab=true
mirror_doc_tabs=true
group_toolbar_buttons=false
toolbar_item_spacing=1
toolbar_interior_spacing=3
spread_progressbar=true
composite=false
menu_shadow_depth=5
menu_separator_height=6
tooltip_shadow_depth=6
splitter_width=4
scroll_width=9
scroll_arrows=false
scroll_min_extent=60
slider_width=6
slider_handle_width=18
slider_handle_length=18
center_toolbar_handle=true
check_size=14
textless_progressbar=false
progressbar_thickness=3font
menubar_mouse_tracking=true
toolbutton_style=0
click_behavior=0
translucent_windows=false
blurring=false
popup_blurring=false
vertical_spin_indicators=false
spin_button_width=32
fill_rubberband=false
merge_menubar_with_toolbar=true
small_icon_size=16
large_icon_size=32
button_icon_size=16
toolbar_icon_size=22
combo_as_lineedit=true
animate_states=false
combo_menu=true
hide_combo_checkboxes=true
combo_focus_rect=true
groupbox_top_label=true
inline_spin_indicators=false
joined_inactive_tabs=false
layout_spacing=6
layout_margin=9
scrollbar_in_view=true
transient_scrollbar=true
transient_groove=true
submenu_overlap=3
tooltip_delay=-1
tree_branch_line=true
dark_titlebar=true
contrast=1.00
dialog_button_layout=0
drag_from_buttons=false
intensity=1.00
menu_blur_radius=0
no_inactiveness=false
no_window_pattern=false
opaque=kaffeine,kmplayer,subtitlecomposer,kdenlive,vlc,smplayer,smplayer2,avidemux,avidemux2_qt4,avidemux3_qt4,avidemux3_qt5,kamoso,QtCreator,VirtualBox,VirtualBoxVM,trojita,dragon,digikam,lyx
reduce_menu_opacity=0
reduce_window_opacity=0
respect_DE=true
saturation=1.00
scrollable_menu=true
shadowless_popup=false
submenu_delay=250
tooltip_blur_radius=0

[GeneralColors]
window.color=#383c4a
base.color=#404552
alt.base.color=#3c434f
button.color=#414654
light.color=#5f677f
mid.light.color=#313131
dark.color=black
mid.color=#191919
highlight.color=#5294e2
inactive.highlight.color=#5294e2
text.color=#ffffffc8
window.text.color=#ffffffc8
button.text.color=#ffffffc8
disabled.text.color=#ffffff73
tooltip.text.color=#eefcff
highlight.text.color=white
link.color=#009DFF
link.visited.color=#9E4FFF
progress.indicator.text.color=white

[Hacks]
transparent_ktitle_label=false
transparent_dolphin_view=false
transparent_pcmanfm_sidepane=false
blur_translucent=false
transparent_menutitle=false
respect_darkness=true
force_size_grip=true
iconless_pushbutton=true
iconless_menu=false
disabled_icon_opacity=100
lxqtmainmenu_iconsize=22
normal_default_pushbutton=true
single_top_toolbar=true
tint_on_mouseover=0
transparent_pcmanfm_view=false
blur_only_active_window=false
centered_forms=false
kinetic_scrolling=false
middle_click_scroll=false
no_selection_tint=false
noninteger_translucency=false
style_vertical_toolbars=false

[PanelButtonCommand]
frame=true
frame.element=button
frame.top=3
frame.bottom=3
frame.left=3
frame.right=3
interior=true
interior.element=button
indicator.size=9
text.normal.color=#ffffffc8
text.focus.color=white
text.press.color=white
text.toggle.color=white
text.shadow=0
text.margin=1
text.iconspacing=4
indicator.element=arrow
text.margin.top=2
text.margin.bottom=2
text.margin.left=2
text.margin.right=2
min_width=+0.3font
min_height=+0.3font
frame.expansion=6

[PanelButtonTool]
inherits=PanelButtonCommand

[Dock]
inherits=PanelButtonCommand
interior.element=dock
frame.element=dock
frame.top=1
frame.bottom=1
frame.left=1
frame.right=1
text.normal.color=#ffffffc8

[DockTitle]
inherits=PanelButtonCommand
frame=false
interior=false
text.normal.color=#ffffff96
text.focus.color=white
text.bold=true

[IndicatorSpinBox]
inherits=PanelButtonCommand
frame=true
interior=true
frame.left=1
indicator.element=spin
indicator.size=10
text.normal.color=#ffffffc8

[RadioButton]
inherits=PanelButtonCommand
frame=false
interior.element=radio
text.normal.color=#ffffffc8
text.focus.color=white

[CheckBox]
inherits=PanelButtonCommand
frame=false
interior.element=checkbox
text.normal.color=#ffffffc8
text.focus.color=white

[Focus]
inherits=PanelButtonCommand
frame=true
frame.element=focus
frame.top=1
frame.bottom=1
frame.left=1
frame.right=1
frame.patternsize=20

[GenericFrame]
inherits=PanelButtonCommand
frame=true
interior=false
frame.element=common
interior.element=common
frame.top=3
frame.bottom=3
frame.left=3
frame.right=3

[LineEdit]
inherits=PanelButtonCommand
frame.element=lineedit
interior.element=lineedit
text.margin.left=1
text.margin.right=1

[DropDownButton]
inherits=PanelButtonCommand
indicator.element=arrow-down

[IndicatorArrow]
indicator.element=arrow
indicator.size=9

[ToolboxTab]
inherits=PanelButtonCommand
text.normal.color=#ffffffc8
text.press.color=#ffffff96
text.focus.color=white

[Tab]
inherits=PanelButtonCommand
interior.element=tab
text.margin.left=8
text.margin.right=8
text.margin.top=2
text.margin.bottom=2
frame.element=tab
indicator.element=tab
frame.top=4
frame.bottom=4
frame.left=4
frame.right=4
text.normal.color=#ffffff78
text.focus.color=#ffffffb4
text.toggle.color=#ffffffd2
frame.expansion=0

[TabFrame]
inherits=PanelButtonCommand
frame.element=tabframe
interior.element=tabframe
frame.top=4
frame.bottom=4
frame.left=4
frame.right=4

[TreeExpander]
inherits=PanelButtonCommand
indicator.size=12
indicator.element=tree

[HeaderSection]
inherits=PanelButtonCommand
interior.element=header
frame.element=header
frame.top=3
frame.bottom=3
frame.left=1
frame.right=1
text.bold=true
text.normal.color=#ffffff96
text.focus.color=#5796e8
text.toggle.color=white
frame.expansion=0

[SizeGrip]
indicator.element=resize-grip

[Toolbar]
inherits=PanelButtonCommand
indicator.element=toolbar
indicator.size=5
text.margin=0
frame=false
interior.element=menubar
frame.element=menubar
text.normal.color=#ffffffc8
text.focus.color=white
frame.bottom=0
frame.expansion=0

[Slider]
inherits=PanelButtonCommand
frame.element=slider
interior.element=slider
frame.top=3
frame.bottom=3
frame.left=3
frame.right=3

[SliderCursor]
inherits=PanelButtonCommand
frame=false
interior.element=slidercursor

[Progressbar]
inherits=PanelButtonCommand
frame.element=progress
interior.element=progress
text.margin=0
text.normal.color=#ffffffc8
text.focus.color=white
text.press.color=white
text.toggle.color=white
text.bold=false
frame.expansion=8

[ProgressbarContents]
inherits=PanelButtonCommand
frame=true
frame.element=progress-pattern
interior.element=progress-pattern

[ItemView]
inherits=PanelButtonCommand
text.margin=0
frame.element=itemview
interior.element=itemview
frame.top=2
frame.bottom=2
frame.left=2
frame.right=2
text.margin.top=2
text.margin.bottom=2
text.margin.left=4
text.margin.right=4
text.normal.color=#ffffffc8
text.focus.color=white
text.press.color=white
text.toggle.color=white
frame.expansion=0

[Splitter]
indicator.size=48

[Scrollbar]
inherits=PanelButtonCommand
indicator.element=arrow
indicator.size=10

[ScrollbarSlider]
inherits=PanelButtonCommand
frame.element=scrollbarslider
interior=false
frame.left=6
frame.right=6
frame.top=6
frame.bottom=6
indicator.element=grip
indicator.size=13
frame.expansion=48

[ScrollbarGroove]
inherits=PanelButtonCommand
interior=false
frame=false

[MenuItem]
inherits=PanelButtonCommand
frame=true
frame.element=menuitem
interior.element=menuitem
indicator.element=menuitem
text.normal.color=#ffffffc8
text.focus.color=white
text.margin.top=1
text.margin.bottom=1
text.margin.left=15
text.margin.right=5
frame.top=3
frame.bottom=3
frame.left=3
frame.right=3
frame.expansion=0

[MenuBar]
inherits=PanelButtonCommand
frame.element=menubar
interior.element=menubar
frame.bottom=0
frame.expansion=0

[MenuBarItem]
inherits=PanelButtonCommand
interior=true
interior.element=menubaritem
frame.element=menubaritem
frame.top=2
frame.bottom=2
frame.left=2
frame.right=2
text.margin.left=4
text.margin.right=4
text.margin.top=0
text.margin.bottom=0
text.normal.color=#000000b4
text.focus.color=white
frame.expansion=0

[TitleBar]
inherits=PanelButtonCommand
frame=false
interior.element=titlebar
indicator.size=12
indicator.element=mdi
text.normal.color=#787878
text.focus.color=white
text.bold=true
text.italic=true
frame.expansion=0

[ComboBox]
inherits=PanelButtonCommand
interior.element=combo
frame.element=combo
text.press.color=#ffffffc8
indicator.element=carrow

[Menu]
inherits=PanelButtonCommand
frame.top=1
frame.bottom=1
frame.left=1
frame.right=1
frame.element=menu
interior.element=menu
text.normal.color=#ffffffc8
text.shadow=false
frame.expansion=0

[GroupBox]
inherits=GenericFrame
frame=false
text.shadow=0
text.margin=0
text.normal.color=#ffffff96
text.focus.color=white
text.bold=true
frame.expansion=0

[TabBarFrame]
inherits=GenericFrame
frame=true
frame.element=tabBarFrame
interior=false
frame.top=4
frame.bottom=4
frame.left=4
frame.right=4

[ToolTip]
inherits=GenericFrame
frame.top=3
frame.bottom=3
frame.left=3
frame.right=3
interior=true
text.shadow=0
text.margin=0
interior.element=tooltip
frame.element=tooltip
frame.expansion=0

[StatusBar]
inherits=GenericFrame
frame=false
interior=false

[Window]
interior=true
interior.element=window
KVARCDARK__KVCONFIG

    __file_write;
}

# English locale config
_locale() {
    FILE_PATH \
<<'LOCALE_CONF'
/etc/locale.conf
LOCALE_CONF

    FILE \
<<'LOCALE_CONF'
LANG=en_US.UTF-8
LOCALE_CONF

    __file_write;

    FILE_PATH \
<<'LOCALE_GEN'
/etc/locale.gen
LOCALE_GEN

    FILE \
<<'LOCALE_GEN'
bg_BG.UTF-8 UTF-8
en_US.UTF-8 UTF-8
LOCALE_GEN

    __file_write;

    __cmd locale-gen
}

_makepkg_conf() {
    if [ "$arch_linux" != 1 ]; then
        _info -white - 'Nothing to be done.'

        return 0
    fi

    FILE_PATH \
<<'MAKEPKG_CONF'
/etc/makepkg.conf
MAKEPKG_CONF

    libfile ~~~1 \
            ' -O2 -pipe -fno-plt -fexceptions \' \
            'CFLAGS="-march=x86-64 -mtune=' \
            'CFLAGS="-march=x86-64 -mtune=native -O2 -pipe -fno-plt -fexceptions \' \
            ~~3 \
            'MAKEFLAGS="-j' \
            'MAKEFLAGS="-j6"'

    __file_write_overwrite;
}

_moc_conf() {
    FILE_PATH \
<<CONFIG
$home/.moc/config
CONFIG

    FILE \
<<'CONFIG'
SoundDriver = ALSA
Theme = transparent-background
CONFIG

    __file_write;
}

# Fix pop on idle resume
_modprobe_conf() {
    FILE_PATH \
<<'99_SND_POWERSAVE_CONF'
/etc/modprobe.d/99-snd_powersave.conf
99_SND_POWERSAVE_CONF

    FILE \
<<'99_SND_POWERSAVE_CONF'
options snd_hda_intel power_save=0 power_save_controller=N
99_SND_POWERSAVE_CONF

    __file_write;
}

_mpv_conf() {
    FILE_PATH \
<<MPV_CONF
$home/.config/mpv/mpv.conf
MPV_CONF

    FILE \
<<'MPV_CONF'
profile=gpu-hq
scale=ewa_lanczossharp
cscale=ewa_lanczossharp
override-display-fps=60
video-sync=display-resample
interpolation=yes
tscale=oversample
hwdec=auto
border=no
msg-color=yes
cursor-autohide=1000
screenshot-template="%F - [%P]v%#01n"
save-position-on-quit=yes
alang=en
slang=en
sub-auto=fuzzy
sub-bold=yes
MPV_CONF

    __file_write;
}

_mutt_conf() {
    FILE_PATH \
<<MUTTRC
$home/.mutt/muttrc
MUTTRC

    FILE \
<<'MUTTRC'
# Personal
set realname = "Dimitar Yurukov"
set from = "mscalindt@gmail.com"

# SMTP
set smtp_url = "smtps://mscalindt@smtp.gmail.com"
set ssl_force_tls = yes

# IMAP
set imap_user = "mscalindt@gmail.com"
set folder = "imaps://imap.gmail.com"
set spoolfile = "imaps://imap.gmail.com/INBOX"

# Settings
set signature="~/.mutt/muttsig"
set send_charset="us-ascii:utf-8"
set charset = UTF-8
set edit_headers = yes
set use_from = yes
set envelope_from = yes
unset use_domain

# Keybindings
bind index "^" imap-fetch-mail
MUTTRC

    __file_write;

    FILE_PATH \
<<MUTTSIG
$home/.mutt/muttsig
MUTTSIG

    FILE \
<<'MUTTSIG'
PGP: https://github.com/mscalindt.gpg
Email: mscalindt@gmail.com
MUTTSIG

    __file_write;
}

_nano_conf() {
    FILE_PATH \
<<_NANORC
$home/.nanorc
_NANORC

    FILE \
<<'_NANORC'
set fill 72
set breaklonglines
_NANORC

    __file_write;
}

# Delete all boot entries (UEFI)
_nvram_clr() {
    is_uefi || EERROR 'Not in UEFI mode.'

    set -- '/sys/firmware/efi/efivars'/Boot0*

    if ! exist "$1"; then
        _info -white - 'No valid entries have been found.'
        return 0
    fi

    set -- \
        '/sys/firmware/efi/efivars'/BootOrder* \
        '/sys/firmware/efi/efivars'/Boot0*

    if cmd 'chattr'; then
        __cmd chattr -ia "$@"
    fi

    __cmd rm -f "$@"

    set -- '/sys/firmware/efi/efivars'/Boot0*

    if exist "$1"; then
        EERROR 'Entry removal failed.'
    fi

    _info -white - 'The entries were removed; firmware will attempt recovery.'
}

_openal_conf() {
    FILE_PATH \
<<'ALSOFT_CONF'
/etc/openal/alsoft.conf
ALSOFT_CONF

    FILE \
<<'ALSOFT_CONF'
frequency = 48000
ALSOFT_CONF

    __file_write;
}

_pacman_conf() {
    if [ "$arch_linux" != 1 ]; then
        _info -white - 'Nothing to be done.'

        return 0
    fi

    FILE_PATH \
<<'PACMAN_CONF'
/etc/pacman.conf
PACMAN_CONF

    libfile ~~3 \
            'Color' \
            'Color' \
            ~~3 \
            'ParallelDownloads' \
            'ParallelDownloads = 5' \
            ~~3 \
            'VerbosePkgLists' \
            'VerbosePkgLists'

    FILE=$(
        line_add() {
            while IFS= read -r line; do
                i=$((i + 1))

                LOG_write 1 "$i" "$line"

                printf "%s\n" "$line"
            done <<EOF
$1
EOF
        }

        line_replace() {
            l=0; while IFS= read -r line; do
                l=$((l + 1))

                if [ "$l" -ne 1 ]; then
                    i=$((i + 1))
                fi

                if [ "$l" -eq 1 ]; then
                    if [ "$LINE" != "$line" ]; then
                        LOG_write 3 "$i" "$LINE" "$line"
                    fi
                else
                    LOG_write 1 "$i" "$line"
                fi

                printf "%s\n" "$line"
            done <<EOF
$1
EOF
        }

        case "${FILE#"${FILE%??}"}" in
            "$LF$LF") : ;;
            *"$LF") FILE="$FILE$LF" ;;
            *) FILE="$FILE$LF$LF" ;;
        esac

        _FLAG_MLIB=0; FLAG_MLIB=0

        i=0; printf "%s" "$FILE" | { while IFS= read -r LINE; do
            i=$((i + 1))

            if [ "$_FLAG_MLIB" = 1 ]; then
                _FLAG_MLIB=0

                case "$LINE" in
                    *'Include = '*)
                        line_replace "Include = $arch_mirlist"
                    ;;
                    *)
                        line_add "Include = $arch_mirlist"
                    ;;
                esac

                continue
            fi

            case "$LINE" in
                *'[multilib]'*)
                    FLAG_MLIB=1; _FLAG_MLIB=1

                    line_replace '[multilib]'

                    continue
                ;;
            esac

            printf "%s\n" "$LINE"
        done

        while :; do
            if [ "$FLAG_MLIB" = 0 ]; then
                FLAG_MLIB=1

                line_add '[multilib]'
                line_add "Include = $arch_mirlist"
            else
                break
            fi
        done; }
    ); FILE="$FILE$LF"

    __file_write_overwrite;
}

_pam_conf() {
    FILE_PATH \
<<'FAILLOCK_CONF'
/etc/security/faillock.conf
FAILLOCK_CONF

    FILE \
<<'FAILLOCK_CONF'
deny=7
even_deny_root
nodelay
root_unlock_time=8400
unlock_time=600
FAILLOCK_CONF

    __file_write_overwrite;

    FILE_PATH \
<<'LOGIN_DEFS'
/etc/login.defs
LOGIN_DEFS

    libfile ~1 \
            'FAIL_DELAY' \
            'FAIL_DELAY 0'

    __file_write_overwrite;

    FILE_PATH \
<<'SU'
/etc/pam.d/su
SU

    __FILE_PATH_preload;

    FILE=$(
        line_replace() {
            l=0; while IFS= read -r line; do
                l=$((l + 1))

                if [ "$l" -ne 1 ]; then
                    i=$((i + 1))
                fi

                if [ "$l" -eq 1 ]; then
                    if [ "$LINE" != "$line" ]; then
                        LOG_write 3 "$i" "$LINE" "$line"
                    fi
                else
                    LOG_write 1 "$i" "$line"
                fi

                printf "%s\n" "$line"
            done <<EOF
$1
EOF
        }

        case "${FILE#"${FILE%??}"}" in
            "$LF$LF") : ;;
            *"$LF") FILE="$FILE$LF" ;;
            *) FILE="$FILE$LF$LF" ;;
        esac

        i=0; printf "%s" "$FILE" | while IFS= read -r LINE; do
            i=$((i + 1))

            case "$LINE" in
                'auth'*'pam_unix.so'*)
                    case "$LINE" in
                        *'nodelay'*)
                            printf "%s\n" "$LINE"

                            continue
                        ;;
                    esac

                    line_replace "${LINE} nodelay"

                    continue
                ;;
            esac

            printf "%s\n" "$LINE"
        done
    ); FILE="$FILE$LF"

    __file_write_overwrite;

    FILE_PATH \
<<'SYSTEM_AUTH'
/etc/pam.d/system-auth
SYSTEM_AUTH

    __FILE_PATH_preload;

    FILE=$(
        line_replace() {
            l=0; while IFS= read -r line; do
                l=$((l + 1))

                if [ "$l" -ne 1 ]; then
                    i=$((i + 1))
                fi

                if [ "$l" -eq 1 ]; then
                    if [ "$LINE" != "$line" ]; then
                        LOG_write 3 "$i" "$LINE" "$line"
                    fi
                else
                    LOG_write 1 "$i" "$line"
                fi

                printf "%s\n" "$line"
            done <<EOF
$1
EOF
        }

        case "${FILE#"${FILE%??}"}" in
            "$LF$LF") : ;;
            *"$LF") FILE="$FILE$LF" ;;
            *) FILE="$FILE$LF$LF" ;;
        esac

        i=0; printf "%s" "$FILE" | while IFS= read -r LINE; do
            i=$((i + 1))

            case "$LINE" in
                'auth'*'pam_unix.so'*)
                    case "$LINE" in
                        *'nodelay'*)
                            printf "%s\n" "$LINE"

                            continue
                        ;;
                    esac

                    line_replace "${LINE} nodelay"

                    continue
                ;;
            esac

            printf "%s\n" "$LINE"
        done
    ); FILE="$FILE$LF"

    __file_write_overwrite;
}

_pipewire_conf() {
    FILE_PATH \
<<'CLIENT_CONF'
/etc/pipewire/client.conf.d/client.conf
CLIENT_CONF

    FILE \
<<'CLIENT_CONF'
context.properties = {
    module.rt = false  # disable rtkit module

    mem.allow-mlock = false  # swap is not used -> mlock is useless overhead

    default.clock.quantum-limit = 8192
}

filter.properties = {
    node.latency = 1024/44100  # 44.1k with ~23.2ms
}

stream.properties = {
    node.latency = 1024/44100  # 44.1k with ~23.2ms
CLIENT_CONF

    if [ "$audio_hq_resamp" = 1 ]; then
        FILE \
<<'CLIENT_CONF'
    resample.quality = 15
CLIENT_CONF
    else
        FILE \
<<'CLIENT_CONF'
    resample.quality = 9
CLIENT_CONF
    fi

    FILE \
<<'CLIENT_CONF'
}

alsa.properties = {
    alsa.rate = 44100  # 44.100 kHz
}
CLIENT_CONF

    __file_write;

    FILE_PATH \
<<'PIPEWIRE_CONF'
/etc/pipewire/pipewire.conf.d/pipewire.conf
PIPEWIRE_CONF

    FILE \
<<'PIPEWIRE_CONF'
context.properties = {
    module.rt = false  # disable rtkit module
    module.x11.bell = false  # disable x11 bell module
PIPEWIRE_CONF

    if [ "$portal" != 1 ]; then
        FILE \
<<'PIPEWIRE_CONF'

    module.portal = false  # disable portal module
PIPEWIRE_CONF
    fi

    FILE \
<<'PIPEWIRE_CONF'

    mem.allow-mlock = false  # swap is not used -> mlock is useless overhead

    loop.rt-prio = 0  # disable module-rt prio

    # 44.1k with ~23.2ms; related limits noted for explicit config
    default.clock.rate = 44100
    default.clock.allowed-rates = [ 44100 ]
    default.clock.quantum = 1024
    default.clock.min-quantum = 32
    default.clock.max-quantum = 2048
    default.clock.quantum-limit = 8192
    default.clock.quantum-floor = 4
}
PIPEWIRE_CONF

    __file_write;

    FILE_PATH \
<<'PIPEWIRE_PULSE_CONF'
/etc/pipewire/pipewire-pulse.conf.d/pipewire-pulse.conf
PIPEWIRE_PULSE_CONF

    FILE \
<<'PIPEWIRE_PULSE_CONF'
context.properties = {
    mem.allow-mlock = false  # swap is not used -> mlock is useless overhead

    default.clock.quantum-limit = 8192
}

pulse.properties = {
    pulse.allow-module-loading = false  # we use no modules
    # 44.1k with ~23.2ms
    pulse.min.req = 128/44100  # ~2.9ms
    pulse.default.req = 1024/44100  # ~23.2ms
    pulse.min.frag = 128/44100  # ~2.9ms
    pulse.default.frag = 88200/44100  # 2s
    pulse.default.tlength = 88200/44100  # 2s
    pulse.min.quantum = 128/44100  # ~2.9ms
    pulse.idle.timeout = 0  # I guess disables suspend functionality
}

stream.properties = {
    node.latency = 1024/44100  # 44.1k with ~23.2ms
PIPEWIRE_PULSE_CONF

    if [ "$audio_hq_resamp" = 1 ]; then
        FILE \
<<'PIPEWIRE_PULSE_CONF'
    resample.quality = 15
PIPEWIRE_PULSE_CONF
    else
        FILE \
<<'PIPEWIRE_PULSE_CONF'
    resample.quality = 9
PIPEWIRE_PULSE_CONF
    fi

    FILE \
<<'PIPEWIRE_PULSE_CONF'
}
PIPEWIRE_PULSE_CONF

    __file_write;
}

_pipewire_media_session_conf() {
    FILE_PATH \
<<'MEDIA_SESSION_CONF'
/etc/pipewire/media-session.d/media-session.conf
MEDIA_SESSION_CONF

    FILE \
<<'MEDIA_SESSION_CONF'
context.properties = {
    support.dbus = true
    default-profile.restore-bluetooth = true
}

context.spa-libs = {
    api.bluez5.*    = bluez5/libspa-bluez5
    api.alsa.*      = alsa/libspa-alsa
    api.v4l2.*      = v4l2/libspa-v4l2
    api.libcamera.* = libcamera/libspa-libcamera
}

context.modules = [
    { name = libpipewire-module-protocol-native }
    { name = libpipewire-module-client-node }
    { name = libpipewire-module-client-device }
    { name = libpipewire-module-adapter }
    { name = libpipewire-module-metadata }
    { name = libpipewire-module-session-manager }
]

session.modules = {
    default = [
        alsa-monitor
        alsa-seq
        default-nodes
        default-profile
        default-routes
        metadata
        policy-node
        restore-stream
        streams-follow-default
        v4l2
MEDIA_SESSION_CONF

    if [ "$bluetooth" = 1 ]; then
        FILE \
<<'MEDIA_SESSION_CONF'
        bluez5
        bluez5-autoswitch
MEDIA_SESSION_CONF
    fi

    if [ "$portal" = 1 ]; then
        FILE \
<<'MEDIA_SESSION_CONF'
        portal
MEDIA_SESSION_CONF
    fi

    FILE \
<<'MEDIA_SESSION_CONF'
    ]
}
MEDIA_SESSION_CONF

    __file_write;

    if [ "$bluetooth" = 1 ]; then
        FILE_PATH \
<<'BLUEZ_MONITOR_CONF'
/etc/pipewire/media-session.d/bluez-monitor.conf
BLUEZ_MONITOR_CONF

        FILE \
<<'BLUEZ_MONITOR_CONF'
properties = {
    bluez5.enable-sbc-xq = false
    bluez5.enable-msbc = false
    bluez5.enable-hw-volume = true
    bluez5.enable-faststream = false

    bluez5.codecs = [ aac ]

    bluez5.default.rate = 44100  # 44.100 kHz
}

rules = [
    {
        matches = [
            {
                device.name = "~bluez_card.*"
            }
        ]
        actions = {
            update-props = {
                bluez5.auto-connect = [ a2dp_sink ]
                bluez5.a2dp.aac.bitratemode = 0  # CBR 256 kbps
                bluez5.profile = a2dp-sink
                bluez5.autoswitch-profile = false
            }
        }
    }
    {
        matches = [
            {
                node.name = "~bluez_input.*"
            }
            {
                node.name = "~bluez_output.*"
            }
        ]
        actions = {
            update-props = {
                node.pause-on-idle = false
BLUEZ_MONITOR_CONF

        if [ "$audio_hq_resamp" = 1 ]; then
            FILE \
<<'BLUEZ_MONITOR_CONF'
                resample.quality = 15
BLUEZ_MONITOR_CONF
        else
            FILE \
<<'BLUEZ_MONITOR_CONF'
                resample.quality = 9
BLUEZ_MONITOR_CONF
        fi

        FILE \
<<'BLUEZ_MONITOR_CONF'
                session.suspend-timeout-seconds = 0
                bluez5.media-source-role = playback
            }
        }
    }
]
BLUEZ_MONITOR_CONF

        __file_write;
    fi
}

_ranger_conf() {
    FILE_PATH \
<<RC_CONF
$home/.config/ranger/rc.conf
RC_CONF

    FILE \
<<'RC_CONF'
map D console delete
copymap J <C-z>
copymap K <C-x>
copymap S <C-s>
set autosave_bookmarks false
set display_free_space_in_status_bar false
set display_size_in_status_bar false
set draw_borders both
set hostname_in_titlebar false
set idle_delay 100
set max_console_history_size 100
set mouse_enabled false
set preview_images_method kitty
set tilde_in_titlebar true
RC_CONF

    __file_write;

    FILE_PATH \
<<RIFLE_CONF
$home/.config/ranger/rifle.conf
RIFLE_CONF

    FILE \
<<'RIFLE_CONF'
# Video
mime ^video, has mpv,       X,  flag f = mpv -- "$@"
mime ^video, has parole,    X,  flag f = parole -- "$@"
mime ^video, has vlc,       X,  flag f = vlc -- "$@"
mime ^video, has mpv,       !X, terminal = mpv -- "$@"

# Audio
ext midi?, has wildmidi,    terminal = wildmidi -- "$@"
mime ^audio, has mocp,      terminal = mocp -l -- "$@"
mime ^audio, has mpv,       terminal = mpv -- "$@"
mime ^audio, has parole,    X, flag f = parole -- "$@"
mime ^audio, has vlc,       X, flag f = vlc -- "$@"

# Images
ext xcf, has gimp,                X, flag f = gimp -- "$@"
mime ^image/svg, has inkscape,    X, flag f = inkscape -- "$@"
mime ^image/svg, has display,     X, flag f = display -- "$@"
mime ^image, has swayimg,         X, flag f = swayimg -- "$@"
mime ^image, has imv,             X, flag f = imv -- "$@"
mime ^image, has ristretto,       X, flag f = ristretto "$@"
mime ^image, has gimp,            X, flag f = gimp -- "$@"

# PDF/Books
ext pdf, has firefox,          X, flag f = firefox -- "$@"
ext pdf, has zathura,          X, flag f = zathura -- "$@"
ext djvu, has zathura,         X, flag f = zathura -- "$@"
ext djvu, has djview,          X, flag f = djview -- "$@"
ext epub, has zathura,         X, flag f = zathura -- "$@"
ext epub, has ebook-viewer,    X, flag f = ebook-viewer -- "$@"
ext mobi, has ebook-viewer,    X, flag f = ebook-viewer -- "$@"
ext cbr|cbz, has zathura,      X, flag f = zathura -- "$@"

# Archives (atool)
ext 7z|ace|ar|arc|bz2?|cab|cpio|cpt|deb|dgc|dmg|gz|iso|jar|msi|pkg|rar|shar|tar|tgz|xar|xpi|xz|zip,    has atool = atool --list --each -- "$@" | "$PAGER"
ext 7z|ace|ar|arc|bz2?|cab|cpio|cpt|deb|dgc|dmg|gz|iso|jar|msi|pkg|rar|shar|tar|tgz|xar|xpi|xz|zip,    has atool = atool --extract --each -- "$@"

# Archives
ext 7z      has 7z = 7z -p l "$@" | "$PAGER"
ext 7z,     has 7z = for file in "$@"; do 7z -p -o"${file%???}" x -- "$file"; done
ext ace,    has unace = unace l "$1" | less
ext ace,    has unace = for file in "$@"; do unace e "$file"; done
ext bz2,    has tar = tar vvtf "$1" | "$PAGER"
ext bz2,    has tar = for file in "$@"; do tar vvxf "$file"; done
ext bz2,    has bzip2 = for file in "$@"; do bzip2 -dk "$file"; done
ext gz,     has tar = tar vvtf "$1" | "$PAGER"
ext gz,     has tar = for file in "$@"; do tar vvxf "$file"; done
ext rar,    has unrar = unrar l "$1" | less
ext rar,    has unrar = for file in "$@"; do unrar x "$file"; done
ext tar,    has tar = tar vvtf "$1" | "$PAGER"
ext tar,    has tar = for file in "$@"; do tar vvxf "$file"; done
ext xz,     has tar = tar vvtf "$1" | "$PAGER"
ext xz,     has tar = for file in "$@"; do tar vvxf "$file"; done
ext zip,    has unzip = unzip -l "$1" | less
ext zip,    has unzip = for file in "$@"; do unzip -d "${file%.*}" "$file"; done
ext zst,    has tar = tar vvtf "$1" | "$PAGER"
ext zst,    has tar = for file in "$@"; do tar vvxf "$file"; done

# HTML
ext x?html?, has firefox,     X, flag f = firefox -- "$@"
ext x?html?, has midori,      X, flag f = midori -- "$@"
ext x?html?, has chromium,    X, flag f = midori -- "$@"

# Docs/Text
ext sh,    has featherpad,     X, flag f = featherpad "$@"
ext shfn,  has featherpad,     X, flag f = featherpad "$@"
ext ini,   has featherpad,     X, flag f = featherpad "$@"
ext docx?, has catdoc,         terminal = catdoc -- "$@" | "$PAGER"
mime ^text, has featherpad,    X, flag f = featherpad "$@"
mime ^text, label editor                 = "${VISUAL:-$EDITOR}" -- "$@"
mime ^text, label pager                  = "$PAGER" -- "$@"

# Misc exts
ext 1|5 = man "$1"
ext exe = wine "$1"

# Misc mEmes
mime application/x-executable               = "$1"
mime ^font, has fontforge, X, flag f        = fontforge "$@"
mime ^ranger/x-terminal-emulator, has kitty = kitty -- "$@"

label open,   has xdg-open = xdg-open "$@"
label editor, !mime ^text, = "${VISUAL:-$EDITOR}" -- "$@"
label pager,  !mime ^text, = "$PAGER" -- "$@"
RIFLE_CONF

    __file_write;
}

_reflector() {
    if [ "$arch_linux" != 1 ]; then
        _info -white - 'Nothing to be done.'

        return 0
    fi

    if [ "$bg" = 1 ]; then
        _reflector_bg;
    elif [ "$de" = 1 ]; then
        _reflector_de;
    fi
}

_reflector_bg() {
    if [ "$arch_linux" != 1 ]; then
        _info -white - 'Nothing to be done.'

        return 0
    fi

    FILE_PATH \
<<MIRRORLIST
$arch_mirlist
MIRRORLIST

    __FILE_cmd reflector \
        --country Bulgaria \
        --connection-timeout 1 \
        --download-timeout 20 \
        --protocol https \
        --completion-percent 100 \
        --sort rate \
        --threads 8 \
        --latest 10 \
        --number 3

    FILE=$(
        printf "%s\n" "$FILE" | while IFS= read -r LINE; do
            if str_pfix 'Server =' "$LINE"; then
                printf "%s\n" "$LINE"
            fi
        done
    )

    if [ "$FILE" ]; then
        FILE="$FILE$LF"
    else
        _err -red - 'reflector: Failed.'
        _err -red - 'Try again on a static network condition.'; exit 1
    fi

    __file_write_overwrite;
}

_reflector_de() {
    if [ "$arch_linux" != 1 ]; then
        _info -white - 'Nothing to be done.'

        return 0
    fi

    FILE_PATH \
<<MIRRORLIST
$arch_mirlist
MIRRORLIST

    __FILE_cmd reflector \
        --country Germany \
        --connection-timeout 1 \
        --download-timeout 60 \
        --protocol https \
        --completion-percent 100 \
        --sort rate \
        --threads 8 \
        --latest 15 \
        --number 3

    FILE=$(
        printf "%s\n" "$FILE" | while IFS= read -r LINE; do
            if str_pfix 'Server =' "$LINE"; then
                printf "%s\n" "$LINE"
            fi
        done
    )

    if [ "$FILE" ]; then
        FILE="$FILE$LF"
    else
        _err -red - 'reflector: Failed.'
        _err -red - 'Try again on a static network condition.'; exit 1
    fi

    __file_write_overwrite;
}

_resolv_conf() {
    FILE_PATH \
<<'RESOLV_CONF'
/etc/resolv.conf
RESOLV_CONF

    if [ "$dns" = localhost ]; then
        if [ "$ipv6" = 1 ]; then
            FILE \
<<'RESOLV_CONF'
nameserver ::1
nameserver 127.0.0.1
RESOLV_CONF
        else
            FILE \
<<'RESOLV_CONF'
nameserver 127.0.0.1
RESOLV_CONF
        fi

        if [ "$dns0" = dnsmasq ]; then
            FILE \
<<'RESOLV_CONF'
options trust-ad
RESOLV_CONF
        fi

        __file_write;
        __loc_chattr 'i'
    elif [ "$dns" = none ] || [ ! "$dns" ]; then
        __loc_delete;
    fi
}

_sh() {
    FILE_PATH \
<<'DASH'
/usr/bin/dash
DASH

    FILE_PATH_TARGET \
<<'SH'
/usr/bin/sh
SH

    __loc_target_link_overwrite;

    if [ "$arch_linux" = 1 ]; then
        FILE_PATH \
<<'DASHBINSH_HOOK'
/usr/share/libalpm/hooks/dashbinsh.hook
DASHBINSH_HOOK

        FILE \
<<'DASHBINSH_HOOK'
[Trigger]
Type = Package
Operation = Install
Operation = Upgrade
Target = bash

[Action]
Description = Updating /bin/sh symlink to dash...
When = PostTransaction
Exec = /usr/bin/ln -sf /usr/bin/dash /usr/bin/sh
Depends = dash
DASHBINSH_HOOK

        __file_write;
    else
        FILE_PATH \
<<'DASHBINSH_HOOK'
/usr/share/libalpm/hooks/dashbinsh.hook
DASHBINSH_HOOK

        __loc_delete;
    fi
}

_sudo_conf() {
    FILE_PATH \
<<'WHEEL'
/etc/sudoers.d/wheel
WHEEL

    FILE \
<<'WHEEL'
%wheel ALL=(ALL:ALL) ALL
WHEEL

    __file_write;
    __loc_chmod '0440'
}

_sway_conf() {
    FILE_PATH \
<<CONFIG
$home/.config/sway/config
CONFIG

    FILE \
<<'CONFIG'
output * adaptive_sync off
output * allow_tearing yes
output * max_render_time off

# Mod4 = Super key
set $mod Mod4
set $term kitty
set $menu exec \
    $term --class=sway-app-launcher \
    /usr/bin/sway-launcher-desktop

focus_follows_mouse always

# Prevent annoying apps from disrupting active focus by pinning them to a
# certain workplace, in our case `7`, used as a last resort workspace or "bag".
# Steam's "launcher"
assign [title="Steam"] 7
# Steam
assign [class="steam"] 7

# Pin specific apps to specific workspaces.
# FeatherPad
assign [app_id="featherpad"] 2

for_window [app_id="sway-app-launcher"] \
    floating enable, sticky enable, resize set 30 ppt 60 ppt, border pixel 5
for_window [app_id="firefox"] \
    border none

input type:touchpad {
    dwt disabled
    tap enabled
}

input type:keyboard {
    xkb_layout us,bg(phonetic)
    xkb_model pc86
    xkb_options grp:alt_shift_toggle,caps:super
    repeat_delay 222
    repeat_rate 50
}

# Disable mouse acceleration
input type:pointer {
    accel_profile flat
}

# Appearance {
    output * bg #241f31 solid_color
    default_border pixel
    client.focused #0A75AD #0A75AD #0A75AD #0A75AD #0A75AD
    font pango:Cantarell 12
    seat seat0 xcursor_theme Breeze
    exec_always /home/$USER/.config/sway/import-gsettings
    exec_always /home/$USER/.config/sway/wp-handler
# }

# App keybindings {
    bindsym $mod+Return exec $term
    bindsym $mod+a exec $menu
    bindsym $mod+t exec /usr/bin/telegram-desktop
    bindsym $mod+b exec /usr/bin/blueman-manager
# }

# Control keybindings {
    bindsym $mod+1 workspace number 1
    bindsym $mod+2 workspace number 2
    bindsym $mod+3 workspace number 3
    bindsym $mod+4 workspace number 4
    bindsym $mod+5 workspace number 5
    bindsym $mod+6 workspace number 6
    bindsym $mod+7 workspace number 7

    bindsym $mod+Left focus left
    bindsym $mod+Down focus down
    bindsym $mod+Up focus up
    bindsym $mod+Right focus right
    bindsym Alt+Tab focus right
    bindsym Alt+Shift+Tab focus left

    # Basic functions
    bindsym $mod+z exec pamixer -d5
    bindsym $mod+x exec pamixer -i5
    bindsym $mod+c exec brightnessctl s 5%-
    bindsym $mod+v exec brightnessctl s 5%+
    bindsym print exec grim -l 9 $(date +'SS_%Y-%m-%d_%H%M%S.png')
    bindsym $mod+p exec grim -l 9 -g "$(slurp)" \
                            $(date +'SS_%Y-%m-%d_%H%M%S.png')
    bindsym $mod+Shift+p exec grim -l 9 -g "$(slurp; sleep 2.5)" \
                                  $(date +'SS_%Y-%m-%d_%H%M%S.png')

    # Extended functions
    # get hex color of a pixel
    bindsym $mod+h exec grim -g "$(slurp -p)" -t ppm - | \
                        convert - -format '%[pixel:p{0,0}]' txt:- | \
                        tail -n 1 | cut -d ' ' -f 4 | wl-copy -n
    # toggle audio playback
    bindsym $mod+Space exec /home/$USER/.config/sway/music_toggle

    # Kill window
    bindsym $mod+q kill

    # Force kill window
    bindsym $mod+Shift+q exec /home/$USER/.config/sway/fkill

    # Fullscreen window
    bindsym $mod+f fullscreen

    # Drag window by holding down $mod + LMB
    # Resize window by holding down $mod + RMB
    floating_modifier $mod normal

    # Invoke swaylock
    bindsym $mod+l exec swaylock

    # Reload the config
    bindsym $mod+Shift+c reload
# }

mode "nointercept" {
    bindsym $mod+Escape mode "default"
}
bindsym $mod+Shift+Escape mode "nointercept"

bar {
    status_command while /home/$USER/.config/sway/status; do sleep 0.1; done
    position top
    font pango:Source Code Pro 10

    colors {
        statusline #ffffff
        background #2b2e37
        inactive_workspace #32323200 #32323200 #5c5c5c
    }
}

CONFIG

    if [ "$arch_linux" = 1 ]; then
        FILE \
<<'CONFIG'
exec /home/$USER/.config/sway/systemd-handler
CONFIG
    fi

    FILE \
<<'CONFIG'
exec_always sh -c 'rm -f "${TMPDIR:-/tmp}"/nettotal'
CONFIG

    __file_write;

    if [ "$arch_linux" = 1 ]; then
        FILE_PATH \
<<SYSTEMD_HANDLER
$home/.config/sway/systemd-handler
SYSTEMD_HANDLER

        FILE \
<<'SYSTEMD_HANDLER'
#!/bin/sh

systemctl --user import-environment \
    DISPLAY WAYLAND_DISPLAY SWAYSOCK XDG_CURRENT_DESKTOP XDG_SESSION_DESKTOP \
    DESKTOP_SESSION
dbus-update-activation-environment --systemd \
    DISPLAY WAYLAND_DISPLAY SWAYSOCK XDG_CURRENT_DESKTOP XDG_SESSION_DESKTOP \
    DESKTOP_SESSION
SYSTEMD_HANDLER

        if [ "$portal" = 1 ]; then
            FILE \
<<'SYSTEMD_HANDLER'

systemctl --user start \
    xdg-desktop-portal xdg-desktop-portal-gtk xdg-desktop-portal-wlr \
    xdg-document-portal xdg-permission-store
SYSTEMD_HANDLER
        fi

        FILE \
<<'SYSTEMD_HANDLER'

if [ -f /usr/lib/polkit-gnome/polkit-gnome-authentication-agent-1 ]; then
    exec /usr/lib/polkit-gnome/polkit-gnome-authentication-agent-1
fi
SYSTEMD_HANDLER

        __file_write;
        __file_executable;
    else
        FILE_PATH \
<<SYSTEMD_HANDLER
$home/.config/sway/systemd-handler
SYSTEMD_HANDLER

        __loc_delete;
    fi

    FILE_PATH \
<<FKILL
$home/.config/sway/fkill
FKILL

    FILE \
<<'FKILL'
#!/bin/sh

PID=$(
    swaymsg -t get_tree | \
    jq '.. | select(.type?) | select(.focused==true).pid'
)

kill -9 "$PID"
FKILL

    __file_write;
    __file_executable;

    FILE_PATH \
<<IMPORT_GSETTINGS
$home/.config/sway/import-gsettings
IMPORT_GSETTINGS

    FILE \
<<'IMPORT_GSETTINGS'
#!/bin/sh

cfg="${XDG_CONFIG_HOME:-$HOME/.config}/gtk-3.0/settings.ini"

[ -f "$cfg" ] || return 1

gnome_schema='org.gnome.desktop.interface'

while read -r LINE; do
    case "$LINE" in
        'gtk-theme-name='*)
            gsettings set "$gnome_schema" gtk-theme "${LINE#*=}"
        ;;
        'gtk-icon-theme-name='*)
            gsettings set "$gnome_schema" icon-theme "${LINE#*=}"
        ;;
        'gtk-cursor-theme-name='*)
            gsettings set "$gnome_schema" cursor-theme "${LINE#*=}"
        ;;
        'gtk-font-name='*)
            gsettings set "$gnome_schema" font-name "${LINE#*=}"
        ;;
        'gtk-document-font-name='*)
            gsettings set "$gnome_schema" document-font-name "${LINE#*=}"
        ;;
        'gtk-monospace-font-name='*)
            gsettings set "$gnome_schema" monospace-font-name "${LINE#*=}"
        ;;
    esac
done < "$cfg"
IMPORT_GSETTINGS

    __file_write;
    __file_executable;

    FILE_PATH \
<<STATUS
$home/.config/sway/status
STATUS

    FILE \
<<'STATUS'
#!/bin/sh

NET_INTERFACE=wlan0

replchars() {
    replchar() {
        IFS="$1"; _chars="$2"

        set -f; set -- $3 "$3"; set +f

        _str=; while [ "$#" -ge 3 ]; do
            _str="$_str$1$_chars"; shift
        done

        case "$IFS" in
            *"${2#"${2%?}"}"*) _str="$_str$1$_chars" ;;
            *) _str="$_str$1" ;;
        esac
    }

    _old_IFS="$IFS" 2> /dev/null
    ${IFS+':'} unset _old_IFS 2> /dev/null

    replchar "$1" "$2" "$3"

    IFS="$_old_IFS" 2> /dev/null
    ${_old_IFS+':'} unset IFS 2> /dev/null
}

TITLE=$(
    swaymsg -t get_tree | \
    jq -r '.. | select(.type?) | select(.focused==true).name' 2> /dev/null
)
if [ "$TITLE" ]; then
    replchars '&' '&amp;' "$TITLE"; TITLE="$_str";
fi

MEMHOG=$(ps aux 2> /dev/null)
{
CUR=
CUR_F_PERC=
CUR_S_PERC=
while IFS= read -r LINE; do
    set -- $LINE

    case "$4" in
        '%MEM') continue ;;
    esac

    f_perc="${4%.*}"
    s_perc="${4#*.}"

    if [ "$CUR_F_PERC" ]; then
        if [ "$f_perc" -gt "$CUR_F_PERC" ]; then
            CUR="$LINE"
            CUR_F_PERC="$f_perc"
            CUR_S_PERC="$s_perc"
        elif [ "$f_perc" -eq "$CUR_F_PERC" ]; then
            if [ "$s_perc" -gt "$CUR_S_PERC" ]; then
                CUR="$LINE"
                CUR_S_PERC="$s_perc"
            fi
        fi
    else
        CUR="$LINE"
        CUR_F_PERC="$f_perc"
        CUR_S_PERC="$s_perc"
    fi
done \
<<EOF
$MEMHOG
EOF

read -r _ MEMTOTAL_BYTES _ < /proc/meminfo
MEMTOTAL_BYTES=$((MEMTOTAL_BYTES * 1024))

MEMHOG=$(
    set -- $CUR

    printf "%s" "$2 /"  # pid
    printf "%s" "${11##*/} /"  # cmd

    MEMHOG_BYTES=$((MEMTOTAL_BYTES * $CUR_F_PERC$CUR_S_PERC / 1000))  # base 2
    awk -v 'bytes_memhog'="$MEMHOG_BYTES" '
	function hsize(x, base) {
		basesuf = (base == "1024") ? "iB" : "B"

		s = "BKMGTEPYZ"
		while (x >= base && length(s) > 1)
			{x /= base; s = substr(s, 2)}
		s = substr(s, 1, 1)

		xf = (s == "B") ? "%d" : "%.2f"

		if (s != "B")
			s = s basesuf

		printf((xf " %s"), x, s)
	}

	BEGIN {
		printf hsize(bytes_memhog, 1000)
	}
    '  # mem_usage
)
} 2> /dev/null

while :; do
NET_USAGE=
if [ -h /sys/class/net/"$NET_INTERFACE" ]; then
    PREV_TX=0
    PREV_RX=0
    TOTAL=0
    if [ -f "${TMPDIR:-/tmp}"/netprevtx ]; then
        read -r PREV_TX < "${TMPDIR:-/tmp}"/netprevtx
    fi
    if [ -f "${TMPDIR:-/tmp}"/netprevrx ]; then
        read -r PREV_RX < "${TMPDIR:-/tmp}"/netprevrx
    fi
    if [ -f "${TMPDIR:-/tmp}"/nettotal ]; then
        read -r TOTAL < "${TMPDIR:-/tmp}"/nettotal
    fi
    read -r TX < /sys/class/net/"$NET_INTERFACE"/statistics/tx_bytes
    read -r RX < /sys/class/net/"$NET_INTERFACE"/statistics/rx_bytes
    [ "$TX" ] || break
    [ "$RX" ] || break

    if [ "$PREV_TX" = 0 ]; then
        printf "%s\n" "$TX" > "${TMPDIR:-/tmp}"/netprevtx; TX=0
    else
        CUR_TX=$((TX - PREV_TX))
    fi

    if [ "$PREV_RX" = 0 ]; then
        printf "%s\n" "$RX" > "${TMPDIR:-/tmp}"/netprevrx; RX=0
    else
        CUR_RX=$((RX - PREV_RX))
    fi

    if [ "$TX" = 0 ] || [ "$RX" = 0 ]; then
        break
    fi

    TOTAL=$((TOTAL + (CUR_TX + CUR_RX)))

    printf "%s\n" "$TX" > "${TMPDIR:-/tmp}"/netprevtx
    printf "%s\n" "$RX" > "${TMPDIR:-/tmp}"/netprevrx
    printf "%s\n" "$TOTAL" > "${TMPDIR:-/tmp}"/nettotal

    NET_USAGE=$(awk -v 'bytes_tx'="$CUR_TX" -v 'bytes_rx'="$CUR_RX" \
                    -v 'bytes_total'="$TOTAL" '
	function hsize(x, base) {
		basesuf = (base == "1024") ? "iB" : "B"

		s = "BKMGTEPYZ"
		while (x >= base && length(s) > 1)
			{x /= base; s = substr(s, 2)}
		s = substr(s, 1, 1)

		xf = (s == "B") ? "%d" : "%.2f"

		if (s != "B")
			s = s basesuf

		printf((xf " %s"), x, s)
	}

	BEGIN {
		printf "UDT"
		printf " /"
		printf hsize(bytes_tx, 1000)
		printf " /"
		printf hsize(bytes_rx, 1000)
		printf " /"
		printf hsize(bytes_total, 1000)
	}
    ' 2> /dev/null)
fi
break; done

PREV_IDLE=0
PREV_TOTAL=0
if [ -f "${TMPDIR:-/tmp}"/cpustatprevi ]; then
    read -r PREV_IDLE < "${TMPDIR:-/tmp}"/cpustatprevi
fi
if [ -f "${TMPDIR:-/tmp}"/cpustatprevt ]; then
    read -r PREV_TOTAL < "${TMPDIR:-/tmp}"/cpustatprevt
fi
read -r line < /proc/stat
PFIX="${line%%[0123456789]*}"
SFIX="${line#*[0123456789]}"
case "$SFIX" in
    [0123456789]*)
        SFIX="${SFIX#"${SFIX%%[!0123456789]*}"}"
    ;;
esac
IDLE="${line#"$PFIX"}"
IDLE="${IDLE%"$SFIX"}"
LINE="$PFIX$IDLE$SFIX"
x=0; while [ "$x" -ne 3 ]; do
    LINE="${LINE#"$PFIX$IDLE"}"
    PFIX="$PFIX$IDLE${LINE%%[0123456789]*}"
    SFIX="${LINE#*[0123456789]}"
    case "$SFIX" in
        [0123456789]*)
            SFIX="${SFIX#"${SFIX%%[!0123456789]*}"}"
        ;;
    esac
    IDLE="${LINE#"${LINE%%[0123456789]*}"}"
    IDLE="${IDLE%"$SFIX"}"
    LINE="$PFIX$IDLE$SFIX"
    x=$((x + 1))
done
PFIX="${line%%[0123456789]*}"
SFIX="${line#*[0123456789]}"
case "$SFIX" in
    [0123456789]*)
        SFIX="${SFIX#"${SFIX%%[!0123456789]*}"}"
    ;;
esac
_TOTAL="${line#"$PFIX"}"
_TOTAL="${_TOTAL%"$SFIX"}"
TOTAL="$_TOTAL"
LINE="$PFIX$_TOTAL$SFIX"
x=0; while [ "$x" -ne 6 ]; do
    LINE="${LINE#"$PFIX$_TOTAL"}"
    PFIX="$PFIX$_TOTAL${LINE%%[0123456789]*}"
    SFIX="${LINE#*[0123456789]}"
    case "$SFIX" in
        [0123456789]*)
            SFIX="${SFIX#"${SFIX%%[!0123456789]*}"}"
        ;;
    esac
    _TOTAL="${LINE#"${LINE%%[0123456789]*}"}"
    _TOTAL="${_TOTAL%"$SFIX"}"
    TOTAL=$((TOTAL + _TOTAL))
    LINE="$PFIX$_TOTAL$SFIX"
    x=$((x + 1))
done
printf "%s\n" "$IDLE" > "${TMPDIR:-/tmp}"/cpustatprevi
printf "%s\n" "$TOTAL" > "${TMPDIR:-/tmp}"/cpustatprevt
DIFF_IDLE=$((IDLE - PREV_IDLE))
DIFF_TOTAL=$((TOTAL - PREV_TOTAL))
CPU=$(((1000 * (DIFF_TOTAL - DIFF_IDLE) / DIFF_TOTAL + 5) / 10))

{ while read -r LINE; do
    case "$LINE" in
        'MemAvailable:'*)
            PFIX="${LINE%%[0123456789]*}"
            SFIX="${LINE#*[0123456789]}"
            case "$SFIX" in
                [0123456789]*)
                    SFIX="${SFIX#"${SFIX%%[!0123456789]*}"}"
                ;;
            esac

            MEMORY="${LINE#"$PFIX"}"
            MEMORY="${MEMORY%"$SFIX"}"
            MEMORY=$((MEMORY * 1024))

            MEMORY=$(awk -v 'bytes'="$MEMORY" '
function hsize(x, base) {
	basesuf = (base == "1024") ? "iB" : "B"

	s = "BKMGTEPYZ"
	while (x >= base && length(s) > 1)
		{x /= base; s = substr(s, 2)}
	s = substr(s, 1, 1)

	xf = (s == "B") ? "%d" : "%.2f"

	if (s != "B")
		s = s basesuf

	printf((xf " %s"), x, s)
}

BEGIN {
	printf hsize(bytes, 1000)
}
            ' 2> /dev/null)
        ;;
    esac
done < /proc/meminfo; } 2> /dev/null

{ read -r BATTERY < /sys/class/power_supply/BAT0/capacity; } 2> /dev/null

VOLUME=$(pamixer --get-volume 2> /dev/null)

AUDIO_SINK=$(pactl list sinks 2> /dev/null)
{
_STATE=; _NAME=
while IFS= read -r LINE; do
    case "$LINE" in
        *'State: RUNNING'*) _STATE=1 ;;
    esac

    case "$LINE" in
        *'Name: '*)
            if [ "$_STATE" = 1 ]; then
                _NAME="${LINE#*Name: }"; break
            fi
        ;;
    esac
done \
<<EOF
$AUDIO_SINK
EOF

AUDIO_SINK="$_NAME"
} 2> /dev/null
case "$AUDIO_SINK" in
    'alsa_output'*) AUDIO_SINK=ALSA ;;
    'bluez_output'*) AUDIO_SINK=BLUEZ ;;
esac

KB_LAYOUT=$(
    swaymsg -t get_inputs | \
    jq 'map(select(has("xkb_active_layout_name")))[0].xkb_active_layout_name'
)
case "$KB_LAYOUT" in
    *'English'*)
        KB_LAYOUT=EN
    ;;
    *'Bulgarian'*)
        KB_LAYOUT=BG
    ;;
esac

DATE=$(date "+%A%_d,%_I:%M %p" 2> /dev/null)
while :; do case "$DATE" in
    *[0123456789]','[0123456789]*)
        DATE="${DATE%\,*}, ${DATE#*\,}"
    ;;
    *'day'[0123456789]*)
        DATE="${DATE%day*}day ${DATE#*day}"
    ;;
    *)
        break
    ;;
esac done

STATUS="$TITLE | $MEMHOG"
if [ "$NET_USAGE" ]; then
    STATUS="$STATUS | $NET_USAGE"
fi
STATUS="$STATUS | ${CPU}% | $MEMORY"
case "$BATTERY" in
    100) : ;;
    *) STATUS="$STATUS | ~${BATTERY}%" ;;
esac
STATUS="$STATUS | ${VOLUME}%"
if [ "$AUDIO_SINK" ]; then
    STATUS="$STATUS | $AUDIO_SINK"
fi
STATUS="$STATUS | $KB_LAYOUT | $DATE |"

printf "%s" "$STATUS"
STATUS

    __file_write;
    __file_executable;

    FILE_PATH \
<<MUSIC_TOGGLE
$home/.config/sway/music_toggle
MUSIC_TOGGLE

    FILE \
<<'MUSIC_TOGGLE'
#!/bin/sh

MOCP_STATE=$(mocp -Q %state)
MOCP_PAUSE_FILE="${TMPDIR:-/tmp}"/music_toggle_mocp

if [ -f "$MOCP_PAUSE_FILE" ]; then
    if playerctl status 2> /dev/null | grep -q 'Playing'; then
        playerctl play-pause
    elif [ "$MOCP_STATE" = 'PAUSE' ]; then
        mocp -U
    fi

    rm -f "$MOCP_PAUSE_FILE"
    exit 0
elif [ "$MOCP_STATE" = 'PLAY' ]; then
    mocp -P
    : > "$MOCP_PAUSE_FILE"
    exit 0
fi

playerctl play-pause > /dev/null 2>&1
MUSIC_TOGGLE

    __file_write;
    __file_executable;

    FILE_PATH \
<<WP_HANDLER
$home/.config/sway/wp-handler
WP_HANDLER

    FILE \
<<'WP_HANDLER'
#!/bin/sh

WP_HANDLER

    FILE \
<<WP_HANDLER
WP=$home/.config/sway/wp
WP_HANDLER

    FILE \
<<'WP_HANDLER'
WP_NEW="${TMPDIR:-/tmp}"/wp

if [ -f "$WP_NEW" ]; then
    swaymsg output '*' bg "$WP_NEW" fill
elif [ -f "$WP" ]; then
    swaymsg output '*' bg "$WP" fill
fi
WP_HANDLER

    __file_write;
    __file_executable;
}

_sway_conf_gaming() {
    FILE_PATH \
<<CONFIG
$home/.config/sway/config
CONFIG

    FILE \
<<'CONFIG'
output * adaptive_sync off
output * allow_tearing yes
output * max_render_time off

# Mod4 = Super key
set $mod Mod4
set $term kitty
set $menu exec \
    $term --class=sway-app-launcher \
    /usr/bin/sway-launcher-desktop

focus_follows_mouse always

# Prevent annoying apps from disrupting active focus by pinning them to a
# certain workplace, in our case `7`, used as a last resort workspace or "bag".
# Steam's "launcher"
assign [title="Steam"] 7
# Steam
assign [class="steam"] 7

# Pin specific apps to specific workspaces.
# FeatherPad
assign [app_id="featherpad"] 2

for_window [app_id="sway-app-launcher"] \
    floating enable, sticky enable, resize set 30 ppt 60 ppt, border pixel 5
for_window [app_id="firefox"] \
    border none

input type:touchpad {
    dwt disabled
    tap enabled
}

input type:keyboard {
    xkb_layout us,bg(phonetic)
    xkb_model pc86
    xkb_options grp:alt_shift_toggle
    repeat_delay 222
    repeat_rate 50
}

# Disable mouse acceleration
input type:pointer {
    accel_profile flat
}

# Appearance {
    output * bg #241f31 solid_color
    default_border pixel
    client.focused #0A75AD #0A75AD #0A75AD #0A75AD #0A75AD
    font pango:Cantarell 12
    seat seat0 xcursor_theme Breeze
    exec_always /home/$USER/.config/sway/import-gsettings
    exec_always /home/$USER/.config/sway/wp-handler
# }

# App keybindings {
    bindsym $mod+Return exec $term
    bindsym $mod+a exec $menu
    bindsym $mod+t exec /usr/bin/telegram-desktop
    bindsym $mod+b exec /usr/bin/blueman-manager
# }

# Control keybindings {
    bindsym $mod+1 workspace number 1
    bindsym $mod+2 workspace number 2
    bindsym $mod+3 workspace number 3
    bindsym $mod+4 workspace number 4
    bindsym $mod+5 workspace number 5
    bindsym $mod+6 workspace number 6
    bindsym $mod+7 workspace number 7

    bindsym $mod+Left focus left
    bindsym $mod+Down focus down
    bindsym $mod+Up focus up
    bindsym $mod+Right focus right
    bindsym Alt+Tab focus right
    bindsym Alt+Shift+Tab focus left

    # Basic functions
    bindsym $mod+z exec pamixer -d5
    bindsym $mod+x exec pamixer -i5
    bindsym $mod+c exec brightnessctl s 5%-
    bindsym $mod+v exec brightnessctl s 5%+
    bindsym print exec grim -l 9 $(date +'SS_%Y-%m-%d_%H%M%S.png')
    bindsym $mod+p exec grim -l 9 -g "$(slurp)" \
                            $(date +'SS_%Y-%m-%d_%H%M%S.png')
    bindsym $mod+Shift+p exec grim -l 9 -g "$(slurp; sleep 2.5)" \
                                  $(date +'SS_%Y-%m-%d_%H%M%S.png')

    # Extended functions
    # get hex color of a pixel
    bindsym $mod+h exec grim -g "$(slurp -p)" -t ppm - | \
                        convert - -format '%[pixel:p{0,0}]' txt:- | \
                        tail -n 1 | cut -d ' ' -f 4 | wl-copy -n
    # toggle audio playback
    bindsym $mod+Space exec /home/$USER/.config/sway/music_toggle

    # Kill window
    bindsym $mod+q kill

    # Force kill window
    bindsym $mod+Shift+q exec /home/$USER/.config/sway/fkill

    # Fullscreen window
    bindsym $mod+f fullscreen

    # Drag window by holding down $mod + LMB
    # Resize window by holding down $mod + RMB
    floating_modifier $mod normal

    # Invoke swaylock
    bindsym $mod+l exec swaylock

    # Reload the config
    bindsym $mod+Shift+c reload
# }

mode "nointercept" {
    bindsym $mod+Escape mode "default"
}
bindsym $mod+Shift+Escape mode "nointercept"

bar {
    position top
    font pango:Source Code Pro 10

    colors {
        statusline #ffffff
        background #2b2e37
        inactive_workspace #32323200 #32323200 #5c5c5c
    }
}

CONFIG

    if [ "$arch_linux" = 1 ]; then
        FILE \
<<'CONFIG'
exec /home/$USER/.config/sway/systemd-handler
CONFIG
    fi

    FILE \
<<'CONFIG'
exec_always sh -c 'rm -f "${TMPDIR:-/tmp}"/nettotal'
CONFIG

    __file_write;

    if [ "$arch_linux" = 1 ]; then
        FILE_PATH \
<<SYSTEMD_HANDLER
$home/.config/sway/systemd-handler
SYSTEMD_HANDLER

        FILE \
<<'SYSTEMD_HANDLER'
#!/bin/sh

systemctl --user import-environment \
    DISPLAY WAYLAND_DISPLAY SWAYSOCK XDG_CURRENT_DESKTOP XDG_SESSION_DESKTOP \
    DESKTOP_SESSION
dbus-update-activation-environment --systemd \
    DISPLAY WAYLAND_DISPLAY SWAYSOCK XDG_CURRENT_DESKTOP XDG_SESSION_DESKTOP \
    DESKTOP_SESSION
SYSTEMD_HANDLER

        if [ "$portal" = 1 ]; then
            FILE \
<<'SYSTEMD_HANDLER'

systemctl --user start \
    xdg-desktop-portal xdg-desktop-portal-gtk xdg-desktop-portal-wlr \
    xdg-document-portal xdg-permission-store
SYSTEMD_HANDLER
        fi

        FILE \
<<'SYSTEMD_HANDLER'

if [ -f /usr/lib/polkit-gnome/polkit-gnome-authentication-agent-1 ]; then
    exec /usr/lib/polkit-gnome/polkit-gnome-authentication-agent-1
fi
SYSTEMD_HANDLER

        __file_write;
        __file_executable;
    else
        FILE_PATH \
<<SYSTEMD_HANDLER
$home/.config/sway/systemd-handler
SYSTEMD_HANDLER

        __loc_delete;
    fi

    FILE_PATH \
<<FKILL
$home/.config/sway/fkill
FKILL

    FILE \
<<'FKILL'
#!/bin/sh

PID=$(
    swaymsg -t get_tree | \
    jq '.. | select(.type?) | select(.focused==true).pid'
)

kill -9 "$PID"
FKILL

    __file_write;
    __file_executable;

    FILE_PATH \
<<IMPORT_GSETTINGS
$home/.config/sway/import-gsettings
IMPORT_GSETTINGS

    FILE \
<<'IMPORT_GSETTINGS'
#!/bin/sh

cfg="${XDG_CONFIG_HOME:-$HOME/.config}/gtk-3.0/settings.ini"

[ -f "$cfg" ] || return 1

gnome_schema='org.gnome.desktop.interface'

while read -r LINE; do
    case "$LINE" in
        'gtk-theme-name='*)
            gsettings set "$gnome_schema" gtk-theme "${LINE#*=}"
        ;;
        'gtk-icon-theme-name='*)
            gsettings set "$gnome_schema" icon-theme "${LINE#*=}"
        ;;
        'gtk-cursor-theme-name='*)
            gsettings set "$gnome_schema" cursor-theme "${LINE#*=}"
        ;;
        'gtk-font-name='*)
            gsettings set "$gnome_schema" font-name "${LINE#*=}"
        ;;
        'gtk-document-font-name='*)
            gsettings set "$gnome_schema" document-font-name "${LINE#*=}"
        ;;
        'gtk-monospace-font-name='*)
            gsettings set "$gnome_schema" monospace-font-name "${LINE#*=}"
        ;;
    esac
done < "$cfg"
IMPORT_GSETTINGS

    __file_write;
    __file_executable;

    FILE_PATH \
<<STATUS
$home/.config/sway/status
STATUS

    FILE \
<<'STATUS'
#!/bin/sh

NET_INTERFACE=wlan0

replchars() {
    replchar() {
        IFS="$1"; _chars="$2"

        set -f; set -- $3 "$3"; set +f

        _str=; while [ "$#" -ge 3 ]; do
            _str="$_str$1$_chars"; shift
        done

        case "$IFS" in
            *"${2#"${2%?}"}"*) _str="$_str$1$_chars" ;;
            *) _str="$_str$1" ;;
        esac
    }

    _old_IFS="$IFS" 2> /dev/null
    ${IFS+':'} unset _old_IFS 2> /dev/null

    replchar "$1" "$2" "$3"

    IFS="$_old_IFS" 2> /dev/null
    ${_old_IFS+':'} unset IFS 2> /dev/null
}

TITLE=$(
    swaymsg -t get_tree | \
    jq -r '.. | select(.type?) | select(.focused==true).name' 2> /dev/null
)
if [ "$TITLE" ]; then
    replchars '&' '&amp;' "$TITLE"; TITLE="$_str";
fi

MEMHOG=$(ps aux 2> /dev/null)
{
CUR=
CUR_F_PERC=
CUR_S_PERC=
while IFS= read -r LINE; do
    set -- $LINE

    case "$4" in
        '%MEM') continue ;;
    esac

    f_perc="${4%.*}"
    s_perc="${4#*.}"

    if [ "$CUR_F_PERC" ]; then
        if [ "$f_perc" -gt "$CUR_F_PERC" ]; then
            CUR="$LINE"
            CUR_F_PERC="$f_perc"
            CUR_S_PERC="$s_perc"
        elif [ "$f_perc" -eq "$CUR_F_PERC" ]; then
            if [ "$s_perc" -gt "$CUR_S_PERC" ]; then
                CUR="$LINE"
                CUR_S_PERC="$s_perc"
            fi
        fi
    else
        CUR="$LINE"
        CUR_F_PERC="$f_perc"
        CUR_S_PERC="$s_perc"
    fi
done \
<<EOF
$MEMHOG
EOF

read -r _ MEMTOTAL_BYTES _ < /proc/meminfo
MEMTOTAL_BYTES=$((MEMTOTAL_BYTES * 1024))

MEMHOG=$(
    set -- $CUR

    printf "%s" "$2 /"  # pid
    printf "%s" "${11##*/} /"  # cmd

    MEMHOG_BYTES=$((MEMTOTAL_BYTES * $CUR_F_PERC$CUR_S_PERC / 1000))  # base 2
    awk -v 'bytes_memhog'="$MEMHOG_BYTES" '
	function hsize(x, base) {
		basesuf = (base == "1024") ? "iB" : "B"

		s = "BKMGTEPYZ"
		while (x >= base && length(s) > 1)
			{x /= base; s = substr(s, 2)}
		s = substr(s, 1, 1)

		xf = (s == "B") ? "%d" : "%.2f"

		if (s != "B")
			s = s basesuf

		printf((xf " %s"), x, s)
	}

	BEGIN {
		printf hsize(bytes_memhog, 1000)
	}
    '  # mem_usage
)
} 2> /dev/null

while :; do
NET_USAGE=
if [ -h /sys/class/net/"$NET_INTERFACE" ]; then
    PREV_TX=0
    PREV_RX=0
    TOTAL=0
    if [ -f "${TMPDIR:-/tmp}"/netprevtx ]; then
        read -r PREV_TX < "${TMPDIR:-/tmp}"/netprevtx
    fi
    if [ -f "${TMPDIR:-/tmp}"/netprevrx ]; then
        read -r PREV_RX < "${TMPDIR:-/tmp}"/netprevrx
    fi
    if [ -f "${TMPDIR:-/tmp}"/nettotal ]; then
        read -r TOTAL < "${TMPDIR:-/tmp}"/nettotal
    fi
    read -r TX < /sys/class/net/"$NET_INTERFACE"/statistics/tx_bytes
    read -r RX < /sys/class/net/"$NET_INTERFACE"/statistics/rx_bytes
    [ "$TX" ] || break
    [ "$RX" ] || break

    if [ "$PREV_TX" = 0 ]; then
        printf "%s\n" "$TX" > "${TMPDIR:-/tmp}"/netprevtx; TX=0
    else
        CUR_TX=$((TX - PREV_TX))
    fi

    if [ "$PREV_RX" = 0 ]; then
        printf "%s\n" "$RX" > "${TMPDIR:-/tmp}"/netprevrx; RX=0
    else
        CUR_RX=$((RX - PREV_RX))
    fi

    if [ "$TX" = 0 ] || [ "$RX" = 0 ]; then
        break
    fi

    TOTAL=$((TOTAL + (CUR_TX + CUR_RX)))

    printf "%s\n" "$TX" > "${TMPDIR:-/tmp}"/netprevtx
    printf "%s\n" "$RX" > "${TMPDIR:-/tmp}"/netprevrx
    printf "%s\n" "$TOTAL" > "${TMPDIR:-/tmp}"/nettotal

    NET_USAGE=$(awk -v 'bytes_tx'="$CUR_TX" -v 'bytes_rx'="$CUR_RX" \
                    -v 'bytes_total'="$TOTAL" '
	function hsize(x, base) {
		basesuf = (base == "1024") ? "iB" : "B"

		s = "BKMGTEPYZ"
		while (x >= base && length(s) > 1)
			{x /= base; s = substr(s, 2)}
		s = substr(s, 1, 1)

		xf = (s == "B") ? "%d" : "%.2f"

		if (s != "B")
			s = s basesuf

		printf((xf " %s"), x, s)
	}

	BEGIN {
		printf "UDT"
		printf " /"
		printf hsize(bytes_tx, 1000)
		printf " /"
		printf hsize(bytes_rx, 1000)
		printf " /"
		printf hsize(bytes_total, 1000)
	}
    ' 2> /dev/null)
fi
break; done

PREV_IDLE=0
PREV_TOTAL=0
if [ -f "${TMPDIR:-/tmp}"/cpustatprevi ]; then
    read -r PREV_IDLE < "${TMPDIR:-/tmp}"/cpustatprevi
fi
if [ -f "${TMPDIR:-/tmp}"/cpustatprevt ]; then
    read -r PREV_TOTAL < "${TMPDIR:-/tmp}"/cpustatprevt
fi
read -r line < /proc/stat
PFIX="${line%%[0123456789]*}"
SFIX="${line#*[0123456789]}"
case "$SFIX" in
    [0123456789]*)
        SFIX="${SFIX#"${SFIX%%[!0123456789]*}"}"
    ;;
esac
IDLE="${line#"$PFIX"}"
IDLE="${IDLE%"$SFIX"}"
LINE="$PFIX$IDLE$SFIX"
x=0; while [ "$x" -ne 3 ]; do
    LINE="${LINE#"$PFIX$IDLE"}"
    PFIX="$PFIX$IDLE${LINE%%[0123456789]*}"
    SFIX="${LINE#*[0123456789]}"
    case "$SFIX" in
        [0123456789]*)
            SFIX="${SFIX#"${SFIX%%[!0123456789]*}"}"
        ;;
    esac
    IDLE="${LINE#"${LINE%%[0123456789]*}"}"
    IDLE="${IDLE%"$SFIX"}"
    LINE="$PFIX$IDLE$SFIX"
    x=$((x + 1))
done
PFIX="${line%%[0123456789]*}"
SFIX="${line#*[0123456789]}"
case "$SFIX" in
    [0123456789]*)
        SFIX="${SFIX#"${SFIX%%[!0123456789]*}"}"
    ;;
esac
_TOTAL="${line#"$PFIX"}"
_TOTAL="${_TOTAL%"$SFIX"}"
TOTAL="$_TOTAL"
LINE="$PFIX$_TOTAL$SFIX"
x=0; while [ "$x" -ne 6 ]; do
    LINE="${LINE#"$PFIX$_TOTAL"}"
    PFIX="$PFIX$_TOTAL${LINE%%[0123456789]*}"
    SFIX="${LINE#*[0123456789]}"
    case "$SFIX" in
        [0123456789]*)
            SFIX="${SFIX#"${SFIX%%[!0123456789]*}"}"
        ;;
    esac
    _TOTAL="${LINE#"${LINE%%[0123456789]*}"}"
    _TOTAL="${_TOTAL%"$SFIX"}"
    TOTAL=$((TOTAL + _TOTAL))
    LINE="$PFIX$_TOTAL$SFIX"
    x=$((x + 1))
done
printf "%s\n" "$IDLE" > "${TMPDIR:-/tmp}"/cpustatprevi
printf "%s\n" "$TOTAL" > "${TMPDIR:-/tmp}"/cpustatprevt
DIFF_IDLE=$((IDLE - PREV_IDLE))
DIFF_TOTAL=$((TOTAL - PREV_TOTAL))
CPU=$(((1000 * (DIFF_TOTAL - DIFF_IDLE) / DIFF_TOTAL + 5) / 10))

{ while read -r LINE; do
    case "$LINE" in
        'MemAvailable:'*)
            PFIX="${LINE%%[0123456789]*}"
            SFIX="${LINE#*[0123456789]}"
            case "$SFIX" in
                [0123456789]*)
                    SFIX="${SFIX#"${SFIX%%[!0123456789]*}"}"
                ;;
            esac

            MEMORY="${LINE#"$PFIX"}"
            MEMORY="${MEMORY%"$SFIX"}"
            MEMORY=$((MEMORY * 1024))

            MEMORY=$(awk -v 'bytes'="$MEMORY" '
function hsize(x, base) {
	basesuf = (base == "1024") ? "iB" : "B"

	s = "BKMGTEPYZ"
	while (x >= base && length(s) > 1)
		{x /= base; s = substr(s, 2)}
	s = substr(s, 1, 1)

	xf = (s == "B") ? "%d" : "%.2f"

	if (s != "B")
		s = s basesuf

	printf((xf " %s"), x, s)
}

BEGIN {
	printf hsize(bytes, 1000)
}
            ' 2> /dev/null)
        ;;
    esac
done < /proc/meminfo; } 2> /dev/null

{ read -r BATTERY < /sys/class/power_supply/BAT0/capacity; } 2> /dev/null

VOLUME=$(pamixer --get-volume 2> /dev/null)

AUDIO_SINK=$(pactl list sinks 2> /dev/null)
{
_STATE=; _NAME=
while IFS= read -r LINE; do
    case "$LINE" in
        *'State: RUNNING'*) _STATE=1 ;;
    esac

    case "$LINE" in
        *'Name: '*)
            if [ "$_STATE" = 1 ]; then
                _NAME="${LINE#*Name: }"; break
            fi
        ;;
    esac
done \
<<EOF
$AUDIO_SINK
EOF

AUDIO_SINK="$_NAME"
} 2> /dev/null
case "$AUDIO_SINK" in
    'alsa_output'*) AUDIO_SINK=ALSA ;;
    'bluez_output'*) AUDIO_SINK=BLUEZ ;;
esac

KB_LAYOUT=$(
    swaymsg -t get_inputs | \
    jq 'map(select(has("xkb_active_layout_name")))[0].xkb_active_layout_name'
)
case "$KB_LAYOUT" in
    *'English'*)
        KB_LAYOUT=EN
    ;;
    *'Bulgarian'*)
        KB_LAYOUT=BG
    ;;
esac

DATE=$(date "+%A%_d,%_I:%M %p" 2> /dev/null)
while :; do case "$DATE" in
    *[0123456789]','[0123456789]*)
        DATE="${DATE%\,*}, ${DATE#*\,}"
    ;;
    *'day'[0123456789]*)
        DATE="${DATE%day*}day ${DATE#*day}"
    ;;
    *)
        break
    ;;
esac done

STATUS="$TITLE | $MEMHOG"
if [ "$NET_USAGE" ]; then
    STATUS="$STATUS | $NET_USAGE"
fi
STATUS="$STATUS | ${CPU}% | $MEMORY"
case "$BATTERY" in
    100) : ;;
    *) STATUS="$STATUS | ~${BATTERY}%" ;;
esac
STATUS="$STATUS | ${VOLUME}%"
if [ "$AUDIO_SINK" ]; then
    STATUS="$STATUS | $AUDIO_SINK"
fi
STATUS="$STATUS | $KB_LAYOUT | $DATE |"

printf "%s" "$STATUS"
STATUS

    __file_write;
    __file_executable;

    FILE_PATH \
<<MUSIC_TOGGLE
$home/.config/sway/music_toggle
MUSIC_TOGGLE

    FILE \
<<'MUSIC_TOGGLE'
#!/bin/sh

MOCP_STATE=$(mocp -Q %state)
MOCP_PAUSE_FILE="${TMPDIR:-/tmp}"/music_toggle_mocp

if [ -f "$MOCP_PAUSE_FILE" ]; then
    if playerctl status 2> /dev/null | grep -q 'Playing'; then
        playerctl play-pause
    elif [ "$MOCP_STATE" = 'PAUSE' ]; then
        mocp -U
    fi

    rm -f "$MOCP_PAUSE_FILE"
    exit 0
elif [ "$MOCP_STATE" = 'PLAY' ]; then
    mocp -P
    : > "$MOCP_PAUSE_FILE"
    exit 0
fi

playerctl play-pause > /dev/null 2>&1
MUSIC_TOGGLE

    __file_write;
    __file_executable;

    FILE_PATH \
<<WP_HANDLER
$home/.config/sway/wp-handler
WP_HANDLER

    FILE \
<<'WP_HANDLER'
#!/bin/sh

WP_HANDLER

    FILE \
<<WP_HANDLER
WP=$home/.config/sway/wp
WP_HANDLER

    FILE \
<<'WP_HANDLER'
WP_NEW="${TMPDIR:-/tmp}"/wp

if [ -f "$WP_NEW" ]; then
    swaymsg output '*' bg "$WP_NEW" fill
elif [ -f "$WP" ]; then
    swaymsg output '*' bg "$WP" fill
fi
WP_HANDLER

    __file_write;
    __file_executable;
}

_swaylock_conf() {
    FILE_PATH \
<<CONFIG
$home/.swaylock/config
CONFIG

    FILE \
<<'CONFIG'
color=2b2e37
indicator-idle-visible
inside-color=2b2e37
ring-color=0A75AD
layout-bg-color=2b2e37
layout-border-color=2b2e37
CONFIG

    __file_write;
}

_sysctl_conf() {
    FILE_PATH \
<<'99_SYSCTL_CONF'
/etc/sysctl.d/99-sysctl.conf
99_SYSCTL_CONF

    FILE \
<<'99_SYSCTL_CONF'
kernel.sysrq = 1
99_SYSCTL_CONF

    __file_write;
}

_tz() {
    if [ "$bg" = 1 ]; then
        _tz_bg;
    elif [ "$de" = 1 ]; then
        _tz_de;
    else
        _info -white - 'Nothing to be done.'

        return 0
    fi
}

# Bulgarian timezone (Europe/Sofia)
_tz_bg() {
    FILE_PATH \
<<'SOFIA'
/usr/share/zoneinfo/Europe/Sofia
SOFIA

    FILE_PATH_TARGET \
<<'LOCALTIME'
/etc/localtime
LOCALTIME

    __loc_target_link_overwrite;

    __cmd hwclock -w
}

# German timezone (Europe/Berlin)
_tz_de() {
    FILE_PATH \
<<'BERLIN'
/usr/share/zoneinfo/Europe/Berlin
BERLIN

    FILE_PATH_TARGET \
<<'LOCALTIME'
/etc/localtime
LOCALTIME

    __loc_target_link_overwrite;

    __cmd hwclock -w
}

_xdg_conf() {
    FILE_PATH \
<<MIMEAPPS_LIST
$home/.config/mimeapps.list
MIMEAPPS_LIST

    FILE \
<<'MIMEAPPS_LIST'
# Programs that support:
[Added Associations]
application/json=featherpad.desktop
application/javascript=firefox.desktop

# Programs that don't support:
[Removed Associations]

# Programs that will be used to open by default:
[Default Applications]
# /usr/lib/firefox/firefox: URLs / `.html` / `.pdf` / `.json`
x-scheme-handler/http=firefox.desktop
x-scheme-handler/https=firefox.desktop
text/html=firefox.desktop
application/pdf=firefox.desktop
application/json=firefox.desktop
# /usr/bin/featherpad: Text / Empty file / `.patch`/`.diff` / `.sh` / `.c` /
# JavaScript source
text/plain=featherpad.desktop
inode/x-empty=featherpad.desktop
text/x-diff=featherpad.desktop
text/x-shellscript=featherpad.desktop
text/x-c=featherpad.desktop
application/javascript=featherpad.desktop
MIMEAPPS_LIST

    __file_write;

    FILE_PATH_TARGET \
<<MIMEAPPS_LIST
$home/.local/share/applications/mimeapps.list
MIMEAPPS_LIST

    __loc_target_link_overwrite;

    FILE_PATH \
<<INDEX_THEME
$home/.icons/default/index.theme
INDEX_THEME

    FILE \
<<'INDEX_THEME'
[icon theme]
Inherits=Breeze
INDEX_THEME

    __file_write;
}

#! .desc:
# Assert the passed arguments match BRE: [0-9A-Za-z_-]
#! .params:
# <"$1"+> - argument
#! .gives:
# (0) <"$_arg"> - the last argument
# (1) <"$_arg"> - the bad argument
#! .rc:
# (0) yes
# (1) no
# (255) bad input
#.
main_assert_args() {
    assert -min "$#" 1 || return 255

    for _arg in "$@"; do
        [ "$_arg" ] || return 255

        case "$_arg" in
            *[!0-9A-Za-z_-]*) return 1 ;;
        esac
    done
}

#! .desc:
# Assert the passed arguments are valid operations
#! .params:
# <"$1"+> - operation
#! .uses:
# <ops> $ - the list of operations
#! .gives:
# (0) <"$_opd"> - the last operation
# (1) <"$_opd"> - the bad operation
#! .rc:
# (0) yes
# (1) no
# (255) bad input
#.
main_assert_ops() {
    assert -min "$#" 1 || return 255

    for _opd in "$@"; do
        [ "$_opd" ] || return 255

        case "$ops" in
            "$_opd "* | *" $_opd" | *" $_opd "*) : ;;
            *) return 1 ;;
        esac
    done
}

err_handler() {
    trap - INT TERM EXIT

    # env cleanup
    if [ -e "$tmpd" ] || [ -e "$tmpf" ] || [ -e "$logf" ]; then
        chattr -R -ia "$tmpd" "$tmpf" "$logf" > /dev/null 2>&1 || :
        rm -rf "$tmpd" "$tmpf" "$logf"
    fi

    if [ "$2" = INT ]; then
        err -red - "${0##*/}: Received INT signal. ($1)"; kill -2 "$$"
    else
        err -red - "${0##*/}: Received $2 signal. ($1)"; exit "$1"
    fi
}

main() {
    # Control switches
    # Always write files, even if the remote/fs content matches ours.
    always_write=0
    # Force file writes by remote/fs object overwrite/removal:
    force_write=0
    # Disable command output:
    silent_cmd=0
    # Disable content output of file writes:
    silent_write=0

    # Device switches
    # ASUS VivoBook S15 X521IA-M533IA (AMD):
    m533ia=1

    # OS switches
    # Arch Linux system:
    arch_linux=1

    # Software switches
    # Configure highest audio resampling quality possible when resampling:
    audio_hq_resamp=0
    # Bluetooth support (D-Bus dependent)
    bluetooth=1
    # Configure and prefer IPv6 over IPv4:
    ipv6=0
    # XDG portals support (D-Bus dependent protocols)
    portal=1

    # Location switches
    # Bulgaria:
    bg=0
    # Germany:
    de=1

    # Software
    # Audio player daemon; currently supported: moc, none
    audio_playerd='moc'
    # Audio server; currently supported: pipewire, none
    audio_server='pipewire'
    # Web browser; currently supported: firefox, none
    browser='firefox'
    # Display server; currently supported: wayland, none
    display_server='wayland'
    # DNS; currently supported: localhost, none
    dns='localhost'
    # Dedicated DNS (stub) resolver (localhost); currently supported: dnsmasq,
    # none
    dns0='dnsmasq'
    # Init system; currently supported: systemd, none
    init='systemd'
    # Pipewire manager; currently supported: pipewire, none
    pipewire_manager='pipewire'
    # QT theme engine; currently supported: kvantum, none
    qt_theme='kvantum'
    # WLAN daemon; currently supported: iwd, none
    wland='iwd'
    # Window manager / desktop environment; currently supported: sway, none
    wm='sway'

    # Data
    gid='1000'
    group='mscalindt'
    hostname='syscfg'
    uid='1000'
    user='mscalindt'

    # Locations
    home='/home/mscalindt'
    efi_mnt='/efi'
    arch_mirlist='/etc/pacman.d/mirrorlist'

    # Operations
    ops=
    ops="$ops alsa-conf"
    ops="$ops autostart"
    ops="$ops bash-conf"
    ops="$ops bluez-conf"
    ops="$ops clk-sync"
    ops="$ops conf-1"
    ops="$ops conf-2"
    ops="$ops conf-3"
    ops="$ops conf-4"
    ops="$ops dhcpcd-conf"
    ops="$ops dnsmasq-conf"
    ops="$ops doas-conf"
    ops="$ops env"
    ops="$ops face-bin"
    ops="$ops featherpad-conf"
    ops="$ops firefox-conf"
    ops="$ops fontconfig-conf"
    ops="$ops fuse-conf"
    ops="$ops gai-conf"
    ops="$ops git-conf"
    ops="$ops gov-performance"
    ops="$ops gov-schedutil"
    ops="$ops grub grub-conf"
    ops="$ops gtk-conf"
    ops="$ops hostname"
    ops="$ops hosts"
    ops="$ops imv-conf"
    ops="$ops initramfs-conf"
    ops="$ops iwd-conf"
    ops="$ops kitty-conf"
    ops="$ops kvantum-conf"
    ops="$ops locale"
    ops="$ops makepkg-conf"
    ops="$ops moc-conf"
    ops="$ops modprobe-conf"
    ops="$ops mpv-conf"
    ops="$ops mutt-conf"
    ops="$ops nano-conf"
    ops="$ops nvram-clr"
    ops="$ops openal-conf"
    ops="$ops pacman-conf"
    ops="$ops pam-conf"
    ops="$ops pipewire-conf"
    ops="$ops pipewire-media-session-conf"
    ops="$ops ranger-conf"
    ops="$ops reflector"
    ops="$ops resolv-conf"
    ops="$ops sh"
    ops="$ops sudo-conf"
    ops="$ops sway-conf"
    ops="$ops sway-conf-gaming"
    ops="$ops swaylock-conf"
    ops="$ops sysctl-conf"
    ops="$ops tz"
    ops="$ops xdg-conf"
    ops="${ops# }"

    # Utility internal locations
    # Temporary per-function dir (cleared on func exit):
    tmpd="${TMPDIR:-/tmp}/syscfg_tmpd"
    # Temporary per-function file (cleared on func exit):
    tmpf="${TMPDIR:-/tmp}/syscfg_tmpf"
    # Temporary per-function log file (cleared on func exit):
    logf="${TMPDIR:-/tmp}/syscfg_logf"

    # Enable always_write from cmdline:    ^AW as $1
    # Enable audio_hq_resamp from cmdline: ^AQ as $1
    # Enable force_write from cmdline:     ^FW as $1
    # Enable ipv6 from cmdline:            ^I6 as $1
    # Enable silent_cmd from cmdline:      ^SC as $1
    # Enable silent_write from cmdline:    ^SW as $1
    while :; do case "$1" in
        '^AW') always_write=1; shift && continue ;;
        '^AQ') audio_hq_resamp=1; shift && continue ;;
        '^FW') force_write=1; shift && continue ;;
        '^I6') ipv6=1; shift && continue ;;
        '^SC') silent_cmd=1; shift && continue ;;
        '^SW') silent_write=1; shift && continue ;;
        *) break ;;
    esac done

    readonly tmpd tmpf logf always_write force_write m533ia \
             arch_linux audio_hq_resamp bluetooth browser dns dns0 init \
             ipv6 qt_theme display_server wm bg de user home efi_mnt \
             arch_mirlist ops audio_server hostname wland audio_playerd portal \
             silent_cmd silent_write gid group uid pipewire_manager

    { assert -min "$#" 1 && main_assert_ops "$@"; } || {
        if [ "$#" -eq 0 ]; then
            err -red - 'No operation has been specified.'
        else
            err -red - "Unrecognized operation: '$_opd'"
        fi

        ifs_map "$ops" info -white -
        info -white - 'SWITCH: always_write ^AW'
        info -white - 'SWITCH: audio_hq_resamp ^AQ'
        info -white - 'SWITCH: force_write ^FW'
        info -white - 'SWITCH: ipv6 ^I6'
        info -white - 'SWITCH: silent_cmd ^SC'
        info -white - 'SWITCH: silent_write ^SW'

        exit 2
    }

    main_assert_args "$@" || {
        err -red - "Bad argument: '$_arg'."

        info -white - "Allowed characters: 0-9A-Za-z_-"

        exit 2
    }

    # end arg parsing; main()

    [ "$(id -u)" = 0 ] || {
        err -red - 'Missing root rights.'; exit 1
    }

    LC_ALL=C; export LC_ALL
    LF='
'
    readonly LF

    # past env cleanup from SIGKILL or something else
    if [ -e "$tmpd" ] || [ -e "$tmpf" ] || [ -e "$logf" ]; then
        chattr -R -ia "$tmpd" "$tmpf" "$logf" > /dev/null 2>&1 || :
        rm -rf "$tmpd" "$tmpf" "$logf"
    fi

    while [ "$1" ]; do
        opd="_$1"; case "$opd" in
            *'-'*) replchar_posix '-' '_' "$opd" && opd="$_str" ;;
        esac

        # use '|| :' to validate a command failure
        set -e
        trap "err_handler \$? INT" INT
        trap "err_handler \$? TERM" TERM
        trap "err_handler \$? EXIT" EXIT

        # env setup
        { mkdir -p "$tmpd" && chmod 0700 "$tmpd"; } || {
            set -- "$?"
            err -red - "Cannot create tmpd: $tmpd"
            exit "$1"
        }
        { : > "$tmpf" && chmod 0600 "$tmpf"; } || {
            set -- "$?"
            err -red - "Cannot create tmpf: $tmpf"
            exit "$1"
        }
        { : > "$logf" && chmod 0600 "$logf"; } || {
            set -- "$?"
            err -red - "Cannot create logf: $logf"
            exit "$1"
        }

        eval "info -blue - \"$1 -> ${opd}()\"; ( $opd; )"
        RC=$?

        # env reset
        FILE=; FILE_PATH_TARGET=
        umask 022
        if [ -e "$tmpd" ] || [ -e "$tmpf" ] || [ -e "$logf" ]; then
            chattr -R -ia "$tmpd" "$tmpf" "$logf" > /dev/null 2>&1 || :
            rm -rf "$tmpd" "$tmpf" "$logf"
        fi

        trap - INT TERM EXIT
        set +e

        info -green - 'Done!'

        shift
    done; readonly RC

    # env cleanup
    if [ -e "$tmpd" ] || [ -e "$tmpf" ] || [ -e "$logf" ]; then
        chattr -R -ia "$tmpd" "$tmpf" "$logf" > /dev/null 2>&1 || :
        rm -rf "$tmpd" "$tmpf" "$logf"
    fi

    return "$RC"
}

assertive_functions;
helper_functions;
utility_functions;
utility_functions_err;
utility_functions_out;
main "$@"
