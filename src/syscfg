#!/bin/sh
# SPDX-License-Identifier: BSD-2-Clause
# Copyright (C) 2021-2025 Dimitar Yurukov <mscalindt@protonmail.com>
#
# syscfg - declarative OS configuration
#
# Table of syscfg-defined error codes:
# ---
# (1): EERROR: "General operation error".
# ---
# STANDARD:
# (1): EPERM: "Operation not permitted".
# (2): ENOENT: "No such file or directory".
# (17): EEXIST: "Already exists".
# (20): ENOTDIR: "Not a directory".
# (21): EISDIR: "Is a directory".
# (22): EINVAL: "Invalid argument".
# ---
# SPECIAL CUSTOM:
# (255): Bad function input/usage error.
#
# Use to_octal() or to_octal_offset() to obtain the POSIX shell-compatible
# octal escape sequence(s) of octal byte streams produced by `od -b -An` or
# `od -b`, respectively.

# Maintainer note for any functions in assertive_functions():
#
# Assertive functions shall not return `255` on empty input, and instead,
# simply return true/false appropriately. `255` is only returned when input is
# unspecified. If a function cannot adhere to the aforementioned, it does not
# belong in assertive_functions().
assertive_functions() { # START assertive_functions
    :
} # END assertive_functions

helper_functions() { # START helper_functions
    :
} # END helper_functions

# Maintainer note for any functions in utility_functions():
#
# Utility functions shall always begin with two underscore characters.
utility_functions() { # START utility_functions
    :
} # END utility_functions

# Maintainer note for any functions in utility_functions_err():
#
# Utility error functions shall always begin with an underscore character.
utility_functions_err() { # START utility_functions_err
    :
} # END utility_functions_err

# Maintainer note for any functions in utility_functions_out():
#
# Utility output functions shall always begin with an underscore character.
utility_functions_out() { # START utility_functions_out
#! .desc:
# Print formatted text to stderr (syscfg client string)
#! .params:
# <$1> - color(
#     '-'  - none
#     '-black' - bold (`1;`) foreground (`3X`) black (`0`)
#     '-blue' - bold (`1;`) foreground (`3X`) blue (`4`)
#     '-cyan' - bold (`1;`) foreground (`3X`) cyan (`6`)
#     '-green' - bold (`1;`) foreground (`3X`) green (`2`)
#     '-magenta' - bold (`1;`) foreground (`3X`) magenta (`5`)
#     '-red' - bold (`1;`) foreground (`3X`) red (`1`)
#     '-white' - bold (`1;`) foreground (`3X`) white (`7`)
#     '-yellow' - bold (`1;`) foreground (`3X`) yellow (`3`)
#     .
# )
# <$2> - format(
#     '-' - raw
#     '--' - raw; no <newline>
#     .
# )
# <"$3">+ - text
#! .uses.var.err:
# [NO_COLOR] $ - environment variable;
#                disable color
#! .uses.fn:
# <err> ('$@');
#       Print formatted text
#! .rc.fn:
# (err) (0) success
# (err) (*) error
#! .desc.ext:
# The colors are bold, foreground text, escape sequences of ANSI.
#
# The usage of color results in undefined behavior. For strict POSIX
# compatibility, specify `-` for $1 or set variable `NO_COLOR`
# to a non-empty value.
#.
_err() {
    _clr="$1"
    _fmt="$2"

    shift 2 && set -- "$_clr" "$_fmt" "[E $$ $opd]" "$@"

    err "$@"
}

#! .desc:
# Print formatted text to stdout (syscfg client string)
#! .params:
# <$1> - color(
#     '-'  - none
#     '-black' - bold (`1;`) foreground (`3X`) black (`0`)
#     '-blue' - bold (`1;`) foreground (`3X`) blue (`4`)
#     '-cyan' - bold (`1;`) foreground (`3X`) cyan (`6`)
#     '-green' - bold (`1;`) foreground (`3X`) green (`2`)
#     '-magenta' - bold (`1;`) foreground (`3X`) magenta (`5`)
#     '-red' - bold (`1;`) foreground (`3X`) red (`1`)
#     '-white' - bold (`1;`) foreground (`3X`) white (`7`)
#     '-yellow' - bold (`1;`) foreground (`3X`) yellow (`3`)
#     .
# )
# <$2> - format(
#     '-' - raw
#     '--' - raw; no <newline>
#     .
# )
# <"$3">+ - text
#! .uses.var.info:
# [NO_COLOR] $ - environment variable;
#                disable color
#! .uses.fn:
# <info> ('$@');
#        Print formatted text
#! .rc:
# (info) (0) success
# (info) (*) error
#! .desc.ext:
# The colors are bold, foreground text, escape sequences of ANSI.
#
# The usage of color results in undefined behavior. For strict POSIX
# compatibility, specify `-` for $1 or set variable `NO_COLOR`
# to a non-empty value.
#.
_info() {
    _clr="$1"
    _fmt="$2"

    shift 2 && set -- "$_clr" "$_fmt" "[I $$ $opd]" "$@"

    info "$@"
}
} # END utility_functions_out

# START boilerplate_functions

#! .desc:
# Check if a command exists
#! .params:
# <"$1"> - command
#! .rc:
# (0) yes
# (*) no
# (255) bad input
#.
cmd() {
    assert -eq "$#" 1 || return 255

    command -v "$1" > /dev/null 2>&1
}

#! .desc:
# Check if a given path is a directory
#! .params:
# <"$1"> - path
#! .rc:
# (0) yes
# (1) no
# (255) bad input
#.
dir() {
    assert -eq "$#" 1 || return 255

    [ -d "$1" ]
}

#! .desc:
# Check if a given path exists
#! .params:
# <"$1"> - path
#! .rc:
# (0) yes
# (1) no
# (255) bad input
#.
exist() {
    assert -eq "$#" 1 || return 255

    [ -e "$1" ]
}

#! .desc:
# Check if a given path is a regular file
#! .params:
# <"$1"> - path
#! .rc:
# (0) yes
# (1) no
# (255) bad input
#.
file() {
    assert -eq "$#" 1 || return 255

    [ -f "$1" ]
}

#! .desc:
# Assert a given string is strict POSIX shell-compatible octal escape
# sequence(s)
#! .params:
# <["$1"]> - string
#! .uses.fn:
# <assert> ('-eq' '$#' '1');
#          Assert a string
#! .uses.util:
# <awk> ("program" '$1');
#       pattern scanning and processing language
#! .rc.fn:
# (assert) (255) bad input
#! .rc.util:
# (awk) (0) true
# (awk) (1) false / error
# (awk) (*) error
#.
is_octal() {
    assert -eq "$#" 1 || return 255

    awk '
function is_valid_chunk(chunk) {
	return chunk ~ /^\\0[0-7]{3}$/ ? 0 : 1
}

BEGIN {
	string=ARGV[1]
	delete ARGV

	if (length(string) % 5 != 0)
		exit 1

	for (i = 1; i <= length(string); i += 5) {
		chunk = substr(string, i, 5)

		if (is_valid_chunk(chunk) == 1)
			exit 1
	}

	exit 0
}
    ' "$1"
}

#! .desc:
# Check if the system is booted in UEFI mode
#! .rc:
# (0) yes
# (1) no
#.
is_uefi() {
    dir '/sys/firmware/efi/efivars'
}

#! .desc:
# Check if a given path is readable
#! .params:
# <"$1"> - path
#! .rc:
# (0) yes
# (1) no
# (255) bad input
#.
readable() {
    assert -eq "$#" 1 || return 255

    [ -r "$1" ]
}

#! .desc:
# Check if text appears anywhere in a given string
#! .params:
# <"$1"> - text
# <"$2"> - string
#! .rc:
# (0) yes
# (1) no
# (255) bad input
#.
str() {
    assert -eq "$#" 2 || return 255

    case "$2" in
        *"$1"*) return 0 ;;
    esac

    return 1
}

#! .desc:
# Check if text appears at the left side of a given string
#! .params:
# <"$1"> - text
# <"$2"> - string
#! .rc:
# (0) yes
# (1) no
# (255) bad input
#.
str_pfix() {
    assert -eq "$#" 2 || return 255

    case "$2" in
        "$1"*) return 0 ;;
    esac

    return 1
}

#! .desc:
# Check if text appears at the right side of a given string
#! .params:
# <"$1"> - text
# <"$2"> - string
#! .rc:
# (0) yes
# (1) no
# (255) bad input
#.
str_sfix() {
    assert -eq "$#" 2 || return 255

    case "$2" in
        *"$1") return 0 ;;
    esac

    return 1
}

#! .desc:
# Check if a given path is writable
#! .params:
# <"$1"> - path
#! .rc:
# (0) yes
# (1) no
# (255) bad input
#.
writable() {
    assert -eq "$#" 1 || return 255

    [ -w "$1" ]
}

# END boilerplate_functions
# START output_functions

#! .desc:
# Print formatted text to stderr
#! .params:
# <$1> - color(
#     '-'  - none
#     '-black' - bold (`1;`) foreground (`3X`) black (`0`)
#     '-blue' - bold (`1;`) foreground (`3X`) blue (`4`)
#     '-cyan' - bold (`1;`) foreground (`3X`) cyan (`6`)
#     '-green' - bold (`1;`) foreground (`3X`) green (`2`)
#     '-magenta' - bold (`1;`) foreground (`3X`) magenta (`5`)
#     '-red' - bold (`1;`) foreground (`3X`) red (`1`)
#     '-white' - bold (`1;`) foreground (`3X`) white (`7`)
#     '-yellow' - bold (`1;`) foreground (`3X`) yellow (`3`)
#     .
# )
# <$2> - format(
#     '-' - raw
#     '--' - raw; no <newline>
#     .
# )
# <"$3">+ - text
#! .uses.var.info:
# [NO_COLOR] $ - environment variable;
#                disable color
#! .uses.fn:
# <info> ('$@');
#        Print formatted text
#! .rc.fn:
# (info) (0) success
# (info) (*) error
#! .desc.ext:
# The colors are bold, foreground text, escape sequences of ANSI.
#
# The usage of color results in undefined behavior. For strict POSIX
# compatibility, specify `-` for $1 or set variable `NO_COLOR`
# to a non-empty value.
#.
err() {
    info "$@" >&2
}

#! .desc:
# Identify the type of an object on the filesystem
#! .params:
# <"$1"> - path
# [$2] - fd(
#     '-err' - print to stderr; &2
#     '-info' - print to stdout; &1
#     .
# )
#! .uses.var.err:
# [NO_COLOR] $ - environment variable;
#                disable color
#! .uses.var.info:
# [NO_COLOR] $ - environment variable;
#                disable color
#! .uses.fn:
# (-err) <err> ('-red' '--' "text");
#              Print formatted text to stderr
# (-info) <info> ('-white' '--' "text");
#                Print formatted text
#! .sets:
# (0) <_type> $ - 'B' | 'C' | 'D' | 'F' | 'L' | 'P' | 'S' | '?';
# (1) <_type> $ - '>';
#! .rc:
# (0) success
# (1) does not exist
# (255) bad input
#! .rc.fn:
# (err) (*) error
# (info) (*) error
#! .desc.ext:
# The function denotes the type of the specified object using a letter.
# File categorization will take precedence over directory categorization,
# but exceptions[1] apply. Special file categorization will take precedence
# over regular file categorization according to implicit POSIX behavior,
# depicted below in absolute order.
#
# `L` means "symbolic link";
# `B` means "block special file";
# `C` means "character special file";
# `S` means "socket";
# `P` means "FIFO / named pipe";
# `F` means "regular file";
# `D` means "directory";
# `?` means "unrecognized file type"[2];
# `>` means "does not exist".
#
# The usage of color results in undefined behavior. For strict POSIX
# compatibility, set variable `NO_COLOR` to a non-empty value.
#
# For more information, refer to:
# > "POSIX.1-2024, Volume: Base Definitions, Section: General Concepts,
#   Subsection: Pathname Resolution".
# > "POSIX.1-2024, Volume: Shell & Utilities, Section: Utilities,
#   Utility: test".
#
# [1] A trailing slash in the path string can affect the assert, effectively
#     forcing the type to resolve to a directory or otherwise inexistence.
#     See the "Pathname Resolution" POSIX reference for details.
# [2] Practically, on POSIX shells and systems, `?` (unrecognized file type)
#     should never be returned, but nonetheless exists as a catch-all
#     on non-POSIX platforms.
#.
ftype() {
    case "$2" in
        '-err') set -- "$1" 'err' '-red' '--' ;;
        '-info') set -- "$1" 'info' '-white' '--' ;;
        *) [ ! "$2" ] || return 255; set -- "$1" ':' ;;
    esac

    if [ -h "$1" ]; then
        shift; _type='L'; "$@" 'L' || return "$?"
    elif [ -b "$1" ]; then
        shift; _type='B'; "$@" 'B' || return "$?"
    elif [ -c "$1" ]; then
        shift; _type='C'; "$@" 'C' || return "$?"
    elif [ -S "$1" ]; then
        shift; _type='S'; "$@" 'S' || return "$?"
    elif [ -p "$1" ]; then
        shift; _type='P'; "$@" 'P' || return "$?"
    elif [ -f "$1" ]; then
        shift; _type='F'; "$@" 'F' || return "$?"
    elif [ -d "$1" ]; then
        shift; _type='D'; "$@" 'D' || return "$?"
    elif [ -e "$1" ]; then
        shift; _type='?'; "$@" '?' || return "$?"
    else
        shift; _type='>'; "$@" '>' || return "$?"; return 1
    fi

    return 0
}

#! .desc:
# Print formatted text
#! .params:
# <$1> - color(
#     '-'  - none
#     '-black' - bold (`1;`) foreground (`3X`) black (`0`)
#     '-blue' - bold (`1;`) foreground (`3X`) blue (`4`)
#     '-cyan' - bold (`1;`) foreground (`3X`) cyan (`6`)
#     '-green' - bold (`1;`) foreground (`3X`) green (`2`)
#     '-magenta' - bold (`1;`) foreground (`3X`) magenta (`5`)
#     '-red' - bold (`1;`) foreground (`3X`) red (`1`)
#     '-white' - bold (`1;`) foreground (`3X`) white (`7`)
#     '-yellow' - bold (`1;`) foreground (`3X`) yellow (`3`)
#     .
# )
# <$2> - format(
#     '-' - raw
#     '--' - raw; no <newline>
#     .
# )
# <"$3">+ - text
#! .uses.var:
# [NO_COLOR] $ - environment variable;
#                disable color
#! .rc:
# (0) success
# (*) error
# (255) bad input / error
#! .desc.ext:
# The colors are bold, foreground text, escape sequences of ANSI.
#
# The usage of color results in undefined behavior. For strict POSIX
# compatibility, specify `-` for $1 or set variable `NO_COLOR`
# to a non-empty value.
#.
info() {
    _reset='\033[0m'; case $1 in
        '-') _color=; _reset= ;;
        '-black') _color='\033[1;30m' ;;
        '-red') _color='\033[1;31m' ;;
        '-green') _color='\033[1;32m' ;;
        '-yellow') _color='\033[1;33m' ;;
        '-blue') _color='\033[1;34m' ;;
        '-magenta') _color='\033[1;35m' ;;
        '-cyan') _color='\033[1;36m' ;;
        '-white') _color='\033[1;37m' ;;
        *) return 255 ;;
    esac

    _format="$2"

    [ ! "$NO_COLOR" ] || { _color=; _reset=; }

    shift 2; case "$_format" in
        '-') printf "%b%s%b\n" "$_color" "$*" "$_reset" ;;
        '--') printf "%b%s%b" "$_color" "$*" "$_reset" ;;
        *) return 255 ;;
    esac
}

# END output_functions
# START utility_functions

#! .desc:
# Set with single-quote escape an argument into a variable
#! .params:
# <$1> - variable name
# [["$2"]] - argument
#! .uses.fn:
# <assert> ('-shell-name' '$1');
#          Assert a string
# [replchar_posix] ('\'' '\'\\\'\'' '$2');
#                  Replace a specific character with character(s) in a string
#                  using PE
#! .rc:
# (0) success
# (*) error
#! .rc.fn:
# (assert) (255) bad input
# (replchar_posix) (*) error
#! .desc.ext:
# If $2 is unspecified/empty, an empty argument will be set in $1.
#
# For more information, refer to:
# > "POSIX.1-2024, Volume: Shell & Utilities, Section: Shell Command Language,
#   Subsection: Quoting".
#.
arg_set() {
    assert -shell-name "$1" || return 255

    # Escape any single quotes in the argument ($2).
    _str="$2"; case "$_str" in
        *\'*) replchar_posix \' \'\\\'\' "$_str" || return "$?" ;;
    esac  # -> $_str

    # The usage of `eval` here is safe. Assuming $_str is `"'\''abc` (we escape
    # single quotes in $2 before they're passed to `eval`):
    #
    # First expansion (current shell):
    # `eval "$1=\"'\$_str'\""` -> `eval a="'$_str'"` (lit.)
    #
    # Second expansion (`eval`):
    # `eval a="'$_str'"` -> `a = '"'\''abc'` (illust. of meta expansion)
    #
    # Key points:
    # - Due to the sophisticated escaping, single quotes from the first
    #   expansion carry their significance to the second expansion.
    eval "$1=\"'\$_str'\""
}

#! .desc:
# Assert a string
#! .params:
# <$1> - type(
#     '-single-quote-escaped-argument' - argument escaped with single quotes
#     '-single-quotes-array' - pseudo array of single-quote-escaped arguments
#     '-bit' - N that represents a valid bit (valid bit position)
#     '-eq' - N [0,1,00,01...] (integer) equal to another N
#     '-max' - N [0,1,00,01...] (integer) maximum of another N
#     '-min' - N [0,1,00,01...] (integer) minimum of another N
#     '-n' - N [0,1,00,01...] (integer)
#     '-greater-n' - N [0,1,00,01...] (integer) greater than another N
#     '-lower-n' - N [0,1,00,01...] (integer) lower than another N
#     '-natural-n' - natural N [1...] (positive integer)
#     '-whole-n' - whole N [0,1...] (non-negative integer)
#     '-portable-name' - portable ("Portable Filename") name
#     '-absolute-path' - absolute path (/*)
#     '-canonical-path' - lexically canonical (assertable) path
#     '-directory-path' - directory path
#     '-file-path' - file path
#     '-fs-canonical-path' - semantically canonical (assertable) path
#     '-relative-path' - relative path
#     '-shell-array' - shell-parseable evaluable array of arguments
#     '-shell-name' - portable shell-parseable name
#     '-shell-whitespace' - is "IFS white space" (<space>, <tab>, <newline>)
#     '-has-shell-whitespace' - contains "IFS white space" characters
#     .
# )
# <"$2"> - string
# ["$3"] - string
#! .uses:
# [()]
#! .rc:
# (0) true
# (1) false
# (2) false due to bad operand(s)
#! .ec:
# (255) bad input
#! .desc.ext:
# Empty input will assert false (return code `1`) by default; on string types
# with multiple input, `2` might be returned instead.
#
# For `-shell-array`, it is implementation-defined whether the array
# is evaluable, in part with what consists part of "IFS white space";
# the result of the assert is therefore made according to the locale in effect.
#
# For `-shell-whitespace` and `-has-shell-whitespace`, it is
# implementation-defined whether any other, in addition to
# the specified characters, consist part of "IFS white space";
# the result of the assert is therefore made according to the locale in effect.
#
# For more information, refer to:
# > "POSIX.1-2024, Volume: Base Definitions, Section: Definitions,
#   Subsection: Absolute Pathname".
# > "POSIX.1-2024, Volume: Base Definitions, Section: Definitions,
#   Subsection: Argument".
# > "POSIX.1-2024, Volume: Base Definitions, Section: Definitions,
#   Subsection: Name".
# > "POSIX.1-2024, Volume: Base Definitions, Section: Definitions,
#   Subsection: Portable Filename".
# > "POSIX.1-2024, Volume: Base Definitions, Section: Definitions,
#   Subsection: Portable Filename Character Set".
# > "POSIX.1-2024, Volume: Base Definitions, Section: Definitions,
#   Subsection: Relative Pathname".
# > "POSIX.1-2024, Volume: Base Definitions, Section: Definitions,
#   Subsection: User Name".
# > "POSIX.1-2024, Volume: Base Definitions, Section: General Concepts,
#   Subsection: Pathname Resolution".
# > "POSIX.1-2024, Volume: Base Definitions, Section: Regular Expressions,
#   Subsection: RE Bracket Expression".
# > "POSIX.1-2024, Volume: Shell & Utilities, Section: Shell Command Language,
#   Subsection: Escape Character (Backslash)".
# > "POSIX.1-2024, Volume: Shell & Utilities, Section: Shell Command Language,
#   Subsection: eval".
# > "POSIX.1-2024, Volume: Shell & Utilities, Section: Shell Command Language,
#   Subsection: Field Splitting".
# > "POSIX.1-2024, Volume: Shell & Utilities, Section: Shell Command Language,
#   Subsection: Quoting".
# > "POSIX.1-2024, Volume: Shell & Utilities, Section: Shell Command Language,
#   Subsection: set".
# > "POSIX.1-2024, Volume: Shell & Utilities, Section: Shell Command Language,
#   Subsection: Single-Quotes".
#.
assert() {
    case "$1" in
        # Assert $2 is a valid single-quote-escaped argument.
        #
        # A valid single-quote-escaped argument is a shell-parseable string
        # enclosed in single quotes. A single-quote inside
        # a single-quote-escaped argument is escaped
        # with the syntactical expression `'\''`.
        #
        # This string is semantically safe for `eval`.
        '-single-quote-escaped-argument')
            set -- "$2"; while [ "$1" ] || return 1; do
                [ "${1#\'}" != "$1" ] && set -- "${1#\'}" || return 1

                while [ "$1" ]; do
                    case "${1#*\'}" in
                        \\\'\'*) set -- "${1#*\'\\\'\'}"; continue ;;
                        '') return 0 ;;
                    esac

                    return 1
                done
            done
        ;;
        # Assert $2 is a valid single-quotes array of arguments.
        #
        # A valid single-quotes array is a shell-parseable string consisting
        # of at least one argument, each enclosed in single quotes
        # and delimited by <space>. A single-quote inside
        # a single-quote-escaped argument is escaped
        # with the syntactical expression `'\''`.
        #
        # This string is semantically safe for `eval`.
        '-single-quotes-array')
            set -- "${2%"${2##*[! ]}"}"; while [ "$1" ] || return 1; do
                set -- "${1#"${1%%[! ]*}"}"

                [ "${1#\'}" != "$1" ] && set -- "${1#\'}" || return 1

                while [ "$1" ]; do
                    case "${1#*\'}" in
                        \\\'\'*) set -- "${1#*\'\\\'\'}"; continue ;;
                        \ *) set -- "${1#*\'}"; continue 2 ;;
                        '') return 0 ;;
                    esac

                    return 1
                done
            done
        ;;
        # Assert $2 is a number that represents a valid bit.
        #
        # A valid bit is a natural number that represents a specific bit
        # position in a bitmask and is always a power of 2 (`1`, `2`, `4`, `8`,
        # ...). This is also known as "valid bit position".
        #
        # A number is a power of 2 if performing bitwise AND in the expression
        # `N & (N - 1)` results in zero (the binary representation turns to all
        # zeroes due to the single 1-bit being flipped off, given N is
        # a positive integer that is a power of 2).
        '-bit')
            assert -natural-n "$2" || return 2

            [ "$(($2 & ($2 - 1)))" = 0 ] || return 1
        ;;
        # Assert $2 is a number equal to $3.
        #
        # Leading zeroes are ignored, except `[0] -eq [0]` is true. This
        # comparison essentially emulates the behavior of operator `-eq` of
        # `test` in POSIX shells, just with support for extremely large
        # numbers. This comparison is also known as
        # "lexicographical numeric comparison".
        '-eq')
            assert -n "$2" || return 2
            assert -n "$3" || return 2

            set -- "${2#"${2%%[!0]*}"}" "${3#"${3%%[!0]*}"}"

            [ "$1" = "$2" ] || return 1
        ;;
        # Assert $2 is a number maximum of $3.
        #
        # Leading zeroes are ignored, except `[0] -eq [0]` is true. This
        # comparison essentially emulates the behavior of operator `-le` of
        # `test` in POSIX shells, just with support for extremely large
        # numbers. This comparison is also known as
        # "lexicographical numeric comparison".
        '-max')
            assert -lower-n "$2" "$3" || \
            assert -eq "$2" "$3" || \
            return "$?"
        ;;
        # Assert $2 is a number minimum of $3.
        #
        # Leading zeroes are ignored, except `[0] -eq [0]` is true. This
        # comparison essentially emulates the behavior of operator `-ge` of
        # `test` in POSIX shells, just with support for extremely large
        # numbers. This comparison is also known as
        # "lexicographical numeric comparison".
        '-min')
            assert -greater-n "$2" "$3" || \
            assert -eq "$2" "$3" || \
            return "$?"
        ;;
        # Assert $2 is a number (`0`, `1`, `00`, `01`, ...).
        #
        # A number is any string consisting only of digits. This is also
        # well known as "integer".
        '-n')
            case "${2:-0}${2#*[!0123456789]}" in
                "$2$2") return 0 ;;
            esac

            return 1
        ;;
        # Assert $2 is a number greater than $3.
        #
        # To determine which number is greater, leading zeroes are removed,
        # and the numbers are first compared by length, followed by
        # digit comparison if the lengths are the same. This comparison
        # essentially emulates the behavior of operator `-gt` of `test`
        # in POSIX shells, just with support for extremely large
        # numbers. This comparison is also known as
        # "lexicographical numeric comparison".
        '-greater-n')
            assert -n "$2" && assert -n "$3" || return 2

            set -- "${2#"${2%%[!0]*}"}" "${3#"${3%%[!0]*}"}"

            [ ! "$1" = "$2" ] && [ ! "${#1}" -lt "${#2}" ] || return 1
            [ ! "${#1}" -gt "${#2}" ] || return 0

            while [ "$1" ]; do
                case "$1" in
                    "${2%"${2#?}"}"*) set -- "${1#?}" "${2#?}"; continue ;;
                esac

                if [ "${1%"${1#?}"}" -gt "${2%"${2#?}"}" ]; then
                    return 0
                fi

                return 1
            done
        ;;
        # Assert $2 is a number lower than $3.
        #
        # To determine which number is lower, leading zeroes are removed,
        # and the numbers are first compared by length, followed by
        # digit comparison if the lengths are the same. This comparison
        # essentially emulates the behavior of operator `-lt` of `test`
        # in POSIX shells, just with support for extremely large
        # numbers. This comparison is also known as
        # "lexicographical numeric comparison".
        '-lower-n')
            assert -n "$2" && assert -n "$3" || return 2

            set -- "${2#"${2%%[!0]*}"}" "${3#"${3%%[!0]*}"}"

            [ ! "$1" = "$2" ] && [ ! "${#1}" -gt "${#2}" ] || return 1
            [ ! "${#1}" -lt "${#2}" ] || return 0

            while [ "$1" ]; do
                case "$1" in
                    "${2%"${2#?}"}"*) set -- "${1#?}" "${2#?}"; continue ;;
                esac

                if [ "${1%"${1#?}"}" -lt "${2%"${2#?}"}" ]; then
                    return 0
                fi

                return 1
            done
        ;;
        # Assert $2 is a natural number (`1`, `2`, ...).
        #
        # A natural number is any string consisting only of digits,
        # of which the first is not `0`. Also known as "positive integer"
        # in the POSIX standard.
        '-natural-n')
            case "${2:-0}${2#*[!0123456789]}" in
                0*) return 1 ;;
                "$2$2") return 0 ;;
            esac

            return 1
        ;;
        # Assert $2 is a whole number (`0`, `1`, `2`, ...).
        #
        # A whole number is `0` and any string consisting only of digits,
        # of which the first is not `0`. Also known as "non-negative integer"
        # in the POSIX standard.
        '-whole-n')
            assert -natural-n "$2" || \
            assert -eq "$2" 0 || \
            return "$?"
        ;;
        # Assert $2 is a portable ("Portable Filename") name.
        #
        # A portable name is a string composed of the characters in
        # the portable filename character set,
        # with the following exceptions:
        #
        # - Should not begin with a <hyphen-minus> character. This exception
        #   is currently not being asserted.
        #
        # The character classes have been intentionally expanded to be
        # locale-independent.
        '-portable-name')
            case "$2" in
                *[!0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_\.\-]*)
                    return 1
                ;;
            esac

            [ "$2" ] || return 1
        ;;
        # Assert $2 is an absolute (/*) path.
        #
        # An absolute path is any string of which the first character
        # is `/`.
        '-absolute-path')
            case "$2" in
                '/'*) return 0 ;;
            esac

            return 1
        ;;
        # Assert $2 is a lexically canonical (assertable) path.
        #
        # A canonical path is largely implementation-defined string that
        # refers to the normalized absolute path. Therefore,
        # a lexical canonical path is:
        #
        # - Assertive: Multiple consecutive slashes (`//`) are removed,
        #   `.` and `..` are resolved. The only exception is two consecutive
        #   slashes (`//`) at the beginning of the string, which is specified
        #   by the POSIX standard as an "implementation-defined" exception.
        #
        # - Absolute: The path is always rooted from `/`.
        '-canonical-path')
            case "$2" in
                '//'*) set -- "${2#/}" ;;
                *) set -- "$2" ;;
            esac

            case "$1" in
                *'//'*) return 1 ;;
                '/'*) : ;;
                *) return 1 ;;
            esac

            case "$1/" in
                *'/./'* | *'/../'*) return 1 ;;
            esac

            return 0
        ;;
        # Assert $2 is a directory (directory-resolving) path.
        #
        # A directory path is any string containing at least one non-<slash>
        # (`/`) character and that ends with one or more trailing <slash>
        # characters.
        '-directory-path')
            case "$2" in
                *[!/]*/) return 0 ;;
            esac

            return 1
        ;;
        # Assert $2 is a file (file-resolving) path.
        #
        # A file path is any string containing at least one non-<slash>
        # (`/`) character and that does not end with trailing <slash>
        # characters.
        '-file-path')
            case "$2" in
                *[!/]*/) return 1 ;;
                *[!/]*) return 0 ;;
            esac

            return 1
        ;;
        # Assert $2 is a semantically canonical (assertable) path.
        #
        # A canonical path is largely implementation-defined string that
        # refers to the normalized absolute path. Therefore,
        # a semantic canonical path is:
        #
        # - Semantic: Neither the path nor its segments are a symbolic link on
        #   the filesystem. The actual existence of the path or its segments is
        #   ignored.
        #
        # - Assertive: Multiple consecutive slashes (`//`) are removed,
        #   `.` and `..` are resolved.
        #
        # - Absolute: The path is always rooted from `/`.
        '-fs-canonical-path')
            case "$2" in
                '/') return 0 ;;
                *'//'*) return 1 ;;
                '/'*) set -- "${2%/}/" ;;
                *) return 1 ;;
            esac

            case "$1" in
                *'/./'* | *'/../'*) return 1 ;;
            esac

            while [ ! -h "${1%/}" ] || return 1; do
                [ "${1%/*/}" ] && set -- "${1%/*/}/" || return 0
            done
        ;;
        # Assert $2 is a relative (partial) path.
        #
        # A relative path is any string of which the first character
        # is not `/`.
        '-relative-path')
            case "$2" in
                '/'*) return 1 ;;
            esac

            [ "$2" ] || return 1
        ;;
        # Assert $2 is a shell-parseable evaluable array of arguments.
        #
        # A valid shell-parseable evaluable array is a parseable,
        # according to the shell grammar, whole string consisting of
        # at least one argument.
        #
        # This string is semantically safe for `eval`.
        '-shell-array')
            [ "$2" ] && ( eval set -- "$2" && [ "$#" -ge 1 ]; ) || return 1
        ;;
        # Assert $2 is a portable shell-parseable name.
        #
        # A portable shell-parseable name is a string composed of
        # the characters in the portable filename character set,
        # with the following exceptions:
        #
        # - Cannot begin with a digit.
        # - Cannot contain a <hyphen-minus> character.
        # - Cannot contain a <period> character.
        #
        # The character classes have been intentionally expanded to be
        # locale-independent.
        '-shell-name')
            case "$2" in
                [0123456789]*)
                    return 1
                ;;
                *[!0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_]*)
                    return 1
                ;;
            esac

            [ "$2" ] || return 1
        ;;
        # Assert $2 consists of "IFS white space" (<space>, <tab>, <newline>)
        # characters.
        '-shell-whitespace')
            [ "$2" ] && set -- $2 && [ "$#" -eq 0 ] || return 1
        ;;
        # Assert $2 contains "IFS white space" (<space>, <tab>, <newline>)
        # characters.
        '-has-shell-whitespace')
            [ "$2" ] && set -- .$2. && [ "$#" -ne 1 ] || return 1
        ;;
        *)
            exit 255
        ;;
    esac
}

#! .desc:
# Print bytes in human-readable fmt: "N" "X"iB / "N" "X"B
#! .params:
# <$1> - bytes
#! .rc:
# (0) success
# (*) error
# (255) bad input
#.
bytes_size() {
    assert -eq "$#" 1 || return 255

    awk -v 'bytes'="$1" '
	function hsize(x, base) {
		basesuf = (base == "1024") ? "iB" : "B"

		s = "BKMGTEPYZ"
		while (x >= base && length(s) > 1)
			{x /= base; s = substr(s, 2)}
		s = substr(s, 1, 1)

		xf = (s == "B") ? "%d" : "%.2f"

		if (s != "B")
			s = s basesuf

		printf((xf " %s"), x, s)
	}

	BEGIN {
		printf hsize(bytes, 1024)
		printf " / "
		print hsize(bytes, 1000)
	}
    ' 2> /dev/null
}

#! .desc:
# Remove the filesystem flag protection of a physical file
#! .params:
# <"$1"> - absolute path
#! .rc:
# (0) success
# (*) error
# (255) bad input
#.
chattr_remove() {
    assert -eq "$#" 1 || return 255

    cmd 'chattr' || return 0

    { [ -f "$1" ] && [ ! -h "$1" ]; } || return 0

    chattr -ia "$1" 2> /dev/null || :
}

#! .desc:
# Assert confirmation to continue
#! .params:
# [$1] - default_action(
#     '-n' - forbidden
#     '-y' - permitted
#     .
# )
#! .uses.var:
# [NO_COLOR] $ - environment variable;
#                disable color
#! .sets:
# <_action> $ - "read -r" | 'N' | 'Y';
# <_def_action> $ - 'N' | 'Y';
#! .rc:
# (0) true
# (1) false
# (255) bad input
#! .desc.ext:
# $1 specifies the default action to be used in case of empty input.
# If omitted, the default action is set to 'forbidden'.
#
# By default, bold (`1;`) foreground (`3X`) white (`7`) color
# escape sequence of ANSI is used in the prompt.
#
# The usage of color results in undefined behavior. For strict POSIX
# compatibility, set variable `NO_COLOR` to a non-empty value.
#.
confirm_cont() {
    # Set default action; defaults to `-n` if not specified.
    case "${1:--n}" in
        '-n')
            _def_action='N'
            _prompt='Continue? [y/N] '
        ;;
        '-y')
            _def_action='Y'
            _prompt='Continue? [Y/n] '
        ;;
        *)
            return 255
        ;;
    esac

    # Add white color to $_prompt if permitted.
    [ "$NO_COLOR" ] || _prompt='\033[1;37m'"$_prompt"'\033[0m'

    printf "%b" "$_prompt"

    # Store input in $_action; if empty, $_def_action is stored instead.
    read -r _action; [ "$_action" ] || _action="$_def_action"

    # Return "permitted" if the first character entered is `Y` or `y`.
    case "$_action" in
        [Yy]*) return 0 ;;
    esac

    return 1
}

#! .desc:
# Create a deterministic file data edit format
#! .params:
# <["$1"]> - file content
# <$2>+ - operation(
#     '-' - EOF add $3
#     '-m' - apply modifier for `-a`/`-r`/`-s`; see extended description
#     '-a' - add $3
#     '-r' - remove $3
#     '-s' - substitute $3 with $4
#     .
# )
# ["$3"] - string
# ["$4"] - string
#! .uses:
# <()>
# <<<>
#! .uses.fn:
# [arg_set] ("variable name" "argument");
#           Set with single-quote escape an argument into a variable
#! .gives:
# (0) <"$_fmt"> - string;
#                 shell-parseable evaluable line-sorted operations list
#! .sets:
# <fed_> ();
#! .rc:
# (0) success
# (1) no operations to be created / error
# (*) error
# (255) bad input / bad usage / error
#! .rc.fn:
# (arg_set) (*) error
#! .desc.ext:
# The format of created operations is as follows (N - natural number):
# `-a N X`, means at "N" line add "X" data;
# `-r N`,   means remove "N" line;
# `-s N X`, means substitute "N" line with "X" data.
#
# Created operations are line-sorted and FIFO.
# Created EOF operations are specified after all line operations.
#
# FIFO operations take precedence over any additional operations.
# Without modifiers, the default modification behavior is "line of".
# The modifiers are stackable, but may override same-type incompatibility.
#
# $3 cannot be a multiline string, except for `-` and `-a`.
#
# Option `-m` offers the following primary type (conditional) modifier(s):
# ``;
# the following secondary type (modification behavior) modifier(s):
# <n>:           a natural number that specifies a line;
# `mof`:         substitution modification behavior is "match of";
# and the following tertiary type (string matching behavior) modifier(s):
# `e`:           exact string matching assert;
# `p`:           prefix string matching assert;
# `s`:           suffix string matching assert.
#.
fed() {
    fed_() {
        _line="$1"
        _orig_offset="$2"
        shift 2

        # Test all operations against the current line in FIFO manner.
        while [ "$#" -ge 1 ]; do
            _mod_p=; _mod_s=; _mod_t=

            # Set modifiers.
            # `mof` -> `m` in $_mod_s
            # <n> -> "<n>" in $_mod_s
            # `e` -> `e` in $_mod_t
            # `p` -> `p` in $_mod_t
            # `s` -> `s` in $_mod_t
            while :; do case "$1 $2" in
                '-m mof')
                    _mod_s="m ${_mod_s#'m '}"; shift 2 && continue
                ;;
                '-m e')
                    _mod_t=e; shift 2 && continue
                ;;
                '-m p')
                    _mod_t=p; shift 2 && continue
                ;;
                '-m s')
                    _mod_t=s; shift 2 && continue
                ;;
                '-m '*)
                    # Assert $2 is a natural number (`1`, `2`, ...).
                    case "${2:-0}${2#*[!0123456789]}" in
                        0*) return 255 ;;
                        "$2$2") _mod_s="$_mod_s $2 "; shift 2 && continue ;;
                        *) return 255 ;;
                    esac
                ;;
                *)
                    break
                ;;
            esac done

            case "$1" in
                '-')
                    case "$#" in 1) return 255 ;; esac

                    shift 2 && continue
                ;;
                '-a')  # $2 = string
                    case "$#" in 1) return 255 ;; esac
                    case "$_mod_s" in 'm '*) return 255 ;; esac

                    # Test <n> modifier.
                    case "${_mod_s:-0}" in
                        *" $_orig_offset "*)
                            set -- '-a' "$2" "$_orig_offset"
                        ;;
                        0)
                            # Assert addition <noop>; is a valid operation,
                            # hence is the line regarded as parsed.
                            [ "$2" ] || return 0

                            set -- '-s' "$_line$2" "$_orig_offset"
                        ;;
                        *)  # Operation <noop>.
                            shift 2 && continue
                        ;;
                    esac

                    arg_set _a "$2" || return "$?"

                    # $3 = orig_offset
                    printf "%s" " '$1' '$3' $_a"

                    return 0
                ;;
                '-r')  # $2 = string
                    case "$#" in 1) return 255 ;; esac
                    case "$_mod_s" in 'm '*) return 255 ;; esac

                    # Assert <n> modifier.
                    case "${_mod_s:-0}" in
                        *" $_orig_offset "* | 0) : ;;
                        *) shift 2 && continue ;;  # Operation <noop>.
                    esac

                    # Test `e`/`p`/`s` string matching modifiers.
                    case "$_mod_t" in
                        e)
                            case "$_line" in
                                "$2") : ;;
                                *) shift 2 && continue ;;
                            esac
                        ;;
                        p)
                            case "$_line" in
                                "$2"*) : ;;
                                *) shift 2 && continue ;;
                            esac
                        ;;
                        s)
                            case "$_line" in
                                *"$2") : ;;
                                *) shift 2 && continue ;;
                            esac
                        ;;
                        *)
                            # Test default string match.
                            case "$_line" in
                                *"$2"*) : ;;
                                *) shift 2 && continue ;;
                            esac
                        ;;
                    esac

                    printf "%s" " '-r' '$_orig_offset'"

                    return 0
                ;;
                '-s')  # $2 = string; $3 = string
                    case "$#" in 1|2) return 255 ;; esac

                    # Assert <n> modifier.
                    case "${_mod_s:-m }" in
                        *" $_orig_offset "* | 'm '*) : ;;
                        *) shift 3 && continue ;;  # Operation <noop>.
                    esac

                    # Test `mof` (`m`) modifier.
                    case "$_mod_s" in
                        'm '*)
                            # Assert operation <noop>.
                            [ "$2" ] || { shift 3 && continue; }

                            case "$_line" in
                                *"$2"*)
                                    _a="$2"; _b="$3"; shift 3
                                    _b="${_line%%"$_a"*}$_b${_line#*"$_a"}"
                                    set -- '' "$_a" "$_b" "$@"
                                ;;
                            esac
                        ;;
                    esac

                    # Test `e`/`p`/`s` string matching modifiers.
                    # Asserts addition <noop>; is a valid operation,
                    # hence is the line regarded as parsed.
                    case "$_mod_t" in
                        e)
                            case "$_line" in
                                "$3") return 0 ;;  # Addition <noop>.
                                "$2") : ;;
                                *) shift 3 && continue ;;
                            esac
                        ;;
                        p)
                            case "$_line" in
                                "$3") return 0 ;;  # Addition <noop>.
                                "$2"*) : ;;
                                *) shift 3 && continue ;;
                            esac
                        ;;
                        s)
                            case "$_line" in
                                "$3") return 0 ;;  # Addition <noop>.
                                *"$2") : ;;
                                *) shift 3 && continue ;;
                            esac
                        ;;
                        *)
                            # Test default string match.
                            case "$_line" in
                                "$3") return 0 ;;  # Addition <noop>.
                                *"$2"*) : ;;
                                *) shift 3 && continue ;;
                            esac
                        ;;
                    esac

                    set -- '' '' "$3" "$_orig_offset"

                    arg_set _a "$3" || return "$?"

                    # $4 = orig_offset
                    printf "%s" " '-s' '$4' $_a"

                    return 0
                ;;
                *)
                    return 255
                ;;
            esac
        done
    }

    [ "$#" -ge 3 ] || return 255

    # Save the file content into $_str.
    #
    # The current positional parameters become:
    # $1  = orig_offset
    # ... = "$@" (operations)
    _str="$1"; shift; set -- 1 "$@"

    # Store the output of `printf` in $_fmt using command substitution.
    _fmt=$(
        while IFS= read -r _line; do
            fed_ "$_line" "$@" || return "$?"

            # $1 = orig_offset
            _a="$1" && shift 1
            set -- "$((_a + 1))" "$@"
        done \
<<EOF
$_str
EOF

        # Discard orig_offset.
        shift

        # Parse EOF operations.
        while [ "$#" -ge 1 ]; do
            case "$1" in
                '-') : ;;
                '-m' | '-a' | '-r') shift 2 && continue ;;
                '-s') shift 3 && continue ;;
                *) return 255 ;;
            esac

            arg_set _a "$2" || return "$?"

            printf "%s" " '-' $_a"

            shift 2
        done
    ) && \
    _fmt="${_fmt# }" || \
    return "$?"

    [ "$_fmt" ] && return 0 || return 1
}

#! .desc:
# Process each populated IFS field split with a function
#! .params:
# <"$1"> - string
# <$2> - function name
# ["$3"]+ - function argument
#! .uses.var:
# <IFS> $ - environment variable;
#           list of characters that is used for field splitting
#! .sets:
# <set +f>;
#! .rc:
# (0) success
# (*) error
#! .rc.fn:
# ($2) (*) error
#! .desc.ext:
# > "POSIX.1-2024, Volume: Shell & Utilities, Section: Shell Command Language,
#   Subsection: Field Splitting".
# > "POSIX.1-2024, Volume: Shell & Utilities, Section: Shell Command Language,
#   Subsection: set".
# > "POSIX.1-2024, Volume: Shell & Utilities, Section: Shell Command Language,
#   Subsection: Shell Variables".
#.
ifs_map() {
    set -f && _str="$1" && shift && for _field in $_str; do
        [ "$_field" ] || continue

        "$@" "$_field" || { set -- "$?"; set +f; return "$?"; }
    done && set +f
}

#! .desc:
# Modify regular file data in-memory using a deterministic format
#! .params:
# <["$1"]> - log file path
# <["$2"]> - file content
# ["$3"] - operation
# ["$4"]+ - operation argument
#! .uses:
# [&9]
# [()]
# [<<]
# [>>]
# [>]
#! .uses.fn:
# [libfile_n_add] ("natural N" "new string");
#                 For natural N, add line content
# [libfile_n_rem] ("natural N" "line string");
#                 For natural N, remove line string
#! .gives:
# (0) <"$_file"> - [string];
#                  [modified <$2>]
#! .rc:
# (0) success
# (*) error
# (255) bad input / bad usage / error
#! .rc.fn:
# (libfile_n_add) (*) error
# (libfile_n_rem) (*) error
#! .desc.ext:
# The format of operations is as follows (N - natural number):
# `- X`,    means at EOF add "X" data;
# `-a N X`, means at "N" line add "X" data;
# `-r N`,   means remove "N" line;
# `-s N X`, means substitute "N" line with "X" data.
#
# Operations have to be line-sorted (FIFO).
# Multiple operations on the same line are not specified.
# EOF operations are only specified after all line operations.
#
# If a path to a valid file ($1) is given, a diff-style log of any changes
# will be appended to it. If $1 is specified but not a valid file,
# error code `255` (bad usage) will be returned.
#
# If an operation fails to apply, error code `255` (bad usage) will be
# returned.
#
# For more information, refer to:
# > "POSIX.1-2024, Volume: Base Definitions, Section: Definitions,
#   Subsection: File Descriptor".
# > "POSIX.1-2024, Volume: Base Definitions,
#   Section: Directory Structure and Devices,
#   Subsection: Directory Structure and Files".
# > "POSIX.1-2024, Volume: Shell & Utilities, Section: Shell Command Language,
#   Subsection: Appending Redirected Output".
# > "POSIX.1-2024, Volume: Shell & Utilities, Section: Shell Command Language,
#   Subsection: Command Substitution".
# > "POSIX.1-2024, Volume: Shell & Utilities, Section: Shell Command Language,
#   Subsection: Duplicating an Output File Descriptor".
# > "POSIX.1-2024, Volume: Shell & Utilities, Section: Shell Command Language,
#   Subsection: exec".
# > "POSIX.1-2024, Volume: Shell & Utilities, Section: Shell Command Language,
#   Subsection: Here-Document".
# > "POSIX.1-2024, Volume: Shell & Utilities, Section: Shell Command Language,
#   Subsection: Redirecting Output".
# > "POSIX.1-2024, Volume: Shell & Utilities, Section: Shell Command Language,
#   Subsection: Redirection".
#.
libfile() {
    [ "$#" -ge 2 ] || return 255

    _file=

    [ "$2" ] && [ "$#" -ge 3 ] || return 0

    # Assert the log file if specified.
    if [ "$1" ] && [ ! -f "$1" ]; then
        return 255
    fi

    # Open the log file (or /dev/null) using file descriptor `9`. The usage of
    # a file descriptor avoids open/close and related syscall overhead,
    # and also allows us to drop the log file positional parameter.
    exec 9>> "${1:-/dev/null}" || return "$?"

    # Save the file content into $_str.
    #
    # The current positional parameters become:
    # $1  = orig_offset
    # $2  = cur_offset (required for diff/log; tracks current line)
    # $3  = delta_offset (required for diff/log; tracks consecutive difference)
    # ... = "$@" (operations)
    _str="$2"; shift 2; set -- 1 1 0 "$@"

    # Store the output of `printf` in $_file using command substitution.
    # The custom `x` character at the end and its subsequent removal
    # outside the command substitution preserves any trailing <newline>
    # characters stripped by command substitution.
    _file=$(
        # Modify the file content.
        #
        # Our diff algorithm is by definition streaming and FIFO-driven,
        # heavily contrasting with a deferred hunk approach and/or LCS
        # (longest common subsequence; ex. `diff -u`).
        while IFS= read -r _line; do
            # $1 = orig_offset
            # $4 = operation
            # $5 = operation argument (N)
            case "$4 $5" in
                "-a $1")
                    # Preserve $_line as $1.
                    set -- "$_line" "$@"

                    # $1 = $_line
                    # $3 = cur_offset
                    # $7 = operation argument (X)
                    #
                    # Gives $_log, $_offset (cur_offset), and $_str.
                    libfile_n_add "$3" "$7" || return "$?"
                    _offset="$(($3 + 1 + _offset))"
                    _str="$_str$1
"
                    _delta=0
                    _shift=6  # <op params (from $4)> + 3
                    shift

                    # The log ($_log) and the added string ($_str)
                    # always end with a <newline> character.
                    printf "%s" "$_log" >&9
                    printf "%s" "$_str"
                ;;
                "-r $1")
                    # $2 = cur_offset
                    # $3 = delta_offset
                    #
                    # Gives $_log, $_offset (cur_offset), and $_str.
                    #
                    # For multiple consecutive removals, delta_offset is used
                    # in combination with cur_offset; essentially,
                    # any consecutive line removal operations become
                    # offset-aware for as long as the removal operations
                    # span for.
                    libfile_n_rem "$(($2 + $3))" "$_line" || return "$?"
                    _offset="$(($2 + 1 + _offset))"
                    _delta="$(($3 + 1))"
                    _shift=5  # <op params (from $4)> + 3

                    # The log always ends with a <newline> character.
                    printf "%s" "$_log" >&9
                ;;
                "-s $1")
                    # $2 = cur_offset
                    # $3 = delta_offset
                    #
                    # Gives $_log, $_offset (cur_offset), and $_str.
                    #
                    # For multiple consecutive removals, delta_offset is used
                    # in combination with cur_offset; essentially,
                    # any consecutive line removal operations become
                    # offset-aware for as long as the removal operations
                    # span for.
                    libfile_n_rem "$(($2 + $3))" "$_line" || return "$?"

                    # Preserve $_log, $_offset, and $_str as $1, $2, and $3,
                    # respectively.
                    set -- "$_log" "$_offset" "$_str" "$@"

                    # $1 = $_log
                    # $2 = $_offset
                    # $3 = $_str
                    # $5 = cur_offset
                    # $9 = operation argument (X)
                    #
                    # Gives $_log, $_offset (cur_offset), and $_str.
                    # The old values always end with a <newline> character.
                    libfile_n_add "$5" "$9" || return "$?"
                    # Simplify a lookahead (self) replacement.
                    case "$_log" in
                        "${1%%'-'*}+${1#*'-'}"*) _log="${_log#*"${1#*'-'}"}" ;;
                        *) _log="$1$_log" ;;
                    esac
                    _offset="$(($2 + $5 + 1 + _offset))"
                    _str="$3$_str"
                    _delta=0
                    _shift=6  # <op params (from $4)> + 3
                    shift 3

                    # The log ($_log) and the replaced string ($_str)
                    # always end with a <newline> character.
                    printf "%s" "$_log" >&9
                    printf "%s" "$_str"
                ;;
                *)
                    _offset="$(($2 + 1))"; _delta=0; _shift=3

                    printf "%s\n" "$_line"
                ;;
            esac

            # $1 = orig_offset
            _a="$1" && shift "$_shift"
            set -- "$((_a + 1))" "$_offset" "$_delta" "$@"
        done \
<<EOF
$_str
EOF

        # Discard orig_offset and delta_offset, but keep cur_offset.
        shift 3
        set -- "$_offset" "$@"

        # Parse EOF operations.
        while :; do
            # $2 = operation
            case "$2" in
                '-') : ;;
                *) break ;;
            esac

            # $1 = cur_offset
            # $3 = operation argument (X)
            #
            # Gives $_log, $_offset (cur_offset), and $_str.
            libfile_n_add "$1" "$3" || return "$?"
            _offset="$(($1 + _offset))"
            shift 3

            # The log ($_log) and the added string ($_str)
            # always end with a <newline> character.
            printf "%s" "$_log" >&9
            printf "%s" "$_str"

            set -- "$_offset" "$@"
        done

        [ "$#" -eq 1 ] || return 255

        printf "%s" x
    ) && \
    _file="${_file%?}" && \
    _file="${_file%?}"

    set -- "$?"

    # Release file descriptor `9` to close the associated log file.
    if [ "$1" = 0 ]; then
        exec 9>&-; set -- "$?"
    else
        exec 9>&-
    fi

    return "$1"
}

#! .desc:
# For natural N, add line content
#! .params:
# <$1> - natural N
# ["$2"] - new string
#! .uses:
# <<<>
#! .gives:
# (0) <"$_log"> - string;
#                 diff-style log guaranteed to end with <newline>
# (0) <"$_offset"> - integer;
#                    line offset
# (0) <"$_str"> - string;
#                 raw $2 guaranteed to end with <newline>
#! .rc:
# (0) success
# (*) error
#! .desc.ext:
# $2 can be a multiline string.
#
# For more information, refer to:
# > "POSIX.1-2024, Volume: Shell & Utilities, Section: Shell Command Language,
#   Subsection: Here-Document".
#.
libfile_n_add() {
    _log=
    _offset=0

    while IFS= read -r _line; do
        _log="$_log$(($1 + _offset))+ $_line
"
        _offset=$((_offset + 1))
    done \
<<EOF
$2
EOF

    _str="$2
"
}

#! .desc:
# For natural N, remove line string
#! .params:
# <$1> - natural N
# ["$2"] - line string
#! .gives:
# (0) <"$_log"> - string;
#                 diff-style log guaranteed to end with <newline>
#! .sets:
# (0) <_offset> $ - '-1';
# (0) <_str> $ - '';
#! .rc:
# (0) success
# (*) error
# (255) bad input / error
#! .desc.ext:
# $2 cannot be a multiline string and error code `255` (bad input) will be
# returned.
#.
libfile_n_rem() {
    case "$2" in
        *'
'*)
            return 255
        ;;
    esac

    _log="${1}- $2
"
    _offset=-1
    _str=
}

#! .desc:
# Create the parents of a file/directory
#! .params:
# <"$1"> - absolute path
#! .rc:
# (0) success
# (*) error
# (255) bad input
#.
mkdir_parents() {
    assert -eq "$#" 1 || return 255

    if str_sfix '/' "$1"; then
        set -- "${1%?}"
    fi

    if dir "${1%/*}"; then
        return 0
    fi

    # Shall consider implementing 'mkdir -p' within the shell by path
    # traversing the function argument and passing separate consequental
    # arguments to mkdir. Important to note that in such situation, error
    # handling would be on us, including the handling of race conditions.
    mkdir -p "${1%/*}" 2> /dev/null
}

#! .desc:
# Print the return code of a command
#! .params:
# <"$1"> - command
# ["$2"+] - arguments
#! .rc:
# (0) success
# (127) command does not exist
# (255) bad input
#.
rc() {
    assert -min "$#" 1 || return 255

    if cmd "$1"; then
        "$@" > /dev/null 2>&1
        printf "%d" "$?"
    else
        return 127
    fi

    return 0
}

#! .desc:
# Replace a specific character with character(s) in a string using PE
#! .params:
# ["$1"] - specific character
# ["$2"] - character(s)
# ["$3"] - string
#! .uses.fn:
# <assert> ('-max' '${#1}' '1');
#          Assert a string
#! .gives:
# (0) <"$_str"> - [string];
#                 [modified <$3>]
#! .rc:
# (0) success
# (*) error
#! .rc.fn:
# (assert) (255) bad input
#! .desc.ext:
# Multi-byte and multiple characters are not supported and error code `255`
# (bad input) will be returned.
#
# For more information, refer to:
# > "POSIX.1-2024, Volume: Shell & Utilities, Section: Shell Command Language,
#   Subsection: Parameter Expansion".
#.
replchar_posix() {
    assert -max "${#1}" 1 || return 255

    # Traverse $3 (string), replacing the occurrences of $1 with $2.
    _str=; _a="$3"; while [ "$1" ]; do case "$_a" in
        *"$1"*)
            # Example character, replacement character, and string:
            # `a` `A` `ddaabcd`
            # $_b: `dd`
            # $_c: `aabcd`
            # $_d: `aa`
            # $_a: `bcd`
            _b="${_a%%"$1"*}"
            _c="${_a#"$_b"}"
            _d="${_c%%[!"$1"]*}"
            _a="${_a#"$_b$_d"}"

            # ${#_d}: `2`
            # $_chars: `AA`
            _chars=; _i=0; until [ "$_i" = "${#_d}" ]; do
                _chars="$_chars$2"; _i=$((_i + 1))
            done

            # $_str: `ddAA`
            _str="$_str$_b$_chars"
        ;;
        *)
            # $_str: `ddAAbcd`
            _str="$_str$_a"; break
        ;;
    esac done
}

#! .desc:
# Process each populated string line with a function
#! .params:
# <"$1"> - string
# <$2> - function name
# ["$3"]+ - function argument
#! .uses:
# <<<>
#! .rc:
# (0) success
#! .rc.fn:
# ($2) (*) error
#! .desc.ext:
# > "POSIX.1-2024, Volume: Shell & Utilities, Section: Shell Command Language,
#   Subsection: Here-Document".
#.
sline_map() {
    _str="$1"; shift; while IFS= read -r _line; do
        [ "$_line" ] || continue
        "$@" "$_line" || return "$?"
    done \
<<EOF
$_str
EOF

    return 0
}

#! .desc:
# Print POSIX shell-compatible octal escape sequence(s) of `od -b -An` string
#! .params:
# <["$1"]> - string
#! .uses.fn:
# <assert> ('-eq' '$#' '1');
#          Assert a string
#! .rc:
# (0) success
# (*) error
#! .rc.fn:
# (assert) (255) bad input
#.
to_octal() {
    assert -eq "$#" 1 || return 255

    for _octal in $1; do
        printf "%s" "\\0$_octal"
    done
}

#! .desc:
# Print POSIX shell-compatible octal escape sequence(s) of `od -b` string
#! .params:
# <["$1"]> - string
#! .uses:
# <()>
#! .uses.fn:
# <assert> ('-eq' '$#' '1');
#          Assert a string
# <sline_map> ('$1' 'to_octal_offset_');
#             Process each populated string line with a function
# <to_octal> ("string");
#            Print POSIX shell-compatible octal escape sequence(s) of
#            `od -b -An` string
#! .sets:
# <to_octal_offset_> ();
#! .rc.fn:
# (assert) (255) bad input
# (sline_map) (*) error
# (to_octal) (0) success
# (to_octal) (*) error
#.
to_octal_offset() {
    to_octal_offset_() { printf "%s" "${1#"${1%%[!0123456789]*}"}"; }

    assert -eq "$#" 1 || return 255

    to_octal "$(sline_map "$1" to_octal_offset_)"
}

#! .desc:
# Execute 'umount' on a directory
#! .params:
# <"$1"> - directory
#! .rc:
# (0) success
# (255) bad input
#.
unmount() {
    assert -eq "$#" 1 || return 255

    cmd 'umount' && exist "$1" && dir "$1" || return 0

    umount -Rf "$1" > /dev/null 2>&1 || :
}

# END utility_functions
# START std_err_functions

#! .desc:
# EPERM: "Operation not permitted"
#! .rc:
# 1
#.
EPERM() { _err -red -- 'EPERM:'; }

#! .desc:
# ENOENT: "No such file or directory"
#! .rc:
# 2
#.
ENOENT() { _err -red - 'ENOENT:'; }

#! .desc:
# EERROR: "General operation error"
#! .params:
# <"$1"+> - error
#! .rc:
# (1)
# (255) bad input
#.
EERROR() {
    assert -eq "$#" 1 || return 255

    _err -red - "EERROR: $1"; exit 1
}

#! .desc:
# EEXIST: "Already exists"
#! .params:
# <"$1"+> - absolute path
#! .rc:
# (17)
# (255) bad input
#.
EEXIST() {
    assert -min "$#" 1 || return 255

    _err -red - 'EEXIST:'

    while [ "$1" ]; do
        ftype "$1" -err || :
        err - - " $1"

        shift
    done

    exit 17
}

#! .desc:
# ENOTDIR: "Not a directory"
#! .params:
# <"$1"+> - absolute path
#! .rc:
# (20)
# (255) bad input
#.
ENOTDIR() {
    assert -min "$#" 1 || return 255

    _err -red - 'ENOTDIR:'

    while [ "$1" ]; do
        ftype "$1" -err || :
        err - - " $1"

        shift
    done

    exit 20
}

#! .desc:
# EISDIR: "Is a directory"
#! .params:
# <"$1"+> - absolute path
#! .rc:
# (21)
# (255) bad input
#.
EISDIR() {
    assert -min "$#" 1 || return 255

    _err -red - 'EISDIR:'

    while [ "$1" ]; do
        ftype "$1" -err || :
        err - - " $1"

        shift
    done

    exit 21
}

#! .desc:
# EINVAL: "Invalid argument"
#! .rc:
# 22
#.
EINVAL() { _err -red - 'EINVAL:'; }

# END std_err_functions

#! .desc:
# Read STDIN into $FILE
#! .gives:
# (0) <"$FILE"> - the content of STDIN
#! .rc:
# (0) success
# (*) error
#.
FILE() {
    { while IFS= read -r _line; do
        FILE="$FILE$_line
"
    done; FILE="$FILE$_line"; } 2> /dev/null
}

#! .desc:
# Read octal STDIN into $FILE
#! .gives:
# (0) <"$FILE"> - the content of STDIN
#! .rc:
# (0) success
# (*) error
#.
FILE_octal() {
    { while IFS= read -r _line; do
        FILE="$FILE$_line
"
    done; } 2> /dev/null

    case "$FILE" in
        *'
')
            FILE="${FILE%%'
'*}"
        ;;
    esac
}

#! .desc:
# Read a file into $FILE
#! .params:
# <"$1"> - absolute path
#! .gives:
# (0) <"$FILE"> - the content of the file
#! .rc:
# (0) success
# (*) error
# (255) bad input
#.
FILE_preload() {
    assert -eq "$#" 1 || return 255

    file "$1" || return 255
    readable "$1" || return 255

    FILE=$(
        while IFS= read -r _line; do
            printf "%s\n" "$_line"
        done < "$1"; printf "%s" "$_line"

        printf "%s" ' '
    ) 2> /dev/null; FILE="${FILE%?}"
}

#! .desc:
# Read STDIN into $FILE_PATH
#! .gives:
# (0) <"$FILE_PATH"> - the content of STDIN
#! .rc:
# (0) success
# (*) error
#.
FILE_PATH() {
    FILE=; FILE_PATH=; FILE_PATH_TARGET=

    { while IFS= read -r _line; do
        FILE_PATH="$FILE_PATH$_line
"
    done; FILE_PATH="${FILE_PATH%?}$_line"; } 2> /dev/null
}

#! .desc:
# Read STDIN into $FILE_PATH_TARGET
#! .gives:
# (0) <"$FILE_PATH_TARGET"> - the content of STDIN
#! .rc:
# (0) success
# (*) error
#.
FILE_PATH_TARGET() {
    FILE_PATH_TARGET=

    { while IFS= read -r _line; do
        FILE_PATH_TARGET="$FILE_PATH_TARGET$_line
"
    done; FILE_PATH_TARGET="${FILE_PATH_TARGET%?}$_line"; } 2> /dev/null
}

#! .desc:
# Assert a file matches a given string of POSIX shell-compatible octal escape
# sequence(s)
#! .params:
# <"$1"> - file path
# <["$2"]> - string
#! .uses:
# <()>
#! .uses.fn:
# <assert> ('-eq' '$#' '2');
#          Assert a string
# <file> ('$1');
#        Assert a given path is a regular file
# <readable> ('$1');
#            Assert a given path is readable
#! .uses.util:
# <awk> ("program" '$(od -b -An -- "$1")' '$2');
#       pattern scanning and processing language
# <od>;
# dump files in various formats
#! .rc.fn:
# (assert) (255) bad input
# (file) (255) bad usage
# (readable) (255) bad usage
#! .rc.util:
# (awk) (0) true
# (awk) (1) false / error
# (awk) (*) error
# (od) (*) error
#! .desc.ext:
# Broken symbolic links are not valid files and error code `255` (bad usage)
# will be returned.
#.
bin_equiv() {
    assert -eq "$#" 2 || return 255
    { file "$1" && readable "$1"; } || return 255

    awk '
function mod_string(input) {
	result = ""

	gsub(/[ \n]+/, "", input)
	for (i = 1; i <= length(input); i += 3) {
		octal = substr(input, i, 3)
		result = result "\\0" octal
	}

	return result
}

BEGIN {
	file_string=ARGV[1]
	string=ARGV[2]
	delete ARGV

	exit (mod_string(file_string) == string) ? 0 : 1;
}
    ' "$(od -b -An -- "$1")" "$2"
}

#! .desc:
# Copy a given directory at a path
#! .params:
# <"$1"> - absolute path of the directory
# <"$2"> - absolute path to copy the directory at
#! .rc:
# (0) success
# (*) error
# (255) bad input
#.
dir_write() {
    assert -eq "$#" 2 || return 255

    dir "$1" || return 255

    if exist "$2"; then
        chattr_remove "$2"
        unmount "$2"

        rm -rf "$2" 2> /dev/null
    fi

    mkdir_parents "$2"

    cp -R "$1" "$2" 2> /dev/null
}

#! .desc:
# Copy a given file at a path
#! .params:
# <"$1"> - absolute path of the file
# <"$2"> - absolute path to copy the file at
#! .rc:
# (0) success
# (*) error
# (255) bad input
#.
file_copy() {
    assert -eq "$#" 2 || return 255

    file "$1" || return 255

    if exist "$2"; then
        chattr_remove "$2"
        unmount "$2"

        rm -rf "$2" 2> /dev/null
    fi

    mkdir_parents "$2"

    cp "$1" "$2" 2> /dev/null
}

#! .desc:
# Check if a file matches a given string
#! .params:
# <"$1"> - absolute path
# <"$2"> - string
#! .rc:
# (0) yes
# (1) no
# (*) error
# (255) bad input
#.
file_equiv() {
    assert -eq "$#" 2 || return 255

    file "$1" || return 255

    {
        _file= && while IFS= read -r _line; do
            _file="$_file$_line
"
        done < "$1"; _file="$_file$_line"
    } 2> /dev/null

    [ "$_file" = "$2" ]
}

#! .desc:
# Write a given string at a path
#! .params:
# <"$1"> - absolute path
# <"$2"> - string
#! .rc:
# (0) success
# (*) error
# (255) bad input
#.
file_write() {
    assert -eq "$#" 2 || return 255

    if exist "$1"; then
        chattr_remove "$1"
        unmount "$1"

        rm -rf "$1" 2> /dev/null
    fi

    mkdir_parents "$1"

    { printf "%s" "$2" > "$1"; } 2> /dev/null
}

#! .desc:
# Forcefully write a given string at a path
#! .params:
# <"$1"> - absolute path
# <"$2"> - string
#! .rc:
# (0) success
# (*) error
# (255) bad input
#.
file_writeF() {
    assert -eq "$#" 2 || return 255

    if exist "$1"; then
        chattr_remove "$1" 2> /dev/null || :
        unmount "$1" 2> /dev/null || :

        rm -rf "$1" 2> /dev/null || :
    fi

    mkdir_parents "$1"

    { printf "%s" "$2" > "$1"; } 2> /dev/null
}

#! .desc:
# Write a given octal sequence at a path
#! .params:
# <"$1"> - absolute path
# <"$2"> - octal sequence
#! .rc:
# (0) success
# (*) error
# (255) bad input
#.
file_write_octal() {
    assert -eq "$#" 2 || return 255

    if exist "$1"; then
        chattr_remove "$1"
        unmount "$1"

        rm -rf "$1" 2> /dev/null
    fi

    mkdir_parents "$1"
    { printf "%b" "$2" > "$1"; } || { rm -f "$1"; return 1; }
}

#! .desc:
# Check if a file matches a given file
#! .params:
# <"$1"> - absolute path
# <"$2"> - absolute path
#! .rc:
# (0) yes
# (1) no
# (*) error
# (255) bad input
#.
files_equiv() {
    assert -eq "$#" 2 || return 255

    file "$1" || return 255
    file "$2" || return 255
    readable "$1" || return 255
    readable "$2" || return 255

    cmp -s "$1" "$2" 2> /dev/null
}

#! .desc:
# Permanently delete a file/directory
#! .params:
# <"$1"> - absolute path
#! .rc:
# (0) success
# (*) error
# (255) bad $1
#.
loc_delete() {
    assert -eq "$#" 1 || return 255

    exist "$1" || return 0

    chattr_remove "$1"
    unmount "$1"

    rm -rf "$1" 2> /dev/null
}

#! .desc:
# Create a symbolic link of an object
#! .params:
# <"$1"> - absolute path of the object
# <"$2"> - absolute path to create the link at
#! .rc:
# (0) success
# (*) error
# (255) bad input
#.
loc_link() {
    assert -eq "$#" 2 || return 255

    { [ -e "$1" ] || [ -h "$1" ]; } || return 255

    if exist "$2"; then
        chattr_remove "$2"
        unmount "$2"
    fi

    mkdir_parents "$2"

    ln -sf "$1" "$2" 2> /dev/null
}

#! .desc:
# Create a hard link of a file
#! .params:
# <"$1"> - absolute path of the file
# <"$2"> - absolute path to create the link at
#! .rc:
# (0) success
# (*) error
# (255) bad input
#.
loc_link_ptr() {
    assert -eq "$#" 2 || return 255

    if file "$1"; then
        :
    else
        return 255
    fi

    if exist "$2"; then
        chattr_remove "$2"
        unmount "$2"
    fi

    mkdir_parents "$2"

    ln -f "$1" "$2" 2> /dev/null
}

#! .desc:
# Set $user as owner of an object and its parents in $home
#! .params:
# <"$1"> - absolute path
#! .uses:
# [gid] $ - the numerical user primary group ID
# [home] $ - the user directory
# [uid] $ - the numerical user ID
#! .rc:
# (0) success
# (*) error
# (255) bad input
#.
loc_own_user() {
    assert -eq "$#" 1 || return 255

    set -- "${1%"${1##*[!/]}"}"

    exist "$1" && str_pfix "$home"/ "$1" || return 0

    chattr_remove "$1"

    if dir "$1"; then
        chown -RP -- "$uid":"$gid" "$1"
    else
        chown -P -- "$uid":"$gid" "$1"
    fi

    set -- "${1%/*}"
    set -- "${1%"${1##*[!/]}"}"
    until [ "$1" = "$home" ]; do
        chown -P -- "$uid":"$gid" "$1"

        set -- "${1%/*}"
        set -- "${1%"${1##*[!/]}"}"
    done
}

#! .desc:
# Write a binary file at the specified path
#! .uses:
# <FILE> $ - the octal sequence of the file
# <FILE_PATH> $ - the path to write the file at
#! .rc:
# (0) success
# (*) error
# (255) bad usage
#.
__bin_write() {
    if [ ! "$FILE_PATH" ]; then
        _err -red - 'Missing FILE_PATH.'
        return 255
    fi

    if [ ! "$FILE" ]; then
        _info -white - 'Empty FILE. File write cancelled:'
        ftype "$FILE_PATH" -info || :
        info - - " $FILE_PATH"
        return 0
    fi

    if ! is_octal "$FILE"; then
        _err -red - 'Bad FILE; expected octal.'
        return 255
    fi

    while :; do
        if [ "$always_write" = 0 ]; then
            if bin_equiv "$FILE_PATH" "$FILE"; then
                _info -white - 'File write avoided:'
                ftype "$FILE_PATH" -info || :
                info - - " $FILE_PATH"
                break
            fi
        fi

        if [ "$force_write" = 1 ]; then
            loc_delete "$FILE_PATH"
        fi

        if exist "$FILE_PATH"; then
            EEXIST "$FILE_PATH"
        fi

        _info -white - 'Will write a file:'
        ftype "$FILE_PATH" -info || :
        info - - " $FILE_PATH"

        (
            IFS='\''
'
            CC=0; for _octal in $FILE; do CC=$((CC + 1)); done
            info -white -- 'CC: '; info - - "$CC"
            info -white -- 'SIZE: '; bytes_size "$CC"
        )

        if ! file_write_octal "$FILE_PATH" "$FILE"; then
            _err -red - 'File write error:'
            ftype "$FILE_PATH" -err || :
            err - - " $FILE_PATH"
            exit 1
        fi
    break; done

    if ! loc_own_user "$FILE_PATH"; then
        EERROR 'Failed to set user permissions.'
    fi
}

#! .desc:
# Write a binary file at the specified path (overwrite path)
#.
__bin_write_overwrite() {
    __loc_delete && __bin_write;
}

#! .desc:
# Run a command
#! .params:
# <"$1"> - command
# <"$2">+ -  arguments
#! .rc:
# (0) success
# (*) error
# (255) bad usage
#.
__cmd() {
    cmd "$1" || {
        _err -red - 'Missing command:'

        err -white -- '`'
        err - -- "$1"
        err -white - '`'

        exit 127
    }

    _info -white - 'Running command:'

    info -white -- '`'
    info - -- "$@"
    info -white - '`'

    if [ "$silent_cmd" = 1 ]; then
        command "$@" > /dev/null || return "$?"
    else
        command "$@" || return "$?"
    fi
}

#! .desc:
# Run a command and store output in $FILE
#! .params:
# <"$1"> - command
# <"$2">+ -  arguments
#! .rc:
# (0) success
# (*) error
# (255) bad usage
#.
__FILE_cmd() {
    cmd "$1" || {
        _err -red - 'Missing command:'

        err -white -- '`'
        err - -- "$1"
        err -white - '`'

        exit 127
    }

    _info -white - 'Running command:'

    info -white -- '`'
    info - -- "$@"
    info -white - '`'

    FILE=$(command "$@")
}

#! .desc:
# Copy a directory at the specified path
#! .uses:
# <FILE_PATH> $ - the directory
# <FILE_PATH_TARGET> $ - the path to write the directory at
#! .rc:
# (0) success
# (*) error
# (255) bad usage
#.
__dir_target_write() {
    if [ ! "$FILE_PATH" ]; then
        _err -red - 'Missing FILE_PATH.'
        return 255
    fi

    if [ ! "$FILE_PATH_TARGET" ]; then
        _err -red - 'Missing FILE_PATH_TARGET.'
        return 255
    fi

    if ! exist "$FILE_PATH"; then
        ENOENT;
        ftype "$FILE_PATH" -err || :
        err - - " $FILE_PATH"
        exit 2
    fi

    dir "$FILE_PATH" && readable "$FILE_PATH" || {
        EINVAL;
        ftype "$FILE_PATH" -err || :
        err - - " $FILE_PATH"
        exit 22
    }

    while :; do
        if [ "$force_write" = 1 ]; then
            loc_delete "$FILE_PATH_TARGET"
        fi

        if exist "$FILE_PATH_TARGET"; then
            EEXIST "$FILE_PATH_TARGET"
        fi

        _info -white - 'Will copy from/to:'
        ftype "$FILE_PATH" -info || :
        info - - " $FILE_PATH"
        ftype "$FILE_PATH_TARGET" -info || :
        info - - " $FILE_PATH_TARGET"

        info -white -- '> '
        find "$FILE_PATH"//. ! -name . | grep -c // 2> /dev/null | \
            while IFS= read -r _line0; do
                printf "%s, " "$_line0"

                info -white -- 'D '
                find "$FILE_PATH"//. ! -name . -type d | \
                    grep -c // 2> /dev/null | \
                        while IFS= read -r _line1; do
                            printf "%s, " "$_line1"

                            info -white -- 'F '
                            info - - "$((_line0 - _line1))"
                        done
            done

        if ! dir_write "$FILE_PATH" "$FILE_PATH_TARGET"; then
            _err -red - 'Directory write error:'
            ftype "$FILE_PATH_TARGET" -err || :
            err - - " $FILE_PATH_TARGET"
            exit 1
        fi
    break; done

    if ! loc_own_user "$FILE_PATH_TARGET"; then
        EERROR 'Failed to set user permissions.'
    fi
}

#! .desc:
# Copy a directory at the specified path (overwrite path)
#.
__dir_target_write_overwrite() {
    __loc_delete && __dir_target_write;
}

#! .desc:
# Preload FILE_PATH into FILE
#! .uses:
# <FILE> $
# <FILE_PATH> $ - the file to preload
#! .rc:
# (0) success
# (*) error
# (255) bad usage
#.
__FILE_PATH_preload() {
    if [ ! "$FILE_PATH" ]; then
        _err -red - 'Missing FILE_PATH.'
        return 255
    fi

    if ! exist "$FILE_PATH"; then
        ENOENT;
        ftype "$FILE_PATH" -err || :
        err - - " $FILE_PATH"
        exit 2
    fi

    FILE_preload "$FILE_PATH" || {
        _err -red - 'Error reading file:'
        ftype "$FILE_PATH" -err || :
        err - - " $FILE_PATH"
        exit 1
    }
}

#! .desc:
# Modify file data in-place according to format (see fed())
#! .params:
# <[$1]> - crc32 string to verify produced format against
# <["$2"]> - log file path
# <$3>+ - operation(
#     '-' - EOF add $4
#     '-m' - apply modifier for `-a`/`-r`/`-s`; see extended description
#     '-a' - add $4
#     '-r' - remove $4
#     '-s' - substitute $4 with $5
#     .
# )
# ["$4"] - string
# ["$5"] - string
#.
__fed() {
    assert -min "$#" 3 || return 255

    [ "$FILE" ] || __FILE_PATH_preload || exit "$?"

    set -- "$FILE" "$@"

    _fmt=$(
        _a="$1"; shift 3

        fed "$_a" "$@" || {
            set -- "$?"; case "$1" in
                1) [ ! "$_fmt" ] || return "$1" ;;
                *) return "$1" ;;
            esac
        }

        printf "%s" "$_fmt"
    ) || exit "$?"

    [ "$_fmt" ] || return 0

    set -- "$_fmt" "$@"

    _cksum=$(printf "%s" "$1" | cksum) && \
    _cksum="${_cksum%%' '*}" || exit "$?"

    if [ "$3" ] && [ "$3" != "$_cksum" ]; then
        _info -yellow - "CRC32 mismatch. (exp. $3; got $_cksum)"
        _info -white - 'Format:'
        info - - "$1"

        if [ "$confirm_crc" = 1 ]; then
            _info -white - 'Auto accepted the mismatch.'
        elif [ "$interactive" = 1 ]; then
            confirm_cont || return 0
        else
            return 0
        fi
    fi

    FILE=$(
        _a="$2"; _b="$4"; eval set -- "$1"

        libfile "$_b" "$_a" "$@" || return "$?"

        printf "%s" "${_file}x"
    ) && FILE="${FILE%?}" || exit "$?"
}

#! .desc:
# Set the executable bits on a file
#! .uses:
# <FILE_PATH> $ - the file
#! .rc:
# (0) success
# (*) error
# (255) bad usage
#.
__file_executable() {
    if [ ! "$FILE_PATH" ]; then
        _err -red - 'Missing FILE_PATH.'
        return 255
    fi

    if ! exist "$FILE_PATH"; then
        ENOENT;
        ftype "$FILE_PATH" -err || :
        err - - " $FILE_PATH"
        exit 2
    fi

    file "$FILE_PATH" || {
        EINVAL;
        ftype "$FILE_PATH" -err || :
        err - - " $FILE_PATH"
        exit 22
    }

    __cmd chmod +x "$FILE_PATH"
}

#! .desc:
# Write a file at the specified path
#! .uses:
# <FILE> $ - the file
# <FILE_PATH> $ - the path to write the file at
#! .rc:
# (0) success
# (*) error
# (255) bad usage
#.
__file_write() {
    if [ ! "$FILE_PATH" ]; then
        _err -red - 'Missing FILE_PATH.'
        return 255
    fi

    if [ ! "$FILE" ]; then
        _info -white - 'Empty FILE. File write cancelled:'
        ftype "$FILE_PATH" -info || :
        info - - " $FILE_PATH"
        return 0
    fi

    while :; do
        if [ "$always_write" = 0 ]; then
            if file_equiv "$FILE_PATH" "$FILE"; then
                _info -white - 'File write avoided:'
                ftype "$FILE_PATH" -info || :
                info - - " $FILE_PATH"
                break
            fi
        fi

        if [ "$force_write" = 1 ]; then
            loc_delete "$FILE_PATH"
        fi

        if exist "$FILE_PATH"; then
            EEXIST "$FILE_PATH"
        fi

        if [ -s "$logf" ]; then  # log written
            _info -white - 'Will write original file; diff:'
            ftype "$FILE_PATH" -info || :
            info - - " $FILE_PATH"
            while IFS=" " read -r _n _line; do
                case "$_n" in
                    *'+') printf "%b%s%b " '\033[1;32m' "$_n" '\033[0m' ;;
                    *'-') printf "%b%s%b " '\033[1;31m' "$_n" '\033[0m' ;;
                esac; printf "%s\n" "$_line"
            done < "$logf"
        else
            _info -white - 'Will write a file:'
            ftype "$FILE_PATH" -info || :
            info - - " $FILE_PATH"
            if [ "$silent_write" = 0 ]; then
                info -white - '0:'; info - - "${FILE%'
'}"
            fi
        fi

        if ! file_write "$FILE_PATH" "$FILE"; then
            _err -red - 'File write error:'
            ftype "$FILE_PATH" -err || :
            err - - " $FILE_PATH"
            exit 1
        fi
    break; done

    if ! loc_own_user "$FILE_PATH"; then
        EERROR 'Failed to set user permissions.'
    fi

    if ! { : > "$logf"; }; then
        _err -r - 'Log clear error.'
        exit 1
    fi
}

#! .desc:
# Write a file at the specified path (overwrite path)
#.
__file_write_overwrite() {
    __loc_delete && __file_write;
}

#! .desc:
# Overwrite a file at the specified path
#! .uses:
# <FILE> $ - the file
# <FILE_PATH> $ - the path to write the file at
#! .rc:
# (0) success
# (*) error
# (255) bad usage
#.
__file_write_overwrite_soft() {
    if [ ! "$FILE_PATH" ]; then
        _err -red - 'Missing FILE_PATH.'
        return 255
    fi

    if [ ! "$FILE" ]; then
        _info -white - 'Empty FILE. File write cancelled:'
        ftype "$FILE_PATH" -info || :
        info - - " $FILE_PATH"
        return 0
    fi

    while :; do
        if [ "$always_write" = 0 ]; then
            if file_equiv "$FILE_PATH" "$FILE"; then
                _info -white - 'File write avoided:'
                ftype "$FILE_PATH" -info || :
                info - - " $FILE_PATH"
                break
            fi
        fi

        if [ -s "$logf" ]; then  # log written
            _info -white - 'Will write original file; diff:'
            ftype "$FILE_PATH" -info || :
            info - - " $FILE_PATH"
            while IFS=" " read -r _n _line; do
                case "$_n" in
                    *'+') printf "%b%s%b " '\033[1;32m' "$_n" '\033[0m' ;;
                    *'-') printf "%b%s%b " '\033[1;31m' "$_n" '\033[0m' ;;
                esac; printf "%s\n" "$_line"
            done < "$logf"
        else
            _info -white - 'Will overwrite a file:'
            ftype "$FILE_PATH" -info || :
            info - - " $FILE_PATH"
            if [ "$silent_write" = 0 ]; then
                info -white - '0:'; info - - "${FILE%'
'}"
            fi
        fi

        if ! file_writeF "$FILE_PATH" "$FILE"; then
            _err -red - 'File overwrite error:'
            ftype "$FILE_PATH" -err || :
            err - - " $FILE_PATH"
            exit 1
        fi
    break; done

    if ! loc_own_user "$FILE_PATH"; then
        EERROR 'Failed to set user permissions.'
    fi

    if ! { : > "$logf"; }; then
        _err -r - 'Log clear error.'
        exit 1
    fi
}

#! .desc:
# Copy a file at the specified path
#! .uses:
# <FILE_PATH> $ - the directory
# <FILE_PATH_TARGET> $ - the path to write the directory at
#! .rc:
# (0) success
# (*) error
# (255) bad usage
#.
__file_target_write() {
    if [ ! "$FILE_PATH" ]; then
        _err -red - 'Missing FILE_PATH.'
        return 255
    fi

    if [ ! "$FILE_PATH_TARGET" ]; then
        _err -red - 'Missing FILE_PATH_TARGET.'
        return 255
    fi

    if ! exist "$FILE_PATH"; then
        ENOENT;
        ftype "$FILE_PATH" -err || :
        err - - " $FILE_PATH"
        exit 2
    fi

    file "$FILE_PATH" && readable "$FILE_PATH" || {
        EINVAL;
        ftype "$FILE_PATH" -err || :
        err - - " $FILE_PATH"
        exit 22
    }

    while :; do
        if [ "$always_write" = 0 ]; then
            if files_equiv "$FILE_PATH" "$FILE_PATH_TARGET"; then
                _info -white - 'File write avoided:'
                ftype "$FILE_PATH_TARGET" -info || :
                info - - " $FILE_PATH_TARGET"
                break
            fi
        fi

        if [ "$force_write" = 1 ]; then
            loc_delete "$FILE_PATH_TARGET"
        fi

        if exist "$FILE_PATH_TARGET"; then
            EEXIST "$FILE_PATH_TARGET"
        fi

        _info -white - 'Will copy from/to:'
        ftype "$FILE_PATH" -info || :
        info - - " $FILE_PATH"
        ftype "$FILE_PATH_TARGET" -info || :
        info - - " $FILE_PATH_TARGET"

        if ! file_copy "$FILE_PATH" "$FILE_PATH_TARGET"; then
            _err -red - 'File write error:'
            ftype "$FILE_PATH_TARGET" -err || :
            err - - " $FILE_PATH_TARGET"
            exit 1
        fi
    break; done

    if ! loc_own_user "$FILE_PATH_TARGET"; then
        EERROR 'Failed to set user permissions.'
    fi
}

#! .desc:
# Copy a file at the specified path (overwrite path)
#.
__file_target_write_overwrite() {
    __loc_delete && __file_target_write;
}

#! .desc:
# Set filesystem flags on a file/directory
#! .params:
# <$1> - flag(s) to set
#! .uses:
# <FILE_PATH> $ - the file/directory
#! .rc:
# (0) success
# (*) error
# (255) bad input/usage
#.
__loc_chattr() {
    assert -eq "$#" 1 || return 255

    cmd 'chattr' || return 0

    if [ ! "$FILE_PATH" ]; then
        _err -red - 'Missing FILE_PATH.'
        return 255
    fi

    if ! exist "$FILE_PATH"; then
        ENOENT;
        ftype "$FILE_PATH" -err || :
        err - - " $FILE_PATH"
        exit 2
    fi

    if dir "$FILE_PATH"; then
        :
    elif file "$FILE_PATH"; then
        :
    else
        EINVAL;
        ftype "$FILE_PATH" -err || :
        err - - " $FILE_PATH"
        exit 22
    fi

    __cmd chattr +"$1" "$FILE_PATH"
}

#! .desc:
# Set permissions on a file/directory
#! .params:
# <$1> - octal mode
#! .uses:
# <FILE_PATH> $ - the file/directory
#! .rc:
# (0) success
# (*) error
# (255) bad input/usage
#.
__loc_chmod() {
    assert -eq "$#" 1 || return 255

    if [ ! "$FILE_PATH" ]; then
        _err -red - 'Missing FILE_PATH.'
        return 255
    fi

    if ! exist "$FILE_PATH"; then
        ENOENT;
        ftype "$FILE_PATH" -err || :
        err - - " $FILE_PATH"
        exit 2
    fi

    if dir "$FILE_PATH"; then
        :
    elif file "$FILE_PATH"; then
        :
    else
        EINVAL;
        ftype "$FILE_PATH" -err || :
        err - - " $FILE_PATH"
        exit 22
    fi

    chattr_remove "$FILE_PATH"

    __cmd chmod "$1" "$FILE_PATH"
}

#! .desc:
# Set owner of a file/directory
#! .params:
# <$1> - owner
#! .uses:
# <FILE_PATH> $ - the file/directory
#! .rc:
# (0) success
# (*) error
# (255) bad input/usage
#.
__loc_chown() {
    assert -eq "$#" 1 || return 255

    if [ ! "$FILE_PATH" ]; then
        _err -red - 'Missing FILE_PATH.'
        return 255
    fi

    if ! exist "$FILE_PATH"; then
        ENOENT;
        ftype "$FILE_PATH" -err || :
        err - - " $FILE_PATH"
        exit 2
    fi

    if dir "$FILE_PATH"; then
        :
    elif file "$FILE_PATH"; then
        :
    else
        EINVAL;
        ftype "$FILE_PATH" -err || :
        err - - " $FILE_PATH"
        exit 22
    fi

    chattr_remove "$FILE_PATH"

    __cmd chown -R "$uid":"$gid" "$FILE_PATH"
}

#! .desc:
# Delete a file/directory from the specified path
#! .uses:
# <FILE_PATH> $ - the file/directory
#! .rc:
# (0) success
# (*) error
# (255) bad usage
#.
__loc_delete() {
    if [ ! "$FILE_PATH" ]; then
        _err -red - 'Missing FILE_PATH.'
        return 255
    fi

    if ! exist "$FILE_PATH"; then
        _info -white - 'Already deleted:'
        ftype "$FILE_PATH" -info || :
        info - - " $FILE_PATH"
        return 0
    fi

    _info -white - 'Will delete:'
    ftype "$FILE_PATH" -info || :
    info - - " $FILE_PATH"

    if ! loc_delete "$FILE_PATH"; then
        _err -red - 'Removal error:'
        ftype "$FILE_PATH" -err || :
        err - - " $FILE_PATH"
        exit 1
    fi
}

#! .desc:
# Truncate/empty a file/directory on the specified path
#! .uses:
# <FILE_PATH> $ - the file/directory
#! .rc:
# (0) success
# (*) error
# (255) bad usage
#.
__loc_empty() {
    if [ ! "$FILE_PATH" ]; then
        _err -red - 'Missing FILE_PATH.'
        return 255
    fi

    if dir "$FILE_PATH"; then
        :
    elif file "$FILE_PATH"; then
        :
    elif exist "$FILE_PATH"; then
        EINVAL;
        ftype "$FILE_PATH" -err || :
        err - - " $FILE_PATH"
        exit 22
    fi

    if dir "$FILE_PATH"; then
        _info -white - 'Will empty:'
        ftype "$FILE_PATH" -info || :
        info - - " $FILE_PATH"

        __cmd rm -rf "$FILE_PATH"/*
    else
        if exist "$FILE_PATH"; then
            _info -white - 'Will truncate:'
        else
            _info -white - 'Will create a file:'
        fi
        ftype "$FILE_PATH" -info || :
        info - - " $FILE_PATH"

        if ! { : > "$FILE_PATH"; }; then
            if exist "$FILE_PATH"; then
                _err -red - 'Truncation error:'
            else
                _err -red - 'File creation error:'
            fi
            ftype "$FILE_PATH" -err || :
            err - - " $FILE_PATH"
            exit 1
        fi
    fi
}

#! .desc:
# Create a symbolic link of an object at the specified path (overwrite)
#! .uses:
# <FILE_PATH> $ - the object
# <FILE_PATH_TARGET> $ - the path to write the symbolic link at
#! .rc:
# (0) success
# (*) error
# (255) bad usage
#.
__loc_target_link_overwrite() {
    if [ ! "$FILE_PATH" ]; then
        _err -red - 'Missing FILE_PATH.'
        return 255
    fi

    if [ ! "$FILE_PATH_TARGET" ]; then
        _err -red - 'Missing FILE_PATH_TARGET.'
        return 255
    fi

    if ! { exist "$FILE_PATH" || [ -h "$FILE_PATH" ]; }; then
        ENOENT;
        ftype "$FILE_PATH" -err || :
        err - - " $FILE_PATH"
        exit 2
    fi

    while :; do
        _info -white - 'Will symbolic link source/target:'
        ftype "$FILE_PATH" -info || :
        info - - " $FILE_PATH"
        ftype "$FILE_PATH_TARGET" -info || :
        info - - " $FILE_PATH_TARGET"

        if ! loc_link "$FILE_PATH" "$FILE_PATH_TARGET"; then
            _err -red - 'Symbolic linking error:'
            ftype "$FILE_PATH_TARGET" -err || :
            err - - " $FILE_PATH_TARGET"
            exit 1
        fi
    break; done

    if ! loc_own_user "$FILE_PATH_TARGET"; then
        EERROR 'Failed to set user permissions.'
    fi
}

#! .desc:
# Copy/clone a git repository to $tmpd
#! .params:
# <["$1"]> - directory path
# ["$2"]+ - URL
#! .rc:
# (0) success
# (*) error
# (255) bad input
#.
__git_get() {
    assert -min "$#" 1 || return 255

    while [ "$1" ]; do
        dir "$1" && exist "$1"/.git || break

        dir_write "$1" "$tmpd/." || return "$?"

        return 0
    done

    shift

    set -- "$@" '--depth' '1'

    if str '/' "$1"; then
        set -- "$@" "$tmpd/${1#"${1%/*}"?}"
    else
        set -- "$@" "$tmpd/$1"
    fi

    __cmd git clone "$@"
}

# $m533ia assertion:
#
# Use laptop's sound card ALC256 instead of HDMI by default
# Fixes: no sound in some applications/games.
#
# [m533ia]$ aplay -l:
# card 0: Generic [HD-Audio Generic], device 3: HDMI 0 [HDMI 0]
#   Subdevices: 1/1
#   Subdevice #0: subdevice #0
# card 1: Generic_1 [HD-Audio Generic], device 0: ALC256 Analog [ALC256 Analog]
#   Subdevices: 1/1
#   Subdevice #0: subdevice #0
_alsa_conf() {
    FILE_PATH \
<<'ASOUND_CONF'
/etc/asound.conf
ASOUND_CONF

    if [ "$audio_hq_resamp" = 1 ]; then
        FILE \
<<'ASOUND_CONF'
defaults.pcm.rate_converter "speexrate_best"
ASOUND_CONF
    else
        FILE \
<<'ASOUND_CONF'
defaults.pcm.rate_converter "speexrate_medium"
ASOUND_CONF
    fi

    if [ "$m533ia" = 1 ]; then
        FILE \
<<'ASOUND_CONF'
defaults.pcm.card 1
defaults.ctl.card 1
ASOUND_CONF
    fi

    __file_write;
}

# "WantedBy", default.target, ensures systemd will try to start the service on
# boot. Since no other services on the system specifies our, moc.service, we
# essentially tell systemd that default.target "wants us" using WantedBy;
# default.target is equal to runlevel 5 in sysvinit if it is an alias for
# graphical.target, otherwise 3-5 if multi-user.target.
# Symlink is created because the service will not be started if there isn't a
# symlink under a directory with name composed of the WantedBy string +
# '.wants' appended.
#
# Without a symbolic link, the service will be ready to start, but
# it will not be started automatically unless manually started or something
# specifies its start.
#
# Sources:
# https://unix.stackexchange.com/a/506374/431300
#
# Hard dependency mark in systemd:
# Requires=<service>
#
# Hard dependency mark + runtime mark in systemd:
# Requires=<service>
# After=<service>
#
# Soft dependency mark in systemd:
# Wants=<service>
#
# Soft dependency mark + runtime mark in systemd:
# Wants=<service>
# After=<service>
#
# In respect to dependencies, `WantedBy=` string will still be respected
# in all cases.
#
# An alternative to systemd shall be considered.
_autostart() {
    if [ "$init" = systemd ]; then
        if [ "$bluetooth" = 1 ]; then
            FILE_PATH \
<<'BLUETOOTH_SERVICE'
/etc/systemd/system/bluetooth.service
BLUETOOTH_SERVICE

            FILE \
<<'BLUETOOTH_SERVICE'
[Unit]
Description=Bluetooth service
Requires=dbus.service
After=dbus.service

[Service]
Type=dbus
BusName=org.bluez
ExecStart=/usr/lib/bluetooth/bluetoothd
TimeoutStopSec=3

[Install]
WantedBy=multi-user.target
BLUETOOTH_SERVICE

            __file_write;

            FILE_PATH \
<<'BLUETOOTH_SERVICE'
/etc/systemd/system/bluetooth.service
BLUETOOTH_SERVICE

            FILE_PATH_TARGET \
<<'BLUETOOTH_SERVICE'
/etc/systemd/system/multi-user.target.wants/bluetooth.service
BLUETOOTH_SERVICE

            __loc_target_link_overwrite;
        else
            FILE_PATH \
<<'BLUETOOTH_SERVICE'
/etc/systemd/system/bluetooth.service
BLUETOOTH_SERVICE

            __loc_delete;

            FILE_PATH \
<<'BLUETOOTH_SERVICE'
/etc/systemd/system/multi-user.target.wants/bluetooth.service
BLUETOOTH_SERVICE

            __loc_delete;
        fi

        if [ "$dns" = localhost ]; then
            if [ "$dns0" = dnsmasq ]; then
                FILE_PATH \
<<'DNSMASQ_SERVICE'
/etc/systemd/system/dnsmasq.service
DNSMASQ_SERVICE

                FILE \
<<'DNSMASQ_SERVICE'
[Unit]
Description=Caching DNS server
Wants=dbus.service

[Service]
Type=simple
ExecStart=/usr/bin/dnsmasq -k --user=dnsmasq
TimeoutStopSec=3

[Install]
WantedBy=multi-user.target
DNSMASQ_SERVICE

                __file_write;

                FILE_PATH \
<<'DNSMASQ_SERVICE'
/etc/systemd/system/dnsmasq.service
DNSMASQ_SERVICE

                FILE_PATH_TARGET \
<<'DNSMASQ_SERVICE'
/etc/systemd/system/multi-user.target.wants/dnsmasq.service
DNSMASQ_SERVICE

                __loc_target_link_overwrite;
            elif [ "$dns0" = none ] || [ ! "$dns0" ]; then
                FILE_PATH \
<<'DNSMASQ_SERVICE'
/etc/systemd/system/dnsmasq.service
DNSMASQ_SERVICE

                __loc_delete;

                FILE_PATH \
<<'DNSMASQ_SERVICE'
/etc/systemd/system/multi-user.target.wants/dnsmasq.service
DNSMASQ_SERVICE

                __loc_delete;
            fi
        elif [ "$dns" = none ] || [ ! "$dns" ]; then
            FILE_PATH \
<<'DNSMASQ_SERVICE'
/etc/systemd/system/dnsmasq.service
DNSMASQ_SERVICE

            __loc_delete;

            FILE_PATH \
<<'DNSMASQ_SERVICE'
/etc/systemd/system/multi-user.target.wants/dnsmasq.service
DNSMASQ_SERVICE

            __loc_delete;
        fi

        if [ "$m533ia" = 1 ]; then
            FILE_PATH \
<<'EVTEST_GRAB_SERVICE'
/etc/systemd/system/evtest-grab.service
EVTEST_GRAB_SERVICE

            FILE \
<<'EVTEST_GRAB_SERVICE'
[Unit]
Description=Grab m533ia keyboard at startup

[Service]
Type=simple
ExecStart=/bin/bash -c '\
device="$(/usr/bin/awk '\''\
/AT Translated Set 2 keyboard/ { found=1; next } \
found && /Handlers=/ { \
  for (i=1; i<=NF; i++) \
    if ($i ~ /^event[0-9]+$/) { \
      print "/dev/input/" $i; exit \
    } \
}'\'' /proc/bus/input/devices)"; \
exec /usr/bin/evtest --grab "$device"'
User=root
StandardOutput=null

[Install]
WantedBy=multi-user.target
EVTEST_GRAB_SERVICE

            __file_write;

            FILE_PATH \
<<'EVTEST_GRAB_SERVICE'
/etc/systemd/system/evtest-grab.service
EVTEST_GRAB_SERVICE

            FILE_PATH_TARGET \
<<'EVTEST_GRAB_SERVICE'
/etc/systemd/system/multi-user.target.wants/evtest-grab.service
EVTEST_GRAB_SERVICE

            __loc_target_link_overwrite;
        else
            FILE_PATH \
<<'EVTEST_GRAB_SERVICE'
/etc/systemd/system/evtest-grab.service
EVTEST_GRAB_SERVICE

            __loc_delete;

            FILE_PATH \
<<'EVTEST_GRAB_SERVICE'
/etc/systemd/system/multi-user.target.wants/evtest-grab.service
EVTEST_GRAB_SERVICE

            __loc_delete;
        fi

        if [ "$wland" = iwd ]; then
            FILE_PATH \
<<'IWD_SERVICE'
/etc/systemd/system/iwd.service
IWD_SERVICE

            FILE \
<<'IWD_SERVICE'
[Unit]
Description=Wireless service

[Service]
ExecStart=/usr/lib/iwd/iwd

[Install]
WantedBy=multi-user.target
IWD_SERVICE

            __file_write;

            FILE_PATH \
<<'IWD_SERVICE'
/etc/systemd/system/iwd.service
IWD_SERVICE

            FILE_PATH_TARGET \
<<'IWD_SERVICE'
/etc/systemd/system/multi-user.target.wants/iwd.service
IWD_SERVICE

            __loc_target_link_overwrite;
        elif [ "$wland" = none ] || [ ! "$wland" ]; then
            FILE_PATH \
<<'IWD_SERVICE'
/etc/systemd/system/iwd.service
IWD_SERVICE

            __loc_delete;

            FILE_PATH \
<<'IWD_SERVICE'
/etc/systemd/system/multi-user.target.wants/iwd.service
IWD_SERVICE

            __loc_delete;
        fi

        if [ "$audio_playerd" = moc ]; then
            FILE_PATH \
<<MOC_SERVICE
$home/.config/systemd/user/moc.service
MOC_SERVICE

            FILE \
<<'MOC_SERVICE'
[Unit]
Description=MOC server

[Service]
RemainAfterExit=yes
ExecStart=/usr/bin/mocp -S
ExecStop=/usr/bin/mocp -x
TimeoutStopSec=3

[Install]
WantedBy=default.target
MOC_SERVICE

            __file_write;

            FILE_PATH \
<<MOC_SERVICE
$home/.config/systemd/user/moc.service
MOC_SERVICE

            FILE_PATH_TARGET \
<<MOC_SERVICE
$home/.config/systemd/user/default.target.wants/moc.service
MOC_SERVICE

            __loc_target_link_overwrite;
        elif [ "$audio_playerd" = none ] || [ ! "$audio_playerd" ]; then
            FILE_PATH \
<<MOC_SERVICE
$home/.config/systemd/user/moc.service
MOC_SERVICE

            __loc_delete;

            FILE_PATH \
<<MOC_SERVICE
$home/.config/systemd/user/default.target.wants/moc.service
MOC_SERVICE

            __loc_delete;
        fi

        if [ "$audio_server" = pipewire ]; then
            FILE_PATH \
<<PIPEWIRE_SERVICE
$home/.config/systemd/user/pipewire.service
PIPEWIRE_SERVICE

            FILE \
<<'PIPEWIRE_SERVICE'
[Unit]
Description=PipeWire Multimedia Service

[Service]
ExecStart=/usr/bin/pipewire

[Install]
WantedBy=default.target
PIPEWIRE_SERVICE

            __file_write;

            FILE_PATH \
<<PIPEWIRE_SERVICE
$home/.config/systemd/user/pipewire.service
PIPEWIRE_SERVICE

            FILE_PATH_TARGET \
<<PIPEWIRE_SERVICE
$home/.config/systemd/user/default.target.wants/pipewire.service
PIPEWIRE_SERVICE

            __loc_target_link_overwrite;

            if [ "$pipewire_manager" = pipewire ]; then
                FILE_PATH \
<<PIPEWIRE_MEDIA_SESSION_SERVICE
$home/.config/systemd/user/pipewire-media-session.service
PIPEWIRE_MEDIA_SESSION_SERVICE

                FILE \
<<'PIPEWIRE_MEDIA_SESSION_SERVICE'
[Unit]
Description=PipeWire Media Session Manager
After=pipewire.service
BindsTo=pipewire.service

[Service]
ExecStartPre=/usr/bin/sleep 2
ExecStart=/usr/bin/pipewire-media-session

[Install]
WantedBy=pipewire.service
PIPEWIRE_MEDIA_SESSION_SERVICE

                __file_write;

                FILE_PATH \
<<PIPEWIRE_MEDIA_SESSION_SERVICE
$home/.config/systemd/user/pipewire-media-session.service
PIPEWIRE_MEDIA_SESSION_SERVICE

                FILE_PATH_TARGET \
<<PIPEWIRE_MEDIA_SESSION_SERVICE
$home/.config/systemd/user/pipewire.service.wants/pipewire-media-session.service
PIPEWIRE_MEDIA_SESSION_SERVICE

                __loc_target_link_overwrite;
            elif [ "$pipewire_manager" = none ] || [ ! "$pipewire_manager" ]; then
                FILE_PATH \
<<PIPEWIRE_MEDIA_SESSION_SERVICE
$home/.config/systemd/user/pipewire-media-session.service
PIPEWIRE_MEDIA_SESSION_SERVICE

                __loc_delete;

                FILE_PATH \
<<PIPEWIRE_MEDIA_SESSION_SERVICE
$home/.config/systemd/user/pipewire.service.wants/pipewire-media-session.service
PIPEWIRE_MEDIA_SESSION_SERVICE

                __loc_delete;
            fi

            FILE_PATH \
<<PIPEWIRE_PULSE_SERVICE
$home/.config/systemd/user/pipewire-pulse.service
PIPEWIRE_PULSE_SERVICE

            FILE \
<<'PIPEWIRE_PULSE_SERVICE'
[Unit]
Description=PipeWire PulseAudio
After=pipewire.service
BindsTo=pipewire.service

[Service]
ExecStart=/usr/bin/pipewire-pulse

[Install]
WantedBy=pipewire.service
PIPEWIRE_PULSE_SERVICE

            __file_write;

            FILE_PATH \
<<PIPEWIRE_PULSE_SERVICE
$home/.config/systemd/user/pipewire-pulse.service
PIPEWIRE_PULSE_SERVICE

            FILE_PATH_TARGET \
<<PIPEWIRE_PULSE_SERVICE
$home/.config/systemd/user/pipewire.service.wants/pipewire-pulse.service
PIPEWIRE_PULSE_SERVICE

            __loc_target_link_overwrite;
        elif [ "$audio_server" = none ] || [ ! "$audio_server" ]; then
            FILE_PATH \
<<PIPEWIRE_SERVICE
$home/.config/systemd/user/pipewire.service
PIPEWIRE_SERVICE

            __loc_delete;

            FILE_PATH \
<<PIPEWIRE_SERVICE
$home/.config/systemd/user/default.target.wants/pipewire.service
PIPEWIRE_SERVICE

            __loc_delete;

            FILE_PATH \
<<PIPEWIRE_MEDIA_SESSION_SERVICE
$home/.config/systemd/user/pipewire-media-session.service
PIPEWIRE_MEDIA_SESSION_SERVICE

            __loc_delete;

            FILE_PATH \
<<PIPEWIRE_MEDIA_SESSION_SERVICE
$home/.config/systemd/user/pipewire.service.wants/pipewire-media-session.service
PIPEWIRE_MEDIA_SESSION_SERVICE

            __loc_delete;

            FILE_PATH \
<<PIPEWIRE_PULSE_SERVICE
$home/.config/systemd/user/pipewire-pulse.service
PIPEWIRE_PULSE_SERVICE

            __loc_delete;

            FILE_PATH \
<<PIPEWIRE_PULSE_SERVICE
$home/.config/systemd/user/pipewire.service.wants/pipewire-pulse.service
PIPEWIRE_PULSE_SERVICE

            __loc_delete;
        fi

        if [ "$portal" = 1 ]; then
            FILE_PATH \
<<XDG_DESKTOP_PORTAL_SERVICE
$home/.config/systemd/user/xdg-desktop-portal.service
XDG_DESKTOP_PORTAL_SERVICE

            FILE \
<<'XDG_DESKTOP_PORTAL_SERVICE'
[Unit]
Description=Portal service
PartOf=graphical-session.target

[Service]
Type=dbus
BusName=org.freedesktop.portal.Desktop
ExecStart=/usr/lib/xdg-desktop-portal
Slice=session.slice
XDG_DESKTOP_PORTAL_SERVICE

            __file_write;

            FILE_PATH \
<<XDG_DESKTOP_PORTAL_GTK_SERVICE
$home/.config/systemd/user/xdg-desktop-portal-gtk.service
XDG_DESKTOP_PORTAL_GTK_SERVICE

            FILE \
<<'XDG_DESKTOP_PORTAL_GTK_SERVICE'
[Unit]
Description=Portal service (GTK/GNOME implementation)
PartOf=graphical-session.target

[Service]
Type=dbus
BusName=org.freedesktop.impl.portal.desktop.gtk
ExecStart=/usr/lib/xdg-desktop-portal-gtk
Slice=session.slice
XDG_DESKTOP_PORTAL_GTK_SERVICE

            __file_write;

            FILE_PATH \
<<XDG_DESKTOP_PORTAL_WLR_SERVICE
$home/.config/systemd/user/xdg-desktop-portal-wlr.service
XDG_DESKTOP_PORTAL_WLR_SERVICE

            FILE \
<<'XDG_DESKTOP_PORTAL_WLR_SERVICE'
[Unit]
Description=Portal service (wlroots implementation)
PartOf=graphical-session.target

[Service]
Type=dbus
BusName=org.freedesktop.impl.portal.desktop.wlr
ExecStart=/usr/lib/xdg-desktop-portal-wlr
Slice=session.slice
XDG_DESKTOP_PORTAL_WLR_SERVICE

            __file_write;

            FILE_PATH \
<<XDG_DOCUMENT_PORTAL_SERVICE
$home/.config/systemd/user/xdg-document-portal.service
XDG_DOCUMENT_PORTAL_SERVICE

            FILE \
<<'XDG_DOCUMENT_PORTAL_SERVICE'
[Unit]
Description=flatpak document portal service
PartOf=graphical-session.target

[Service]
Type=dbus
BusName=org.freedesktop.portal.Documents
ExecStart=/usr/lib/xdg-document-portal
Slice=session.slice
XDG_DOCUMENT_PORTAL_SERVICE

            __file_write;

            FILE_PATH \
<<XDG_PERMISSION_STORE_SERVICE
$home/.config/systemd/user/xdg-permission-store.service
XDG_PERMISSION_STORE_SERVICE

            FILE \
<<'XDG_PERMISSION_STORE_SERVICE'
[Unit]
Description=sandboxed app permission store
PartOf=graphical-session.target

[Service]
Type=dbus
BusName=org.freedesktop.impl.portal.PermissionStore
ExecStart=/usr/lib/xdg-permission-store
Slice=session.slice
XDG_PERMISSION_STORE_SERVICE

            __file_write;
        else
            FILE_PATH \
<<XDG_DESKTOP_PORTAL_SERVICE
$home/.config/systemd/user/xdg-desktop-portal.service
XDG_DESKTOP_PORTAL_SERVICE

            __loc_delete;

            FILE_PATH \
<<XDG_DESKTOP_PORTAL_GTK_SERVICE
$home/.config/systemd/user/xdg-desktop-portal-gtk.service
XDG_DESKTOP_PORTAL_GTK_SERVICE

            __loc_delete;

            FILE_PATH \
<<XDG_DESKTOP_PORTAL_WLR_SERVICE
$home/.config/systemd/user/xdg-desktop-portal-wlr.service
XDG_DESKTOP_PORTAL_WLR_SERVICE

            __loc_delete;

            FILE_PATH \
<<XDG_DOCUMENT_PORTAL_SERVICE
$home/.config/systemd/user/xdg-document-portal.service
XDG_DOCUMENT_PORTAL_SERVICE

            __loc_delete;

            FILE_PATH \
<<XDG_PERMISSION_STORE_SERVICE
$home/.config/systemd/user/xdg-permission-store.service
XDG_PERMISSION_STORE_SERVICE

            __loc_delete;
        fi

        if [ "$arch_linux" = 1 ]; then
            FILE_PATH \
<<'NULL'
/dev/null
NULL

            FILE_PATH_TARGET \
<<'RTKIT_DAEMON_SERVICE'
/etc/systemd/system/rtkit-daemon.service
RTKIT_DAEMON_SERVICE

            __loc_target_link_overwrite;

            FILE_PATH \
<<'NULL'
/dev/null
NULL

            FILE_PATH_TARGET \
<<AT_SPI_DBUS_BUS_SERVICE
$home/.config/systemd/user/at-spi-dbus-bus.service
AT_SPI_DBUS_BUS_SERVICE

            __loc_target_link_overwrite;

            FILE_PATH \
<<'NULL'
/dev/null
NULL

            if [ "$audio_server" = pipewire ]; then
                FILE_PATH_TARGET \
<<PIPEWIRE_SOCKET
$home/.config/systemd/user/pipewire.socket
PIPEWIRE_SOCKET

                __loc_target_link_overwrite;

                FILE_PATH \
<<'NULL'
/dev/null
NULL

                FILE_PATH_TARGET \
<<PIPEWIRE_PULSE_SOCKET
$home/.config/systemd/user/pipewire-pulse.socket
PIPEWIRE_PULSE_SOCKET

                __loc_target_link_overwrite;
            elif [ "$audio_server" = none ] || [ ! "$audio_server" ]; then
                FILE_PATH \
<<PIPEWIRE_SOCKET
$home/.config/systemd/user/pipewire.socket
PIPEWIRE_SOCKET

                __loc_delete;

                FILE_PATH \
<<PIPEWIRE_PULSE_SOCKET
$home/.config/systemd/user/pipewire-pulse.socket
PIPEWIRE_PULSE_SOCKET

                __loc_delete;
            fi

            FILE_PATH \
<<ORG_FREEDESKTOP_IMPL_PORTAL_DESKTOP_GTK_SERVICE
$home/.local/share/dbus-1/services/org.freedesktop.impl.portal.desktop.gtk.service
ORG_FREEDESKTOP_IMPL_PORTAL_DESKTOP_GTK_SERVICE

            FILE \
<<'ORG_FREEDESKTOP_IMPL_PORTAL_DESKTOP_GTK_SERVICE'
[D-BUS Service]
Name=org.freedesktop.impl.portal.desktop.gtk
Exec=/usr/bin/true
ORG_FREEDESKTOP_IMPL_PORTAL_DESKTOP_GTK_SERVICE

            __file_write;

            FILE_PATH \
<<ORG_FREEDESKTOP_IMPL_PORTAL_DESKTOP_WLR_SERVICE
$home/.local/share/dbus-1/services/org.freedesktop.impl.portal.desktop.wlr.service
ORG_FREEDESKTOP_IMPL_PORTAL_DESKTOP_WLR_SERVICE

            FILE \
<<'ORG_FREEDESKTOP_IMPL_PORTAL_DESKTOP_WLR_SERVICE'
[D-BUS Service]
Name=org.freedesktop.impl.portal.desktop.wlr
Exec=/usr/bin/true
ORG_FREEDESKTOP_IMPL_PORTAL_DESKTOP_WLR_SERVICE

            __file_write;

            FILE_PATH \
<<ORG_FREEDESKTOP_IMPL_PORTAL_PERMISSIONSTORE_SERVICE
$home/.local/share/dbus-1/services/org.freedesktop.impl.portal.PermissionStore.service
ORG_FREEDESKTOP_IMPL_PORTAL_PERMISSIONSTORE_SERVICE

            FILE \
<<'ORG_FREEDESKTOP_IMPL_PORTAL_PERMISSIONSTORE_SERVICE'
[D-BUS Service]
Name=org.freedesktop.impl.portal.PermissionStore
Exec=/usr/bin/true
ORG_FREEDESKTOP_IMPL_PORTAL_PERMISSIONSTORE_SERVICE

            __file_write;

            FILE_PATH \
<<ORG_FREEDESKTOP_PORTAL_DESKTOP_SERVICE
$home/.local/share/dbus-1/services/org.freedesktop.portal.Desktop.service
ORG_FREEDESKTOP_PORTAL_DESKTOP_SERVICE

            FILE \
<<'ORG_FREEDESKTOP_PORTAL_DESKTOP_SERVICE'
[D-BUS Service]
Name=org.freedesktop.portal.Desktop
Exec=/usr/bin/true
ORG_FREEDESKTOP_PORTAL_DESKTOP_SERVICE

            __file_write;

            FILE_PATH \
<<ORG_FREEDESKTOP_PORTAL_DOCUMENTS_SERVICE
$home/.local/share/dbus-1/services/org.freedesktop.portal.Documents.service
ORG_FREEDESKTOP_PORTAL_DOCUMENTS_SERVICE

            FILE \
<<'ORG_FREEDESKTOP_PORTAL_DOCUMENTS_SERVICE'
[D-BUS Service]
Name=org.freedesktop.portal.Documents
Exec=/usr/bin/true
ORG_FREEDESKTOP_PORTAL_DOCUMENTS_SERVICE

            __file_write;
        else
            FILE_PATH \
<<'RTKIT_DAEMON_SERVICE'
/etc/systemd/system/rtkit-daemon.service
RTKIT_DAEMON_SERVICE

            __loc_delete;

            FILE_PATH \
<<AT_SPI_DBUS_BUS_SERVICE
$home/.config/systemd/user/at-spi-dbus-bus.service
AT_SPI_DBUS_BUS_SERVICE

            __loc_delete;

            FILE_PATH \
<<PIPEWIRE_SOCKET
$home/.config/systemd/user/pipewire.socket
PIPEWIRE_SOCKET

            __loc_delete;

            FILE_PATH \
<<PIPEWIRE_PULSE_SOCKET
$home/.config/systemd/user/pipewire-pulse.socket
PIPEWIRE_PULSE_SOCKET

            __loc_delete;

            FILE_PATH \
<<ORG_FREEDESKTOP_IMPL_PORTAL_DESKTOP_GTK_SERVICE
$home/.local/share/dbus-1/services/org.freedesktop.impl.portal.desktop.gtk.service
ORG_FREEDESKTOP_IMPL_PORTAL_DESKTOP_GTK_SERVICE

            __loc_delete;

            FILE_PATH \
<<ORG_FREEDESKTOP_IMPL_PORTAL_DESKTOP_WLR_SERVICE
$home/.local/share/dbus-1/services/org.freedesktop.impl.portal.desktop.wlr.service
ORG_FREEDESKTOP_IMPL_PORTAL_DESKTOP_WLR_SERVICE

            __loc_delete;

            FILE_PATH \
<<ORG_FREEDESKTOP_IMPL_PORTAL_PERMISSIONSTORE_SERVICE
$home/.local/share/dbus-1/services/org.freedesktop.impl.portal.PermissionStore.service
ORG_FREEDESKTOP_IMPL_PORTAL_PERMISSIONSTORE_SERVICE

            __loc_delete;

            FILE_PATH \
<<ORG_FREEDESKTOP_PORTAL_DESKTOP_SERVICE
$home/.local/share/dbus-1/services/org.freedesktop.portal.Desktop.service
ORG_FREEDESKTOP_PORTAL_DESKTOP_SERVICE

            __loc_delete;

            FILE_PATH \
<<ORG_FREEDESKTOP_PORTAL_DOCUMENTS_SERVICE
$home/.local/share/dbus-1/services/org.freedesktop.portal.Documents.service
ORG_FREEDESKTOP_PORTAL_DOCUMENTS_SERVICE

            __loc_delete;
        fi
    elif [ "$init" = none ] || [ ! "$init" ]; then
        FILE_PATH \
<<'BLUETOOTH_SERVICE'
/etc/systemd/system/bluetooth.service
BLUETOOTH_SERVICE

        __loc_delete;

        FILE_PATH \
<<'BLUETOOTH_SERVICE'
/etc/systemd/system/multi-user.target.wants/bluetooth.service
BLUETOOTH_SERVICE

        __loc_delete;

        FILE_PATH \
<<'DNSMASQ_SERVICE'
/etc/systemd/system/dnsmasq.service
DNSMASQ_SERVICE

        __loc_delete;

        FILE_PATH \
<<'DNSMASQ_SERVICE'
/etc/systemd/system/multi-user.target.wants/dnsmasq.service
DNSMASQ_SERVICE

        __loc_delete;

        FILE_PATH \
<<'EVTEST_GRAB_SERVICE'
/etc/systemd/system/evtest-grab.service
EVTEST_GRAB_SERVICE

        __loc_delete;

        FILE_PATH \
<<'EVTEST_GRAB_SERVICE'
/etc/systemd/system/multi-user.target.wants/evtest-grab.service
EVTEST_GRAB_SERVICE

        __loc_delete;

        FILE_PATH \
<<'IWD_SERVICE'
/etc/systemd/system/iwd.service
IWD_SERVICE

        __loc_delete;

        FILE_PATH \
<<'IWD_SERVICE'
/etc/systemd/system/multi-user.target.wants/iwd.service
IWD_SERVICE

        __loc_delete;

        FILE_PATH \
<<MOC_SERVICE
$home/.config/systemd/user/moc.service
MOC_SERVICE

        __loc_delete;

        FILE_PATH \
<<MOC_SERVICE
$home/.config/systemd/user/default.target.wants/moc.service
MOC_SERVICE

        __loc_delete;

        FILE_PATH \
<<PIPEWIRE_SERVICE
$home/.config/systemd/user/pipewire.service
PIPEWIRE_SERVICE

        __loc_delete;

        FILE_PATH \
<<PIPEWIRE_SERVICE
$home/.config/systemd/user/default.target.wants/pipewire.service
PIPEWIRE_SERVICE

        __loc_delete;

        FILE_PATH \
<<PIPEWIRE_MEDIA_SESSION_SERVICE
$home/.config/systemd/user/pipewire-media-session.service
PIPEWIRE_MEDIA_SESSION_SERVICE

        __loc_delete;

        FILE_PATH \
<<PIPEWIRE_MEDIA_SESSION_SERVICE
$home/.config/systemd/user/pipewire.service.wants/pipewire-media-session.service
PIPEWIRE_MEDIA_SESSION_SERVICE

        __loc_delete;

        FILE_PATH \
<<PIPEWIRE_PULSE_SERVICE
$home/.config/systemd/user/pipewire-pulse.service
PIPEWIRE_PULSE_SERVICE

        __loc_delete;

        FILE_PATH \
<<PIPEWIRE_PULSE_SERVICE
$home/.config/systemd/user/pipewire.service.wants/pipewire-pulse.service
PIPEWIRE_PULSE_SERVICE

        __loc_delete;

        FILE_PATH \
<<XDG_DESKTOP_PORTAL_SERVICE
$home/.config/systemd/user/xdg-desktop-portal.service
XDG_DESKTOP_PORTAL_SERVICE

        __loc_delete;

        FILE_PATH \
<<XDG_DESKTOP_PORTAL_GTK_SERVICE
$home/.config/systemd/user/xdg-desktop-portal-gtk.service
XDG_DESKTOP_PORTAL_GTK_SERVICE

        __loc_delete;

        FILE_PATH \
<<XDG_DESKTOP_PORTAL_WLR_SERVICE
$home/.config/systemd/user/xdg-desktop-portal-wlr.service
XDG_DESKTOP_PORTAL_WLR_SERVICE

        __loc_delete;

        FILE_PATH \
<<XDG_DOCUMENT_PORTAL_SERVICE
$home/.config/systemd/user/xdg-document-portal.service
XDG_DOCUMENT_PORTAL_SERVICE

        __loc_delete;

        FILE_PATH \
<<XDG_PERMISSION_STORE_SERVICE
$home/.config/systemd/user/xdg-permission-store.service
XDG_PERMISSION_STORE_SERVICE

        __loc_delete;

        FILE_PATH \
<<'RTKIT_DAEMON_SERVICE'
/etc/systemd/system/rtkit-daemon.service
RTKIT_DAEMON_SERVICE

        __loc_delete;

        FILE_PATH \
<<AT_SPI_DBUS_BUS_SERVICE
$home/.config/systemd/user/at-spi-dbus-bus.service
AT_SPI_DBUS_BUS_SERVICE

        __loc_delete;

        FILE_PATH \
<<PIPEWIRE_SOCKET
$home/.config/systemd/user/pipewire.socket
PIPEWIRE_SOCKET

        __loc_delete;

        FILE_PATH \
<<PIPEWIRE_PULSE_SOCKET
$home/.config/systemd/user/pipewire-pulse.socket
PIPEWIRE_PULSE_SOCKET

        __loc_delete;

        FILE_PATH \
<<ORG_FREEDESKTOP_IMPL_PORTAL_DESKTOP_GTK_SERVICE
$home/.local/share/dbus-1/services/org.freedesktop.impl.portal.desktop.gtk.service
ORG_FREEDESKTOP_IMPL_PORTAL_DESKTOP_GTK_SERVICE

        __loc_delete;

        FILE_PATH \
<<ORG_FREEDESKTOP_IMPL_PORTAL_DESKTOP_WLR_SERVICE
$home/.local/share/dbus-1/services/org.freedesktop.impl.portal.desktop.wlr.service
ORG_FREEDESKTOP_IMPL_PORTAL_DESKTOP_WLR_SERVICE

        __loc_delete;

        FILE_PATH \
<<ORG_FREEDESKTOP_IMPL_PORTAL_PERMISSIONSTORE_SERVICE
$home/.local/share/dbus-1/services/org.freedesktop.impl.portal.PermissionStore.service
ORG_FREEDESKTOP_IMPL_PORTAL_PERMISSIONSTORE_SERVICE

        __loc_delete;

        FILE_PATH \
<<ORG_FREEDESKTOP_PORTAL_DESKTOP_SERVICE
$home/.local/share/dbus-1/services/org.freedesktop.portal.Desktop.service
ORG_FREEDESKTOP_PORTAL_DESKTOP_SERVICE

        __loc_delete;

        FILE_PATH \
<<ORG_FREEDESKTOP_PORTAL_DOCUMENTS_SERVICE
$home/.local/share/dbus-1/services/org.freedesktop.portal.Documents.service
ORG_FREEDESKTOP_PORTAL_DOCUMENTS_SERVICE

        __loc_delete;
    fi
}

_bash_conf() {
    FILE_PATH \
<<_BASH_FUNCTIONS
$home/.bash_functions
_BASH_FUNCTIONS

    FILE \
<<'_BASH_FUNCTIONS'
# System management
sys_pwr_fw() { pwr_fw; }
sys_pwr_off() { pwr_off "$@"; }
sys_pwr_reset() { pwr_reset "$@"; }
sys_pkg_get() { pkg_get "$@"; }
sys_pkg_rm() { pkg_rm "$@"; }
sys_pkg_rmF() { pkg_rmF "$@"; }
sys_pkg_pip_get() { pkg_pip_get "$@"; }
sys_pkg_pip_get_req() { pkg_pip_get_req "$@"; }
sys_pkg_pip_rm() { pkg_pip_rm "$@"; }
sys_up() { up; }
sys_upF() { upF; }

# Package management
pkg_get() (
    case ":$1" in
        :)
            printf "%bERROR:%b No package(s) specified.\n" \
                   "\033[1;31m" "\033[0m"
            exit 2
        ;;
    esac

    ARGS='--sync'

    while [ "$1" ]; do
        ARGS="$ARGS"" \"$1\""
        shift
    done

    eval "su -c 'pacman ${ARGS}'"
)
pkg_rm() (
    case ":$1" in
        :)
            printf "%bERROR:%b No package(s) specified.\n" \
                   "\033[1;31m" "\033[0m"
            exit 2
        ;;
    esac

    ARGS='--remove'
    ARGS="$ARGS"' --nosave'
    ARGS="$ARGS"' --recursive'

    while [ "$1" ]; do
        ARGS="$ARGS"" \"$1\""
        shift
    done

    eval "su -c 'pacman ${ARGS}'"
)
pkg_rmF() (
    case ":$1" in
        :)
            printf "%bERROR:%b No package(s) specified.\n" \
                   "\033[1;31m" "\033[0m"
            exit 2
        ;;
    esac

    ARGS='--remove'
    ARGS="$ARGS"' --nosave'
    ARGS="$ARGS"' --recursive'
    ARGS="$ARGS"' -dd'

    while [ "$1" ]; do
        ARGS="$ARGS"" \"$1\""
        shift
    done

    eval "su -c 'pacman ${ARGS}'"
)
pkg_pip_get() (
    case ":$1" in
        :)
            printf "%bERROR:%b No package(s) specified.\n" \
                   "\033[1;31m" "\033[0m"
            exit 2
        ;;
    esac

    ARGS='-m pip'
    ARGS="$ARGS"' install'
    ARGS="$ARGS"' --user'
    ARGS="$ARGS"' --break-system-packages'

    while [ "$1" ]; do
        ARGS="$ARGS"" \"$1\""
        shift
    done

    eval "python ${ARGS}"
)
pkg_pip_get_req() (
    case ":$1" in
        :)
            printf "%bERROR:%b No file(s) specified.\n" \
                   "\033[1;31m" "\033[0m"
            exit 2
        ;;
    esac

    ARGS='-m pip'
    ARGS="$ARGS"' install'
    ARGS="$ARGS"' --user'
    ARGS="$ARGS"' --break-system-packages'

    while [ "$1" ]; do
        ARGS="$ARGS"" --requirement \"$1\""
        shift
    done

    eval "python ${ARGS}"
)
pkg_pip_rm() (
    case ":$1" in
        :)
            printf "%bERROR:%b No package(s) specified.\n" \
                   "\033[1;31m" "\033[0m"
            exit 2
        ;;
    esac

    ARGS='-m pip'
    ARGS="$ARGS"' uninstall'
    ARGS="$ARGS"' --yes'

    while [ "$1" ]; do
        ARGS="$ARGS"" \"$1\""
        shift
    done

    eval "python ${ARGS}"
)

# Power management
pwr_fw() (
    su -c 'systemctl reboot --firmware-setup'
)
pwr_off() (
    case ":$1" in
        :) su -c 'shutdown -P now' ;;
        *) su -c "shutdown -P $1" ;;
    esac
)
pwr_reset() (
    case ":$1" in
        :) su -c 'shutdown -r now' ;;
        *) su -c "shutdown -r $1" ;;
    esac
)

# Update management
up() (
    ARGS='--sync'
    ARGS="$ARGS"' --refresh'
    ARGS="$ARGS"' --sysupgrade'

    eval "su -c 'pacman ${ARGS}'"
)
upF() (
    ARGS='--sync'
    ARGS="$ARGS"' -yyuu'

    eval "su -c 'pacman ${ARGS}'"
)

# Other management
ramfs_c() (
    su -c "
        [ ! -e /mnt/ramdisk ] || {
            echo 'fail: /mnt/ramdisk already exists'; exit 0
        }
        mkdir /mnt/ramdisk 2> /dev/null
        mount -t ramfs ramfs /mnt/ramdisk && \
        chown $USER:$USER /mnt/ramdisk && \
        chmod 700 /mnt/ramdisk
    "
)
ramfs_d() (
    su -c "
        [ -e /mnt/ramdisk ] || {
            echo 'fail: /mnt/ramdisk does not exist'; exit 0
        }
        umount /mnt/ramdisk && \
        rm -rf /mnt/ramdisk
    "
)

# ffmpeg
ffmpeg_a_get_from() (
    { # Variables expected to be present: OUT, FILENAME.
        handle_err() {
            trap - EXIT
            [ -d "$TMP_DIR" ] && rm -rf "$TMP_DIR"
            [ -d "$DIR" ] && cd "$DIR"
            exit $1
        }; handle_exit() {
            case $1 in
                0) : ;;
                *) handle_err $1 ;;
            esac
            case ":$OUT" in
                :) set -- * ;;
                *) set -- "$OUT" ;;
            esac
            case ":$FILENAME" in
                :)
                    mv "$TMP_DIR"/"$1" "$DIR"/"$1"
                    printf "%bFILE:%b %b%s%b\n" \
                           "\033[1;32m" "\033[0m" "\033[1;37m" \
                           "$DIR/$1" "\033[0m"
                ;;
                *)
                    mv "$TMP_DIR"/"$1" "$DIR"/"${FILENAME}${1#"${1%.*}"}"
                    printf "%bFILE:%b %b%s%b\n" \
                           "\033[1;32m" "\033[0m" "\033[1;37m" \
                           "$DIR/${FILENAME}${1#"${1%.*}"}" "\033[0m"
                ;;
            esac
            [ -d "$TMP_DIR" ] && rm -rf "$TMP_DIR"
            [ -d "$DIR" ] && cd "$DIR"
        }; work() {
            DIR="$PWD"; TMP_DIR="$HOME"/.b81y7yt73627iyqguo9v3ryrand0mstr1ng
            [ -d "$TMP_DIR" ] && rm -rf "$TMP_DIR"
            mkdir "$TMP_DIR"; cd "$TMP_DIR"
        }
        trap "handle_err \$?" INT TERM
        trap "handle_exit \$?" EXIT
        set -e
        work;
    } # Provided variables: DIR; TMP_DIR.

    case ":$1" in
        :)
            printf "%bERROR:%b No time specified.\n" \
                   "\033[1;31m" "\033[0m"
            exit 2
        ;;
    esac
    case ":$2" in
        :)
            printf "%bERROR:%b No file specified.\n" \
                   "\033[1;31m" "\033[0m"
            exit 2
        ;;
    esac

    FROM="$1"
    [ -f "$2" ] && IN="$2" || IN="$DIR/$2"

    if [ ! -f "$IN" ]; then
        printf "%bERROR:%b No file found.\n" \
               "\033[1;31m" "\033[0m"
        exit 2
    fi

    OUT=$(
        printf "%s" "${IN##*/}"
    )

    ARGS="-i \"$IN\" -ss $FROM"
    ARGS="$ARGS"' -c:a copy'
    ARGS="$ARGS"" \"$OUT\""

    eval "ffmpeg ${ARGS}"
)
ffmpeg_a_get_to() (
    { # Variables expected to be present: OUT, FILENAME.
        handle_err() {
            trap - EXIT
            [ -d "$TMP_DIR" ] && rm -rf "$TMP_DIR"
            [ -d "$DIR" ] && cd "$DIR"
            exit $1
        }; handle_exit() {
            case $1 in
                0) : ;;
                *) handle_err $1 ;;
            esac
            case ":$OUT" in
                :) set -- * ;;
                *) set -- "$OUT" ;;
            esac
            case ":$FILENAME" in
                :)
                    mv "$TMP_DIR"/"$1" "$DIR"/"$1"
                    printf "%bFILE:%b %b%s%b\n" \
                           "\033[1;32m" "\033[0m" "\033[1;37m" \
                           "$DIR/$1" "\033[0m"
                ;;
                *)
                    mv "$TMP_DIR"/"$1" "$DIR"/"${FILENAME}${1#"${1%.*}"}"
                    printf "%bFILE:%b %b%s%b\n" \
                           "\033[1;32m" "\033[0m" "\033[1;37m" \
                           "$DIR/${FILENAME}${1#"${1%.*}"}" "\033[0m"
                ;;
            esac
            [ -d "$TMP_DIR" ] && rm -rf "$TMP_DIR"
            [ -d "$DIR" ] && cd "$DIR"
        }; work() {
            DIR="$PWD"; TMP_DIR="$HOME"/.b81y7yt73627iyqguo9v3ryrand0mstr1ng
            [ -d "$TMP_DIR" ] && rm -rf "$TMP_DIR"
            mkdir "$TMP_DIR"; cd "$TMP_DIR"
        }
        trap "handle_err \$?" INT TERM
        trap "handle_exit \$?" EXIT
        set -e
        work;
    } # Provided variables: DIR; TMP_DIR.

    case ":$1" in
        :)
            printf "%bERROR:%b No time specified.\n" \
                   "\033[1;31m" "\033[0m"
            exit 2
        ;;
    esac
    case ":$2" in
        :)
            printf "%bERROR:%b No file specified.\n" \
                   "\033[1;31m" "\033[0m"
            exit 2
        ;;
    esac

    TO="$1"
    [ -f "$2" ] && IN="$2" || IN="$DIR/$2"

    if [ ! -f "$IN" ]; then
        printf "%bERROR:%b No file found.\n" \
               "\033[1;31m" "\033[0m"
        exit 2
    fi

    OUT=$(
        printf "%s" "${IN##*/}"
    )

    ARGS="-t $TO"
    ARGS="$ARGS"" -i \"$IN\""
    ARGS="$ARGS"' -c:a copy'
    ARGS="$ARGS"" \"$OUT\""

    eval "ffmpeg ${ARGS}"
)
ffmpeg_a_get_fromto() (
    { # Variables expected to be present: OUT, FILENAME.
        handle_err() {
            trap - EXIT
            [ -d "$TMP_DIR" ] && rm -rf "$TMP_DIR"
            [ -d "$DIR" ] && cd "$DIR"
            exit $1
        }; handle_exit() {
            case $1 in
                0) : ;;
                *) handle_err $1 ;;
            esac
            case ":$OUT" in
                :) set -- * ;;
                *) set -- "$OUT" ;;
            esac
            case ":$FILENAME" in
                :)
                    mv "$TMP_DIR"/"$1" "$DIR"/"$1"
                    printf "%bFILE:%b %b%s%b\n" \
                           "\033[1;32m" "\033[0m" "\033[1;37m" \
                           "$DIR/$1" "\033[0m"
                ;;
                *)
                    mv "$TMP_DIR"/"$1" "$DIR"/"${FILENAME}${1#"${1%.*}"}"
                    printf "%bFILE:%b %b%s%b\n" \
                           "\033[1;32m" "\033[0m" "\033[1;37m" \
                           "$DIR/${FILENAME}${1#"${1%.*}"}" "\033[0m"
                ;;
            esac
            [ -d "$TMP_DIR" ] && rm -rf "$TMP_DIR"
            [ -d "$DIR" ] && cd "$DIR"
        }; work() {
            DIR="$PWD"; TMP_DIR="$HOME"/.b81y7yt73627iyqguo9v3ryrand0mstr1ng
            [ -d "$TMP_DIR" ] && rm -rf "$TMP_DIR"
            mkdir "$TMP_DIR"; cd "$TMP_DIR"
        }
        trap "handle_err \$?" INT TERM
        trap "handle_exit \$?" EXIT
        set -e
        work;
    } # Provided variables: DIR; TMP_DIR.

    case ":$1" in
        :)
            printf "%bERROR:%b No FROM time specified.\n" \
                   "\033[1;31m" "\033[0m"
            exit 2
        ;;
    esac
    case ":$2" in
        :)
            printf "%bERROR:%b No TO time specified.\n" \
                   "\033[1;31m" "\033[0m"
            exit 2
        ;;
    esac
    case ":$3" in
        :)
            printf "%bERROR:%b No file specified.\n" \
                   "\033[1;31m" "\033[0m"
            exit 2
        ;;
    esac

    FROM="$1"
    TO="$2"
    [ -f "$3" ] && IN="$3" || IN="$DIR/$3"
    

    if [ ! -f "$IN" ]; then
        printf "%bERROR:%b No file found.\n" \
               "\033[1;31m" "\033[0m"
        exit 2
    fi

    OUT=$(
        printf "%s" "${IN##*/}"
    )

    ARGS="-ss $FROM"
    ARGS="$ARGS"" -t $TO"
    ARGS="$ARGS"" -i \"$IN\""
    ARGS="$ARGS"' -c:a copy'
    ARGS="$ARGS"" \"$OUT\""

    eval "ffmpeg ${ARGS}"
)
ffmpeg_merge() (
    { # Variables expected to be present: OUT, FILENAME.
        handle_err() {
            trap - EXIT
            [ -d "$TMP_DIR" ] && rm -rf "$TMP_DIR"
            [ -d "$DIR" ] && cd "$DIR"
            exit $1
        }; handle_exit() {
            case $1 in
                0) : ;;
                *) handle_err $1 ;;
            esac
            case ":$OUT" in
                :) set -- * ;;
                *) set -- "$OUT" ;;
            esac
            case ":$FILENAME" in
                :)
                    mv "$TMP_DIR"/"$1" "$DIR"/"$1"
                    printf "%bFILE:%b %b%s%b\n" \
                           "\033[1;32m" "\033[0m" "\033[1;37m" \
                           "$DIR/$1" "\033[0m"
                ;;
                *)
                    mv "$TMP_DIR"/"$1" "$DIR"/"${FILENAME}${1#"${1%.*}"}"
                    printf "%bFILE:%b %b%s%b\n" \
                           "\033[1;32m" "\033[0m" "\033[1;37m" \
                           "$DIR/${FILENAME}${1#"${1%.*}"}" "\033[0m"
                ;;
            esac
            [ -d "$TMP_DIR" ] && rm -rf "$TMP_DIR"
            [ -d "$DIR" ] && cd "$DIR"
        }; work() {
            DIR="$PWD"; TMP_DIR="$HOME"/.b81y7yt73627iyqguo9v3ryrand0mstr1ng
            [ -d "$TMP_DIR" ] && rm -rf "$TMP_DIR"
            mkdir "$TMP_DIR"; cd "$TMP_DIR"
        }
        trap "handle_err \$?" INT TERM
        trap "handle_exit \$?" EXIT
        set -e
        work;
    } # Provided variables: DIR; TMP_DIR.

    case ":$1" in
        :)
            printf "%bERROR:%b No audio file specified.\n" \
                   "\033[1;31m" "\033[0m"
            exit 2
        ;;
    esac
    case ":$2" in
        :)
            printf "%bERROR:%b No video file specified.\n" \
                   "\033[1;31m" "\033[0m"
            exit 2
        ;;
    esac
    case ":$3" in
        :)
            printf "%bERROR:%b No output name specified.\n" \
                   "\033[1;31m" "\033[0m"
            exit 2
        ;;
    esac

    AUDIO_IN="$DIR/$1"
    VIDEO_IN="$DIR/$2"

    OUT="$3"

    ARGS="-i \"$VIDEO_IN\""
    ARGS="$ARGS"" -i \"$AUDIO_IN\""
    ARGS="$ARGS"' -c:v copy -c:a copy -map 0:v:0 -map 1:a:0'
    ARGS="$ARGS"" \"$OUT\""

    eval "ffmpeg ${ARGS}"
)
ffmpeg_merge_mp4() (
    { # Variables expected to be present: OUT, FILENAME.
        handle_err() {
            trap - EXIT
            [ -d "$TMP_DIR" ] && rm -rf "$TMP_DIR"
            [ -d "$DIR" ] && cd "$DIR"
            exit $1
        }; handle_exit() {
            case $1 in
                0) : ;;
                *) handle_err $1 ;;
            esac
            case ":$OUT" in
                :) set -- * ;;
                *) set -- "$OUT" ;;
            esac
            case ":$FILENAME" in
                :)
                    mv "$TMP_DIR"/"$1" "$DIR"/"$1"
                    printf "%bFILE:%b %b%s%b\n" \
                           "\033[1;32m" "\033[0m" "\033[1;37m" \
                           "$DIR/$1" "\033[0m"
                ;;
                *)
                    mv "$TMP_DIR"/"$1" "$DIR"/"${FILENAME}${1#"${1%.*}"}"
                    printf "%bFILE:%b %b%s%b\n" \
                           "\033[1;32m" "\033[0m" "\033[1;37m" \
                           "$DIR/${FILENAME}${1#"${1%.*}"}" "\033[0m"
                ;;
            esac
            [ -d "$TMP_DIR" ] && rm -rf "$TMP_DIR"
            [ -d "$DIR" ] && cd "$DIR"
        }; work() {
            DIR="$PWD"; TMP_DIR="$HOME"/.b81y7yt73627iyqguo9v3ryrand0mstr1ng
            [ -d "$TMP_DIR" ] && rm -rf "$TMP_DIR"
            mkdir "$TMP_DIR"; cd "$TMP_DIR"
        }
        trap "handle_err \$?" INT TERM
        trap "handle_exit \$?" EXIT
        set -e
        work;
    } # Provided variables: DIR; TMP_DIR.

    case ":$1" in
        :)
            printf "%bERROR:%b No audio file specified.\n" \
                   "\033[1;31m" "\033[0m"
            exit 2
        ;;
    esac
    case ":$2" in
        :)
            printf "%bERROR:%b No video file specified.\n" \
                   "\033[1;31m" "\033[0m"
            exit 2
        ;;
    esac

    AUDIO_IN="$DIR/$1"
    VIDEO_IN="$DIR/$2"

    if [ "$3" ]; then
        case "$OUT" in
            *'.mp4') OUT="$3" ;;
            *) OUT="${3}.mp4" ;;
        esac
    else
        case "$2" in
            *'.mp4') OUT="$2" ;;
            *) OUT="${2}.mp4" ;;
        esac
    fi

    ARGS="-i \"$VIDEO_IN\""
    ARGS="$ARGS"" -i \"$AUDIO_IN\""
    ARGS="$ARGS"' -c:v copy -c:a copy -map 0:v:0 -map 1:a:0'
    ARGS="$ARGS"" \"$OUT\""

    eval "ffmpeg ${ARGS}"
)

# gpg
gpg_d() {
    gpg -o "${1%.gpg}" -d "$1"
}
gpg_e() {
    gpg -r 7D1F56FAD6FB86652A60BEE65BC3343816EAB179 --compress-algo none -e "$1"
}

# steam
:

# tar
tar_c() {
    tar --numeric-owner -cvpf "${1%.tar}".tar "${1%.tar}"
}
tar_e() {
    if [ ! -e "$1" ] && [ -e "$1".tar ]; then
        set -- "$1".tar
    fi

    tar --numeric-owner -xvpf "$1"
}

# youtube-dl
:

# yt-dlp
#
# Audio:
# --format 338 - opus/aac[?] ambisonic audio, contained in webm/mp4(m4a)[?]
# --format 258 - 384 kbps 5.1 aac, contained in mp4(m4a)
# --format 327 - 256 kbps 5.1 aac, contained in mp4(m4a)
# --format 141 - 256 kbps aac, contained in mp4(m4a); premium accounts only
# --format 256 - 192 kbps 5.1 aac, contained in mp4(m4a)
# --format 251 - normal opus, contained in webm
# --format 140 - 128 kbps aac, contained in mp4(m4a)
# --format 22  - {128|192} kbps aac premuxed 720p mp4
#
# Video:
# --format ::: - 4320p60 HDR vp9(.2), contained in webm
# --format ::: - 4320p60 HDR av1, contained in mp4
# --format ::: - 4320p30 HDR vp9(.2), contained in webm
# --format ::: - 4320p30 HDR av1, contained in webm
# --format ::: - 4320p60 vp9, contained in webm
# --format ::: - 4320p60 av1, contained in mp4
# --format ::: - 4320p30 vp9, contained in webm
# --format ::: - 4320p30 av1, contained in webm

# --format ::: - 2160p60 HDR vp9(.2), contained in webm
# --format ::: - 2160p60 HDR av1, contained in mp4
# --format ::: - 2160p30 HDR vp9(.2), contained in webm
# --format ::: - 2160p30 HDR av1, contained in webm
# --format ::: - 2160p60 vp9, contained in webm
# --format ::: - 2160p60 av1, contained in mp4
# --format ::: - 2160p30 vp9, contained in webm
# --format ::: - 2160p30 av1, contained in webm

# --format ::: - 1440p60 HDR vp9(.2), contained in webm
# --format ::: - 1440p60 HDR av1, contained in mp4
# --format ::: - 1440p30 HDR vp9(.2), contained in webm
# --format ::: - 1440p30 HDR av1, contained in webm
# --format ::: - 1440p60 vp9, contained in webm
# --format ::: - 1440p60 av1, contained in mp4
# --format ::: - 1440p30 vp9, contained in webm
# --format ::: - 1440p30 av1, contained in webm

# --format ::: - 1080p60 HDR vp9(.2), contained in webm
# --format ::: - 1080p60 HDR av1, contained in mp4
# --format ::: - 1080p30 HDR vp9(.2), contained in webm
# --format ::: - 1080p30 HDR av1, contained in webm
# --format ::: - 1080p60 vp9, contained in webm
# --format ::: - 1080p60 av1, contained in mp4
# --format ::: - 1080p60 avc1, contained in mp4
# --format ::: - 1080p30 vp9, contained in webm
# --format ::: - 1080p30 av1, contained in webm
# --format ::: - 1080p30 avc1, contained in mp4

# --format ::: - 720p60 HDR vp9(.2), contained in webm
# --format ::: - 720p60 HDR av1, contained in mp4
# --format ::: - 720p30 HDR vp9(.2), contained in webm
# --format ::: - 720p30 HDR av1, contained in webm
# --format ::: - 720p60 vp9, contained in webm
# --format ::: - 720p60 av1, contained in mp4
# --format ::: - 720p60 avc1, contained in mp4
# --format ::: - 720p30 vp9, contained in webm
# --format ::: - 720p30 av1, contained in webm
# --format ::: - 720p30 avc1, contained in mp4

# --format ::: - 480p60 HDR vp9(.2), contained in webm
# --format ::: - 480p60 HDR av1, contained in mp4
# --format ::: - 480p30 HDR vp9(.2), contained in webm
# --format ::: - 480p30 HDR av1, contained in webm
# --format ::: - 480p60 vp9, contained in webm
# --format ::: - 480p60 av1, contained in mp4
# --format ::: - 480p60 avc1, contained in mp4
# --format ::: - 480p30 vp9, contained in webm
# --format ::: - 480p30 av1, contained in webm
# --format ::: - 480p30 avc1, contained in mp4

# --format ::: - 360p60 HDR vp9(.2), contained in webm
# --format ::: - 360p60 HDR av1, contained in mp4
# --format ::: - 360p30 HDR vp9(.2), contained in webm
# --format ::: - 360p30 HDR av1, contained in webm
# --format ::: - 360p60 vp9, contained in webm
# --format ::: - 360p60 av1, contained in mp4
# --format ::: - 360p60 avc1, contained in mp4
# --format ::: - 360p30 vp9, contained in webm
# --format ::: - 360p30 av1, contained in webm
# --format ::: - 360p30 avc1, contained in mp4

# --format ::: - 240p60 HDR vp9(.2), contained in webm
# --format ::: - 240p60 HDR av1, contained in mp4
# --format ::: - 240p30 HDR vp9(.2), contained in webm
# --format ::: - 240p30 HDR av1, contained in webm
# --format ::: - 240p60 vp9, contained in webm
# --format ::: - 240p60 av1, contained in mp4
# --format ::: - 240p60 avc1, contained in mp4
# --format ::: - 240p30 vp9, contained in webm
# --format ::: - 240p30 av1, contained in webm
# --format ::: - 240p30 avc1, contained in mp4

# --format ::: - 144p60 HDR vp9(.2), contained in webm
# --format ::: - 144p60 HDR av1, contained in mp4
# --format ::: - 144p30 HDR vp9(.2), contained in webm
# --format ::: - 144p30 HDR av1, contained in webm
# --format ::: - 144p60 vp9, contained in webm
# --format ::: - 144p60 av1, contained in mp4
# --format ::: - 144p60 avc1, contained in mp4
# --format ::: - 144p30 vp9, contained in webm
# --format ::: - 144p30 av1, contained in webm
# --format ::: - 144p30 avc1, contained in mp4
#
# Above formats are YouTube-specific.
# -> Audio formats ordered by quality;
#    when same quality, by psychoacoustic model (codec).
#    --
#    NOTE[1]: Opus should be better, so it is preferred over AAC when available.
# -> Video formats ordered by quality;
#    when same quality, by various parameters (codec).
#    --
#    NOTE[1]: VP9 has better color, so it is preferred over AV1 when available.
#             Source: my eyes + window-over-window comparison.
#    NOTE[2]: At testing phase (2018-????), AV1 had 10-20% better bitrate over
#             VP9. For such videos, AV1 might be the bettter choice overall.
#             Note 1 still stands, though.
#
# FFmpeg code references:
# https://trac.ffmpeg.org/wiki
# https://trac.ffmpeg.org/wiki/Encode/HighQualityAudio
# https://trac.ffmpeg.org/wiki/FFmpeg%20and%20the%20SoX%20Resampler
ytdlp_a() (
    { # Variables expected to be present: OUT, FILENAME.
        handle_err() {
            trap - EXIT
            [ -d "$TMP_DIR" ] && rm -rf "$TMP_DIR"
            [ -d "$DIR" ] && cd "$DIR"
            exit $1
        }; handle_exit() {
            case $1 in
                0) : ;;
                *) handle_err $1 ;;
            esac
            case ":$OUT" in
                :) set -- * ;;
                *) set -- "$OUT" ;;
            esac
            case ":$FILENAME" in
                :)
                    mv "$TMP_DIR"/"$1" "$DIR"/"$1"
                    printf "%bFILE:%b %b%s%b\n" \
                           "\033[1;32m" "\033[0m" "\033[1;37m" \
                           "$DIR/$1" "\033[0m"
                ;;
                *)
                    mv "$TMP_DIR"/"$1" "$DIR"/"${FILENAME}${1#"${1%.*}"}"
                    printf "%bFILE:%b %b%s%b\n" \
                           "\033[1;32m" "\033[0m" "\033[1;37m" \
                           "$DIR/${FILENAME}${1#"${1%.*}"}" "\033[0m"
                ;;
            esac
            [ -d "$TMP_DIR" ] && rm -rf "$TMP_DIR"
            [ -d "$DIR" ] && cd "$DIR"
        }; work() {
            DIR="$PWD"; TMP_DIR="$HOME"/.b81y7yt73627iyqguo9v3ryrand0mstr1ng
            [ -d "$TMP_DIR" ] && rm -rf "$TMP_DIR"
            mkdir "$TMP_DIR"; cd "$TMP_DIR"
        }
        trap "handle_err \$?" INT TERM
        trap "handle_exit \$?" EXIT
        set -e
        work;
    } # Provided variables: DIR; TMP_DIR.

    case ":$1" in
        :)
            printf "%bERROR:%b No URL specified.\n" \
                   "\033[1;31m" "\033[0m"
            exit 2
        ;;
    esac

    URL="$1";
    case ":$2" in
        :) : ;;
        *) FILENAME="$2" ;;
    esac

    yt-dlp_ --cookies-from-browser firefox \
            --extractor-args "youtube:formats=missing_pot" \
            --format 338/258/327/141/256/251/140/22 \
            "$URL"

    IN=$(
        set -- *
        printf "%s" "$1"
    )
    OUT=$(
        case "$IN" in
            *.webm) printf "%s" "${IN%.webm}.opus" ;;
            *.m4a|*.mp4) printf "%s" "${IN%.*}.aac" ;;
            *)
                printf "%bYOUTUBE DID SOMETHING UNEXPECTED.%b\n"
                       "\033[1;31m" "\033[0m" 1>&2
                exit 1
            ;;
        esac
    )

    ARGS='-vn'
    ARGS="$ARGS"' -c:a copy'

    ffmpeg -i "$IN" ${ARGS} "$OUT"
)
ytdlp_a_opus() (
    { # Variables expected to be present: OUT, FILENAME.
        handle_err() {
            trap - EXIT
            [ -d "$TMP_DIR" ] && rm -rf "$TMP_DIR"
            [ -d "$DIR" ] && cd "$DIR"
            exit $1
        }; handle_exit() {
            case $1 in
                0) : ;;
                *) handle_err $1 ;;
            esac
            case ":$OUT" in
                :) set -- * ;;
                *) set -- "$OUT" ;;
            esac
            case ":$FILENAME" in
                :)
                    mv "$TMP_DIR"/"$1" "$DIR"/"$1"
                    printf "%bFILE:%b %b%s%b\n" \
                           "\033[1;32m" "\033[0m" "\033[1;37m" \
                           "$DIR/$1" "\033[0m"
                ;;
                *)
                    mv "$TMP_DIR"/"$1" "$DIR"/"${FILENAME}${1#"${1%.*}"}"
                    printf "%bFILE:%b %b%s%b\n" \
                           "\033[1;32m" "\033[0m" "\033[1;37m" \
                           "$DIR/${FILENAME}${1#"${1%.*}"}" "\033[0m"
                ;;
            esac
            [ -d "$TMP_DIR" ] && rm -rf "$TMP_DIR"
            [ -d "$DIR" ] && cd "$DIR"
        }; work() {
            DIR="$PWD"; TMP_DIR="$HOME"/.b81y7yt73627iyqguo9v3ryrand0mstr1ng
            [ -d "$TMP_DIR" ] && rm -rf "$TMP_DIR"
            mkdir "$TMP_DIR"; cd "$TMP_DIR"
        }
        trap "handle_err \$?" INT TERM
        trap "handle_exit \$?" EXIT
        set -e
        work;
    } # Provided variables: DIR; TMP_DIR.

    :
)
OPUS_CODE_TMP() {
    AUDIO_IN=$(
        set -- *
        printf "%s" "$1"
    )

    case "$AUDIO_IN" in
        *.opus) exit 0 ;;
        *) AUDIO_OUT=$(printf "%s" "${AUDIO_IN%.*}.opus") ;;
    esac

    ARGS=

    ffmpeg -i "$AUDIO_IN" ${ARGS} "$AUDIO_OUT"
}
ytdlp_a_aac() (
    :
)
ytdlp_a_mp3() (
    :
)
ytdlp_a_wav() (
    :
)
ytdlp_a_flac() (
    :
)
ytdlp_s() (
    { # Variables expected to be present: OUT, FILENAME.
        handle_err() {
            trap - EXIT
            [ -d "$TMP_DIR" ] && rm -rf "$TMP_DIR"
            [ -d "$DIR" ] && cd "$DIR"
            exit $1
        }; handle_exit() {
            case $1 in
                0) : ;;
                *) handle_err $1 ;;
            esac
            case ":$OUT" in
                :) set -- * ;;
                *) set -- "$OUT" ;;
            esac
            case ":$FILENAME" in
                :)
                    mv "$TMP_DIR"/"$1" "$DIR"/"$1"
                    printf "%bFILE:%b %b%s%b\n" \
                           "\033[1;32m" "\033[0m" "\033[1;37m" \
                           "$DIR/$1" "\033[0m"
                ;;
                *)
                    mv "$TMP_DIR"/"$1" "$DIR"/"${FILENAME}${1#"${1%.*}"}"
                    printf "%bFILE:%b %b%s%b\n" \
                           "\033[1;32m" "\033[0m" "\033[1;37m" \
                           "$DIR/${FILENAME}${1#"${1%.*}"}" "\033[0m"
                ;;
            esac
            [ -d "$TMP_DIR" ] && rm -rf "$TMP_DIR"
            [ -d "$DIR" ] && cd "$DIR"
        }; work() {
            DIR="$PWD"; TMP_DIR="$HOME"/.b81y7yt73627iyqguo9v3ryrand0mstr1ng
            [ -d "$TMP_DIR" ] && rm -rf "$TMP_DIR"
            mkdir "$TMP_DIR"; cd "$TMP_DIR"
        }
        trap "handle_err \$?" INT TERM
        trap "handle_exit \$?" EXIT
        set -e
        work;
    } # Provided variables: DIR; TMP_DIR.

    case ":$1" in
        :)
            printf "%bERROR:%b No URL specified.\n" \
                   "\033[1;31m" "\033[0m"
            exit 2
        ;;
    esac

    URL="$1";
    case ":$2" in
        :) : ;;
        *) FILENAME="$2" ;;
    esac

    ARGS='--write-sub'
    ARGS="$ARGS"' --skip-download'

    yt-dlp ${ARGS} "$URL"
)
ytdlp_s_srt() (
    { # Variables expected to be present: OUT, FILENAME.
        handle_err() {
            trap - EXIT
            [ -d "$TMP_DIR" ] && rm -rf "$TMP_DIR"
            [ -d "$DIR" ] && cd "$DIR"
            exit $1
        }; handle_exit() {
            case $1 in
                0) : ;;
                *) handle_err $1 ;;
            esac
            case ":$OUT" in
                :) set -- * ;;
                *) set -- "$OUT" ;;
            esac
            case ":$FILENAME" in
                :)
                    mv "$TMP_DIR"/"$1" "$DIR"/"$1"
                    printf "%bFILE:%b %b%s%b\n" \
                           "\033[1;32m" "\033[0m" "\033[1;37m" \
                           "$DIR/$1" "\033[0m"
                ;;
                *)
                    mv "$TMP_DIR"/"$1" "$DIR"/"${FILENAME}${1#"${1%.*}"}"
                    printf "%bFILE:%b %b%s%b\n" \
                           "\033[1;32m" "\033[0m" "\033[1;37m" \
                           "$DIR/${FILENAME}${1#"${1%.*}"}" "\033[0m"
                ;;
            esac
            [ -d "$TMP_DIR" ] && rm -rf "$TMP_DIR"
            [ -d "$DIR" ] && cd "$DIR"
        }; work() {
            DIR="$PWD"; TMP_DIR="$HOME"/.b81y7yt73627iyqguo9v3ryrand0mstr1ng
            [ -d "$TMP_DIR" ] && rm -rf "$TMP_DIR"
            mkdir "$TMP_DIR"; cd "$TMP_DIR"
        }
        trap "handle_err \$?" INT TERM
        trap "handle_exit \$?" EXIT
        set -e
        work;
    } # Provided variables: DIR; TMP_DIR.

    case ":$1" in
        :)
            printf "%bERROR:%b No URL specified.\n" \
                   "\033[1;31m" "\033[0m"
            exit 2
        ;;
    esac

    URL="$1";
    case ":$2" in
        :) : ;;
        *) FILENAME="$2" ;;
    esac

    ARGS='--write-sub'
    ARGS="$ARGS"' --skip-download'

    yt-dlp ${ARGS} "$URL"

    IN=$(
        set -- *
        printf "%s" "$1"
    )
    OUT=$(
        printf "%s" "${IN%.*}.srt"
    )

    ffmpeg -i "$IN" "$OUT"
)
ytdlp_s_auto() (
    { # Variables expected to be present: OUT, FILENAME.
        handle_err() {
            trap - EXIT
            [ -d "$TMP_DIR" ] && rm -rf "$TMP_DIR"
            [ -d "$DIR" ] && cd "$DIR"
            exit $1
        }; handle_exit() {
            case $1 in
                0) : ;;
                *) handle_err $1 ;;
            esac
            case ":$OUT" in
                :) set -- * ;;
                *) set -- "$OUT" ;;
            esac
            case ":$FILENAME" in
                :)
                    mv "$TMP_DIR"/"$1" "$DIR"/"$1"
                    printf "%bFILE:%b %b%s%b\n" \
                           "\033[1;32m" "\033[0m" "\033[1;37m" \
                           "$DIR/$1" "\033[0m"
                ;;
                *)
                    mv "$TMP_DIR"/"$1" "$DIR"/"${FILENAME}${1#"${1%.*}"}"
                    printf "%bFILE:%b %b%s%b\n" \
                           "\033[1;32m" "\033[0m" "\033[1;37m" \
                           "$DIR/${FILENAME}${1#"${1%.*}"}" "\033[0m"
                ;;
            esac
            [ -d "$TMP_DIR" ] && rm -rf "$TMP_DIR"
            [ -d "$DIR" ] && cd "$DIR"
        }; work() {
            DIR="$PWD"; TMP_DIR="$HOME"/.b81y7yt73627iyqguo9v3ryrand0mstr1ng
            [ -d "$TMP_DIR" ] && rm -rf "$TMP_DIR"
            mkdir "$TMP_DIR"; cd "$TMP_DIR"
        }
        trap "handle_err \$?" INT TERM
        trap "handle_exit \$?" EXIT
        set -e
        work;
    } # Provided variables: DIR; TMP_DIR.

    case ":$1" in
        :)
            printf "%bERROR:%b No URL specified.\n" \
                   "\033[1;31m" "\033[0m"
            exit 2
        ;;
    esac

    URL="$1";
    case ":$2" in
        :) : ;;
        *) FILENAME="$2" ;;
    esac

    ARGS='--write-auto-sub'
    ARGS="$ARGS"' --skip-download'

    yt-dlp ${ARGS} "$URL"
)
ytdlp_s_auto_srt() (
    { # Variables expected to be present: OUT, FILENAME.
        handle_err() {
            trap - EXIT
            [ -d "$TMP_DIR" ] && rm -rf "$TMP_DIR"
            [ -d "$DIR" ] && cd "$DIR"
            exit $1
        }; handle_exit() {
            case $1 in
                0) : ;;
                *) handle_err $1 ;;
            esac
            case ":$OUT" in
                :) set -- * ;;
                *) set -- "$OUT" ;;
            esac
            case ":$FILENAME" in
                :)
                    mv "$TMP_DIR"/"$1" "$DIR"/"$1"
                    printf "%bFILE:%b %b%s%b\n" \
                           "\033[1;32m" "\033[0m" "\033[1;37m" \
                           "$DIR/$1" "\033[0m"
                ;;
                *)
                    mv "$TMP_DIR"/"$1" "$DIR"/"${FILENAME}${1#"${1%.*}"}"
                    printf "%bFILE:%b %b%s%b\n" \
                           "\033[1;32m" "\033[0m" "\033[1;37m" \
                           "$DIR/${FILENAME}${1#"${1%.*}"}" "\033[0m"
                ;;
            esac
            [ -d "$TMP_DIR" ] && rm -rf "$TMP_DIR"
            [ -d "$DIR" ] && cd "$DIR"
        }; work() {
            DIR="$PWD"; TMP_DIR="$HOME"/.b81y7yt73627iyqguo9v3ryrand0mstr1ng
            [ -d "$TMP_DIR" ] && rm -rf "$TMP_DIR"
            mkdir "$TMP_DIR"; cd "$TMP_DIR"
        }
        trap "handle_err \$?" INT TERM
        trap "handle_exit \$?" EXIT
        set -e
        work;
    } # Provided variables: DIR; TMP_DIR.

    case ":$1" in
        :)
            printf "%bERROR:%b No URL specified.\n" \
                   "\033[1;31m" "\033[0m"
            exit 2
        ;;
    esac

    URL="$1";
    case ":$2" in
        :) : ;;
        *) FILENAME="$2" ;;
    esac

    ARGS='--write-auto-sub'
    ARGS="$ARGS"' --skip-download'

    yt-dlp ${ARGS} "$URL"

    IN=$(
        set -- *
        printf "%s" "$1"
    )
    OUT=$(
        printf "%s" "${IN%.*}.srt"
    )

    ffmpeg -i "$IN" "$OUT"
)
ytdlp_ramfs() (
    [ -e /mnt/ramdisk ] || {
        echo 'fail: /mnt/ramdisk does not exist'; return 0
    }
    yt-dlp --no-part --no-cache-dir -P /mnt/ramdisk "$@"
)

# unfinished
ytdlp_v() (
    { # Variables expected to be present: OUT, FILENAME.
        handle_err() {
            trap - EXIT
            [ -d "$TMP_DIR" ] && rm -rf "$TMP_DIR"
            [ -d "$DIR" ] && cd "$DIR"
            exit $1
        }; handle_exit() {
            case $1 in
                0) : ;;
                *) handle_err $1 ;;
            esac
            case ":$OUT" in
                :) set -- * ;;
                *) set -- "$OUT" ;;
            esac
            case ":$FILENAME" in
                :)
                    mv "$TMP_DIR"/"$1" "$DIR"/"$1"
                    printf "%bFILE:%b %b%s%b\n" \
                           "\033[1;32m" "\033[0m" "\033[1;37m" \
                           "$DIR/$1" "\033[0m"
                ;;
                *)
                    mv "$TMP_DIR"/"$1" "$DIR"/"${FILENAME}${1#"${1%.*}"}"
                    printf "%bFILE:%b %b%s%b\n" \
                           "\033[1;32m" "\033[0m" "\033[1;37m" \
                           "$DIR/${FILENAME}${1#"${1%.*}"}" "\033[0m"
                ;;
            esac
            [ -d "$TMP_DIR" ] && rm -rf "$TMP_DIR"
            [ -d "$DIR" ] && cd "$DIR"
        }; work() {
            DIR="$PWD"; TMP_DIR="$HOME"/.b81y7yt73627iyqguo9v3ryrand0mstr1ng
            [ -d "$TMP_DIR" ] && rm -rf "$TMP_DIR"
            mkdir "$TMP_DIR"; cd "$TMP_DIR"
        }
        trap "handle_err \$?" INT TERM
        trap "handle_exit \$?" EXIT
        set -e
        work;
    } # Provided variables: DIR; TMP_DIR.

    :
)
V_CODE_TMP() {
    URL="$1"; [ "$2" ] && FILENAME="$2" || FILENAME=

    ARGS='--format'
    ARGS="$ARGS"' 338/258/327/141/256/251/140/22'

    yt-dlp ${ARGS} "$URL"

    AUDIO_IN=$(
        set -- *
        printf "%s" "$1"
    )
    AUDIO_OUT=$(
        case "$AUDIO_IN" in
            *.webm) printf "%s" "${AUDIO_IN%.webm}.opus" ;;
            *.m4a|*.mp4) printf "%s" "${AUDIO_IN%.*}.aac" ;;
            *)
                printf "%bYOUTUBE DID SOMETHING UNEXPECTED.%b\n" "\033[1;31m" \
                                                                 "\033[0m" 1>&2
                exit 1
            ;;
        esac
    )

    ARGS='-vn'
    ARGS="$ARGS"' -c:a copy'

    ffmpeg -i "$AUDIO_IN" ${ARGS} "$AUDIO_OUT"

    ARGS='--format'
    ARGS="$ARGS"' bestvideo'

    yt-dlp ${ARGS} "$URL"

    VIDEO_IN=$(
        set -- *
        [ "$1" = "$AUDIO_OUT" ] && printf "%s" "$2" || printf "%s" "$1"
    )
    VIDEO_OUT=$(
        :
    )

    :
}
ytdlp_v_1080() (
    :
)
ytdlp_v_webm() (
    :
)
ytdlp_v_webm_1080() (
    :
)
ytdlp_v_mp4() (
    :
)
ytdlp_v_mp4_1080() (
    :
)
ytdlp_v_mkv() (
    :
)
ytdlp_v_mkv_1080() (
    :
)
ytdlp_v_ogg() (
    :
)
ytdlp_v_ogg_1080() (
    :
)
steamwinerun() ( WINEPREFIX="$HOME"/.steam/root/steamapps/compatdata/$1/pfx wine "$2"; )
dgrd() (
    if [ ! "$1" ] || [ ! "$2" ]; then
        printf "%s\n" 'STEP (1-X) = $1'
        printf "%s\n" 'NAME = $2+'
        exit 2
    fi

    STEP="$1"; shift
    DIR=/var/cache/pacman/pkg
    OUT_FLAG=0

    while [ "$#" -ge 1 ]; do
        NAME="$1"
        FILES=$(
            find "$DIR" -name "$NAME"-[0123456789]*.zst -printf "%T+ %p\n" | \
            sort -r
        )

        if [ ! "$FILES" ]; then
            printf "%s\n" 'ERR NO FILES. NAME=%s' "$NAME"
            exit 1
        fi

        x=0; while IFS= read -r LINE; do
            [ "$x" = "$STEP" ] || { x=$((x + 1)); continue; }

            LINE="${LINE#* }"
            if [ "$OUT_FLAG" = 0 ]; then
                printf "%s\n" 'pacman -U \'
                OUT_FLAG=1
            fi
            if [ "$2" ]; then
                printf "%s %s\n" "$LINE" '\'
            else
                printf "%s\n" "$LINE"
            fi
            shift; continue 2
        done <<EOF
$FILES
EOF

        printf "ERR PKG DGRD STEP NO EXIST. x=%s\n" "$x"
        exit 1
    done
)
ytv() { youtube-dl --format bestvideo+bestaudio "$1"; }
ytv1080() { youtube-dl --format bestvideo[height<=1080]+bestaudio "$1"; }
ipv6disable() { su -c 'sysctl -w net.ipv6.conf.all.disable_ipv6=1; sysctl -w net.ipv6.conf.default.disable_ipv6=1'; }
ipv6enable() { su -c 'sysctl -w net.ipv6.conf.all.disable_ipv6=0; sysctl -w net.ipv6.conf.default.disable_ipv6=0'; }
_BASH_FUNCTIONS

    __file_write;

    FILE_PATH \
<<_BASHRC
$home/.bashrc
_BASHRC

    FILE \
<<'_BASHRC'
# Don't parse .bashrc if not running interactively
[[ $- != *i* ]] && return

PS1=\
'\[\033[1;32m\]['\
"\$(\
RC=\$?; \
[ "\$RC" -eq 0 ] \
    && printf "%s%d" '\[\033[1;32m\]' "\$RC" \
    || printf "%s%d" '\[\033[1;33m\]' "\$RC" \
)"' '\
'\[\033[1;36m\]\u@\h '\
'\[\033[1;31m\]\W\[\033[1;32m\]]\$\[\033[0m\] '

export HISTCONTROL=ignoreboth:erasedups
export PATH="${PATH}:$HOME/.local/bin:$HOME/scripts"
export EDITOR=nano

alias ls='ls --color'
alias grep='grep --color=always'
alias ip='ip --color'
alias clr='tput reset; stty -ixon susp undef'
alias gfix='git add .; git commit --amend --date="now" -s'
alias gfixf='git add .; git commit --amend --date="now" --no-edit -s'
alias gchk='git diff --check HEAD~10'

# Source useful custom functions
[ -f "$HOME"/.bash_functions ] && . "$HOME"/.bash_functions

# '-ixon': Disable "Ctrl + S"; WHY IS THIS STILL DEFAULT?
# 'susp undef': Disable "Ctrl + Z"
stty -ixon susp undef
_BASHRC

    __file_write;
}

_bluez_conf() {
    FILE_PATH \
<<'MAIN_CONF'
/etc/bluetooth/main.conf
MAIN_CONF

    FILE \
<<'MAIN_CONF'
[General]
Name = gUcciestBlueZ420
DiscoverableTimeout = 0
FastConnectable = true

[Policy]
AutoEnable=false
ReconnectAttempts=3
ReconnectIntervals=2,8,16
MAIN_CONF

    __file_write_overwrite;
}

# RTC clock sync using the closest NTP server (pool.ntp.org)
_clk_sync() {
    __cmd ntpd -gGLnq pool.ntp.org
    __cmd hwclock -w
}

# Software configuration - stage 1
#
# State-of-the-art config:
# > never overwrites or overwritten.
#
# Run stage 1 at any time of -- initial -- system configuration with:
# > the full filesystem mounted and user dir provided ($home; $user).
#
# The following functions shall -- only -- be defined in _conf_4() if they
# are influenced by utility switches; never to be defined in any other _conf_*()
# functions.
_conf_1() {
    _alsa_conf;
    _bash_conf;
    _doas_conf;
    _face_bin;
    _fontconfig_conf;
    _git_conf;
    _gtk_conf;
    _hostname;
    _imv_conf;
    _iwd_conf;
    _kitty_conf;
    _kvantum_conf;
    _moc_conf;
    _modprobe_conf;
    _mpv_conf;
    _mutt_conf;
    _nano_conf;
    _openal_conf;
    _pipewire_conf;
    _pipewire_media_session_conf;
    _ranger_conf;
    _sudo_conf;
    _sway_conf;
    _swaylock_conf;
    _sysctl_conf;
    _xdg_conf;
}

# Software configuration - stage 2
#
# Config might:
# > overwrite or be overwritten.
# > depend on installed software.
#
# Function might:
# > require $force_write
#
# Run stage 2 at any time of -- desired -- system configuration with:
# > the full filesystem mounted and user dir provided ($home; $user).
# > the output parsed to understand what is not yet being configured.
#
# The following functions shall -- only -- be defined in _conf_4() if they
# are influenced by utility switches; never to be defined in any other _conf_*()
# functions.
_conf_2() {
    _autostart;
    _env;
    _featherpad_conf;
    _hosts;
    _locale;
    _reflector;
    _resolv_conf;
    _sh;
    _tz;

    if file '/etc/dhcpcd.conf'; then
        _dhcpcd_conf;
    else
        _info -yellow - 'Skipped _dhcpcd_conf()'
    fi

    if file '/etc/dnsmasq.conf'; then
        _dnsmasq_conf;
    else
        _info -yellow - 'Skipped _dnsmasq_conf()'
    fi

    if file '/etc/gai.conf'; then
        _gai_conf;
    else
        _info -yellow - 'Skipped _gai_conf()'
    fi

    if cmd 'grub-install' && cmd 'grub-mkconfig'; then
        _grub;

        if file '/etc/default/grub'; then
            _grub_conf;
        else
            _info -yellow - 'Skipped _grub_conf()'
        fi
    else
        _info -yellow - 'Skipped _grub()'
        _info -yellow - 'Skipped _grub_conf()'
    fi

    if file '/etc/mkinitcpio.conf'; then
        _initramfs_conf;
    else
        _info -yellow - 'Skipped _initramfs_conf()'
    fi

    if file '/etc/makepkg.conf'; then
        _makepkg_conf;
    else
        _info -yellow - 'Skipped _makepkg_conf()'
    fi

    if file '/etc/pacman.conf'; then
        _pacman_conf;
    else
        _info -yellow - 'Skipped _pacman_conf()'
    fi

    if file '/etc/security/faillock.conf' && \
       file '/etc/login.defs' && \
       file '/etc/pam.d/su' && \
       file '/etc/pam.d/system-auth'; then
        _pam_conf;
    else
        _info -yellow - 'Skipped _pam_conf()'
    fi
}

# Software configuration - stage 3
#
# Config might:
# > overwrite or be overwritten.
# > depend on specific installed software.
# > depend on ever-executed software.
#
# Function might:
# > require $force_write
#
# Run stage 3 at any time of -- desired -- system configuration with:
# > the full filesystem mounted and user dir provided ($home; $user).
# > the output parsed to understand what is not yet being configured.
#
# The following functions shall -- only -- be defined in _conf_4() if they
# are influenced by utility switches; never to be defined in any other _conf_*()
# functions.
_conf_3() {
    if file '/etc/bluetooth/main.conf'; then
        _bluez_conf;
    else
        _info -yellow - 'Skipped _bluez_conf()'
    fi

    if file "$home"/'.mozilla/firefox/profiles.ini'; then
        _firefox_conf;
    else
        _info -yellow - 'Skipped _firefox_conf()'
    fi

    if file '/etc/fuse.conf'; then
        _fuse_conf;
    else
        _info -yellow - 'Skipped _fuse_conf()'
    fi
}

# Software configuration - stage 4
#
# Config is:
# > influenced by utility switches.
#
# Config might:
# > overwrite or be overwritten.
# > depend on specific installed software.
# > depend on ever-executed software.
#
# Function might:
# > require $force_write
#
# Run stage 4 at any time of -- desired -- system configuration with:
# > the full filesystem mounted and user dir provided ($home; $user).
# > the intent of reproducing the currently declared configuration.
_conf_4() {
    _alsa_conf;
    _autostart;
    _env;
    _hostname;
    _hosts;
    _iwd_conf;
    _pipewire_conf;
    _pipewire_media_session_conf;
    _reflector;
    _resolv_conf;
    _sh;
    _sway_conf;
    _tz;

    if file '/etc/dhcpcd.conf'; then
        _dhcpcd_conf;
    fi

    if file '/etc/dnsmasq.conf'; then
        _dnsmasq_conf;
    fi

    if file '/etc/gai.conf'; then
        _gai_conf;
    fi

    if cmd 'grub-mkconfig' && file '/etc/default/grub'; then
        _grub_conf;
    fi

    if file '/etc/mkinitcpio.conf'; then
        _initramfs_conf;
    fi
}

_dhcpcd_conf() {
    FILE_PATH \
<<'DHCPCD_CONF'
/etc/dhcpcd.conf
DHCPCD_CONF

    if [ "$ipv6" = 1 ]; then
        FILE \
<<'DHCPCD_CONF'
static domain_name_servers=::1 127.0.0.1
slaac private
duid
noipv4ll

DHCPCD_CONF
    else
        FILE \
<<'DHCPCD_CONF'
static domain_name_servers=127.0.0.1
slaac hwaddr
clientid
noipv6rs
noipv6

DHCPCD_CONF
    fi

    FILE \
<<'DHCPCD_CONF'
option classless_static_routes
option interface_mtu
option host_name
option rapid_commit
require dhcp_server_identifier
vendorclassid

noarp
nohook resolv.conf
DHCPCD_CONF

    __file_write_overwrite;
}

# DNS stub resolver configuration
_dnsmasq_conf() {
    FILE_PATH \
<<'DNSMASQ_CONF'
/etc/dnsmasq.conf
DNSMASQ_CONF

    FILE \
<<'DNSMASQ_CONF'
bind-interfaces
cache-size=2048
domain-needed
bogus-priv
no-resolv
no-poll
no-hosts
no-negcache
dnssec
dnssec-check-unsigned
trust-anchor=.,20326,8,2,E06D44B80B8F1D39A95C0B0D7C65D08458E880409BBC683457104237C7F8EC8D
trust-anchor=.,38696,8,2,683D2D0ACB8C9B712A1948B27F741219298D0A450D612C483AF444A4C0FB2B16
all-servers
DNSMASQ_CONF

    if [ "$ipv6" = 1 ]; then
        FILE \
<<'DNSMASQ_CONF'
listen-address=::1,127.0.0.1
server=2606:4700:4700::1111
server=2606:4700:4700::1001
server=2620:119:35::35
server=2620:119:53::53
server=2001:4860:4860::8888
server=2001:4860:4860::8844
server=2620:fe::fe
server=2620:fe::9
server=1.1.1.1
server=1.0.0.1
server=208.67.222.222
server=208.67.220.220
server=8.8.8.8
server=8.8.4.4
server=9.9.9.9
server=149.112.112.112
DNSMASQ_CONF
    else
        FILE \
<<'DNSMASQ_CONF'
listen-address=127.0.0.1
server=1.1.1.1
server=1.0.0.1
server=208.67.222.222
server=208.67.220.220
server=8.8.8.8
server=8.8.4.4
server=9.9.9.9
server=149.112.112.112
DNSMASQ_CONF
    fi

    __file_write_overwrite;
}

_doas_conf() {
    FILE_PATH \
<<'DOAS_CONF'
/etc/doas.conf
DOAS_CONF

    FILE \
<<'DOAS_CONF'
permit persist :wheel as root
DOAS_CONF

    __file_write;
    __loc_chmod '0400'
}

_env() {
    FILE_PATH \
<<BROWSER
$home/.syscfg_env/browser
BROWSER

    if [ "$browser" = firefox ] && [ "$display_server" = wayland ]; then
        FILE \
<<'BROWSER'
MOZ_ENABLE_WAYLAND=1
BROWSER

        __file_write_overwrite;
    elif [ "$browser" = none ] || [ ! "$browser" ] || \
        [ "$display_server" = none ] || [ ! "$display_server" ]; then
        __loc_delete;
    fi

    FILE_PATH \
<<QT_THEME
$home/.syscfg_env/qt_theme
QT_THEME

    if [ "$qt_theme" = kvantum ]; then
        FILE \
<<'QT_THEME'
QT_STYLE_OVERRIDE=kvantum
QT_THEME

        __file_write_overwrite;
    elif [ "$qt_theme" = none ] || [ ! "$qt_theme" ]; then
        __loc_delete;
    fi

    FILE_PATH \
<<DISPLAY_SERVER
$home/.syscfg_env/display_server
DISPLAY_SERVER

    if [ "$display_server" = wayland ]; then
        FILE \
<<'DISPLAY_SERVER'
QT_QPA_PLATFORM=wayland
QT_WAYLAND_DISABLE_WINDOWDECORATION=1
SDL_VIDEODRIVER=wayland
GDK_BACKEND=wayland
GTK_A11Y=none
DISPLAY_SERVER

        if [ "$portal" = 1 ]; then
            FILE \
<<'DISPLAY_SERVER'
GTK_USE_PORTAL=1
DISPLAY_SERVER
        else
            FILE \
<<'DISPLAY_SERVER'
GTK_USE_PORTAL=0
DISPLAY_SERVER
        fi

        __file_write_overwrite;
    elif [ "$display_server" = none ] || [ ! "$display_server" ]; then
        __loc_delete;
    fi

    FILE_PATH \
<<WM
$home/.syscfg_env/wm
WM

    if [ "$wm" = sway ]; then
        FILE \
<<'WM'
XDG_CURRENT_DESKTOP=sway
XDG_SESSION_DESKTOP=sway
DESKTOP_SESSION=sway
WM

        __file_write_overwrite;
    elif [ "$wm" = none ] || [ ! "$wm" ]; then
        __loc_delete;
    fi

    FILE_PATH \
<<_BASH_PROFILE
$home/.bash_profile
_BASH_PROFILE

    FILE \
<<'_BASH_PROFILE'
set -a; for file in "$HOME"/.syscfg_env/*; do
    . "$file"
done; set +a
_BASH_PROFILE

    if [ "$wm" = sway ]; then
        FILE \
<<'_BASH_PROFILE'

if [ -z "$DISPLAY" ] && [ "$(tty)" = '/dev/tty1' ]; then
    if command -v sway > /dev/null 2>&1; then
        exec sway > /var/log/sway.log 2>&1
    fi
fi
_BASH_PROFILE
    fi

    __file_write;

    if [ "$wm" = sway ]; then
        FILE_PATH \
<<'SWAY_LOG'
/var/log/sway.log
SWAY_LOG

        __loc_empty;
        __loc_chmod '0644'
        __loc_chown "$user"
    else
        FILE_PATH \
<<'SWAY_LOG'
/var/log/sway.log
SWAY_LOG

        __loc_delete;
    fi
}

# .face png in $home (user $HOME); some applications use this file.
_face_bin() {
    FILE_PATH \
<<_FACE
$home/.face
_FACE

    FILE_octal \
<<'_FACE'
\0211\0120\0116\0107\0015\0012\0032\0012\0000\0000\0000\0015\0111\0110\0104\0122\0000\0000\0000\0144\0000\0000\0000\0144\0010\0002\0000\0000\0000\0377\0200\0002\0003\0000\0000\0000\0003\0163\0102\0111\0124\0010\0010\0010\0333\0341\0117\0340\0000\0000\0010\0010\0111\0104\0101\0124\0170\0234\0355\0235\0117\0150\0023\0117\0024\0307\0137\0252\0325\0370\0277\0326\0077\0304\0077\0075\0010\0125\0243\0124\0232\0050\0005\0251\0010\0332\0136\0104\0004\0053\0036\0104\0301\0322\0256\0005\0017\0005\0351\0101\0017\0036\0212\0207\0212\0050\0071\0064\0170\0116\0215\0030\0355\0105\0321\0252\0330\0253\0101\0244\0212\0042\0046\0324\0103\0113\0212\0177\0132\0264\0242\0025\0135\0250\0156\0252\0326\0375\0035\0346\0327\0141\0234\0375\0237\0314\0314\0116\0045\0237\0123\0166\0166\0063\0373\0366\0333\0231\0267\0157\0346\0315\0244\0001\0135\0327\0241\0204\0073\0312\0374\0066\0140\0066\0121\0022\0313\0003\0045\0261\0074\0120\0022\0313\0003\0045\0261\0074\0060\0013\0304\0112\0247\0323\0175\0175\0175\0176\0133\0001\0060\0053\0304\0112\0245\0122\0207\0016\0035\0272\0172\0365\0252\0337\0206\0000\0350\0162\0323\0335\0335\0215\0115\0115\0046\0223\0376\0032\0043\0173\0313\0032\0031\0031\0301\0237\0133\0133\0133\0375\0155\0137\0054\0305\0312\0144\0062\0055\0055\0055\0147\0317\0236\0145\0130\0047\0205\0317\0172\0261\0155\0250\0065\0065\0065\0000\0120\0133\0133\0313\0252\0302\0366\0366\0166\0243\0315\0167\0356\0334\0141\0125\0277\0047\0030\0167\0303\0301\0301\0301\0171\0363\0346\0145\0263\0331\0160\0070\0314\0266\0146\0222\0267\0157\0337\0362\0253\0334\0006\0366\0076\0353\0324\0251\0123\0000\0060\0074\0074\0314\0111\0057\0105\0121\0072\0072\0072\0170\0324\0354\0010\0173\0261\0142\0261\0130\0165\0165\0065\0160\0323\0153\0303\0206\0015\0314\0353\0164\0111\0121\0142\0145\0062\0031\0323\0160\0061\0227\0313\0141\0275\0366\0356\0335\0133\0314\0055\0244\0242\0050\0261\0042\0221\0110\0062\0231\0104\0375\0216\0042\0227\0313\0125\0124\0124\0000\0100\0072\0235\0276\0161\0343\0106\0061\0167\0261\0047\0036\0217\0007\0002\0001\0176\0365\0223\0024\0333\0015\0357\0336\0275\0333\0327\0327\0267\0151\0323\0046\0143\0304\0360\0365\0353\0327\0271\0163\0347\0002\0000\0127\0027\0063\0070\0070\0310\0257\0162\0012\0006\0076\0153\0164\0164\0364\0335\0273\0167\0027\0057\0136\0154\0153\0153\0243\0116\0041\0231\0046\0046\0046\0166\0355\0332\0125\0374\0215\0214\0234\0077\0177\0376\0312\0225\0053\0074\0152\0066\0207\0131\0014\0122\0126\0006\0146\0021\0026\0352\0214\0000\0160\0374\0370\0361\0002\0252\0065\0306\0131\0135\0135\0135\0350\0124\0127\0127\0027\0363\0247\0260\0207\0331\0333\0160\0172\0172\0072\0020\0010\0144\0263\0331\0225\0053\0127\0222\0345\0270\0063\0246\0122\0051\0206\0316\0053\0036\0217\0167\0166\0166\0262\0252\0315\0045\0054\0103\0207\0077\0177\0376\0000\0300\0227\0057\0137\0202\0301\0040\0131\0216\0175\0126\0001\0043\0041\0112\0172\0104\0042\0221\0270\0166\0355\0132\0101\0066\0026\0005\0343\0070\0113\0327\0165\0000\0230\0232\0232\0042\0365\0212\0305\0142\0353\0326\0255\0003\0200\0261\0261\0061\0257\0221\0304\0304\0304\0204\0261\0060\0223\0311\0274\0174\0371\0262\0070\0113\0013\0201\0175\0120\0212\0365\0132\0270\0160\0041\0056\0074\0172\0364\0050\0372\0120\0174\0044\0061\0060\0060\0060\0060\0060\0120\0114\0015\0205\0303\0311\0027\0242\0312\0053\0052\0052\0160\0011\0152\0134\0000\0260\0177\0377\0176\0367\0365\0234\0076\0175\0332\0307\0247\0240\0340\0170\0033\0024\0053\0256\0130\0261\0002\0035\0222\0217\0175\0375\0372\0165\0367\0365\0140\0225\0377\0145\0261\0364\0031\0275\0252\0253\0253\0321\0141\0141\0215\0313\0164\0226\0306\0027\0261\0370\0316\0224\0176\0370\0360\0001\0000\0106\0106\0106\0220\0137\0157\0152\0152\0102\0345\0375\0375\0375\0356\0075\0227\0351\0013\0321\0027\0370\0212\0025\0012\0205\0132\0133\0133\0001\0040\0235\0116\0267\0265\0265\0055\0130\0260\0000\0237\0352\0355\0355\0165\0131\0211\0351\0013\0221\0244\0256\0256\0256\0140\0013\0275\0041\0240\0365\0342\0111\0225\0023\0047\0116\0220\0016\0310\0245\0347\0262\0357\0206\0212\0242\0360\0266\0037\0043\0042\0141\0361\0372\0365\0353\0245\0113\0227\0002\0100\0117\0117\0317\0326\0255\0133\0161\0271\0313\0306\0225\0315\0146\0155\0316\0212\0234\0336\0022\0224\0335\0121\0125\0025\0015\0036\0037\0075\0172\0204\0013\0135\0172\0256\0071\0163\0346\0330\0234\0135\0274\0170\0161\0361\0346\0271\0144\0256\0260\0073\0115\0117\0117\0227\0225\0225\0115\0115\0115\0221\0205\0157\0336\0274\0161\0374\0242\0225\0317\0332\0261\0143\0307\0341\0303\0207\0205\0116\0061\0013\0353\0360\0272\0131\0204\0351\0030\0103\0220\0111\0126\0222\0140\0060\0070\0076\0076\0056\0306\0154\0214\0350\0214\0364\0242\0105\0213\0250\0307\0266\0167\0363\0212\0242\0230\0212\0325\0331\0331\0051\0314\0146\0214\0150\0261\0352\0353\0353\0251\0307\0306\0363\0123\0106\0056\0135\0272\0144\0252\0324\0366\0355\0333\0105\0332\0214\0021\0235\0276\0067\0212\0145\0105\0076\0237\0267\0352\0203\0113\0226\0054\0141\0147\0221\0007\0104\0213\0025\0213\0305\0052\0053\0053\0335\0134\0171\0341\0302\0205\0217\0037\0077\0232\0236\0232\0077\0177\0076\0123\0243\0334\0342\0303\0302\0020\0074\0135\0143\0317\0373\0367\0357\0255\0116\0215\0216\0216\0262\0063\0307\0003\0376\0257\0242\0061\0215\0071\0343\0361\0270\0115\0046\0142\0150\0150\0150\0150\0150\0210\0247\0121\0346\0370\0057\0326\0203\0007\0017\0214\0205\0337\0276\0175\0263\0377\0326\0275\0173\0367\0370\0230\0143\0207\0377\0142\0151\0232\0266\0173\0367\0156\0257\0337\0372\0371\0363\0047\0017\0143\0354\0361\0137\0054\0000\0170\0374\0370\0061\0065\0356\0031\0033\0033\0363\0313\0030\0033\0244\0020\0013\0376\0036\0124\0333\0073\0054\0304\0357\0337\0277\0071\0133\0144\0202\0017\0142\0151\0232\0146\0054\0044\0007\0325\0246\0316\0073\0032\0215\0222\0207\0317\0237\0077\0347\0141\0233\0003\0202\0203\0140\0253\0070\0023\0146\0306\0211\0232\0246\0205\0102\0041\0343\0131\0343\0014\0237\0247\0211\0174\0046\0210\0233\0165\0100\0220\0013\0152\0051\0120\0343\0032\0036\0036\0066\0215\0105\0311\0304\0032\0042\0227\0313\0061\0066\0316\0011\0321\0142\0331\0323\0333\0333\0153\0332\0254\0140\0046\0035\0111\0202\0126\0005\0210\0104\0012\0261\0312\0313\0313\0177\0375\0372\0005\0000\0375\0375\0375\0246\0027\0050\0212\0162\0346\0314\0231\0055\0133\0266\0210\0265\0213\0106\0264\0203\0067\0365\0356\0015\0015\0015\0366\0337\0332\0274\0171\0163\0070\0034\0246\0026\0135\0212\0177\0041\0012\0025\0313\0064\0046\0120\0024\0005\0255\0251\0264\0042\0030\0014\0066\0067\0067\0003\0000\0025\0273\0212\0357\0206\0102\0305\0062\0365\0356\0216\0031\0207\0366\0366\0166\0344\0310\0326\0256\0135\0113\0226\0377\0343\0055\0313\0264\0017\0002\0000\0231\0117\0064\0262\0176\0375\0172\0364\0101\0125\0125\0262\0034\0255\0160\0022\0212\0260\0040\0305\0052\0302\0102\0063\0245\0126\0013\0032\0310\0264\0340\0370\0370\0070\0231\0351\0011\0207\0303\0302\0214\0107\0210\0153\0131\0126\0021\0026\0312\0145\0341\0314\0076\0005\0331\0111\0103\0241\0320\0221\0043\0107\0360\0241\0370\0211\0032\0101\0142\0045\0022\0011\0323\0105\0125\0216\0333\0045\0250\0264\0340\0306\0215\0033\0311\0103\0301\0023\0065\0202\0304\0262\0132\0253\0207\0033\0216\0351\0024\0240\0243\0224\0077\0176\0374\0140\0142\0236\0113\0104\0210\0145\0325\0254\0200\0150\0070\0224\0363\0106\0124\0125\0125\0121\0045\0124\0302\0125\0260\0217\0027\0041\0326\0223\0047\0117\0114\0233\0225\0143\0303\0061\0106\0122\0324\0362\0243\0313\0227\0057\0347\0363\0371\0342\0055\0164\0011\0307\0315\0231\0211\0104\0142\0337\0276\0175\0015\0015\0015\0126\0223\0123\0216\0021\0226\0061\0222\0242\0032\0240\0252\0252\0075\0075\0075\0205\0332\0353\0031\0226\0101\0160\0044\0022\0171\0361\0342\0305\0253\0127\0257\0122\0251\0124\0115\0115\0315\0247\0117\0237\0154\0326\0024\0107\0243\0321\0110\0044\0142\0137\0041\0336\0160\0200\0071\0170\0360\0140\0074\0036\0047\0113\0076\0177\0376\0134\0260\0301\0236\0141\0036\0214\0240\0325\0105\0216\0120\0211\0350\0155\0333\0266\0121\0027\0230\0246\0235\0065\0115\0243\0026\0331\0237\0073\0167\0216\0371\0043\0130\0301\0336\0147\0251\0252\0352\0250\0027\0325\0254\0022\0211\0204\0261\0201\0054\0137\0276\0334\0370\0305\0140\0060\0270\0163\0347\0116\0262\0104\0344\0010\0221\0213\0203\0167\0324\0253\0271\0271\0371\0300\0201\0003\0350\0163\0046\0223\0271\0165\0353\0226\0125\0362\0331\0010\0025\0152\0211\0034\0041\0362\0372\0263\0250\0252\0272\0152\0325\0052\0352\0115\0037\0215\0106\0053\0053\0053\0033\0033\0033\0311\0227\0140\0044\0022\0131\0263\0146\0215\0373\0232\0251\0165\0070\0102\0243\0007\0256\0235\0274\0251\0251\0251\0256\0256\0256\0161\0206\0373\0367\0357\0133\0135\0151\0164\0366\0215\0215\0215\0246\0127\0122\0043\0304\0075\0173\0366\0160\0063\0237\0106\0226\0137\0014\0061\0256\0262\0265\0022\0113\0327\0365\0143\0307\0216\0341\0313\0202\0301\0240\0246\0151\0142\0214\0224\0045\0157\0150\0144\0365\0352\0325\0126\0247\0110\0267\0225\0317\0347\0237\0076\0175\0052\0304\0042\0151\0222\0254\0106\0310\0165\0315\0024\0224\0053\0174\0366\0354\0031\0177\0163\0000\0344\0021\0313\0323\0066\0212\0362\0362\0162\0362\0160\0162\0162\0222\0265\0071\0346\0310\0042\0226\0161\0111\0262\0115\0114\0160\0362\0344\0111\0362\0120\0330\0010\0121\0026\0261\0214\0330\0104\0233\0124\0246\0107\0330\0010\0121\0026\0261\0274\0356\0146\0242\0062\0075\0142\0106\0210\0262\0210\0365\0375\0373\0167\0117\0327\0123\0356\0137\0314\0240\0107\0026\0261\0360\0076\0152\0214\0375\0070\0246\0243\0243\0243\0245\0245\0005\0037\0212\0131\0333\0046\0213\0130\0140\0310\0131\0070\0066\0226\0144\0062\0211\0365\0272\0171\0363\0046\0047\0253\0110\0044\0022\0253\0200\0115\0230\0130\0057\0061\0231\0036\0211\0304\0242\0334\0226\0313\0351\0004\0254\0227\0210\0114\0217\0230\0121\0225\0113\0226\0055\0133\0206\0015\0363\0264\0217\0272\0273\0273\0373\0341\0303\0207\0334\0354\0372\0037\0271\0304\0242\0266\0215\0211\0137\0333\0147\0217\0104\0335\0020\0014\0357\0104\0067\0273\0021\0105\0042\0227\0130\0360\0367\0146\0225\0333\0267\0157\0373\0150\0211\0011\0176\0067\0155\0023\0012\0330\0164\0056\0006\0351\0132\0026\0374\0335\0270\0344\0352\0211\0176\0377\0265\0314\0301\0211\0173\0117\0357\0104\0336\0110\0052\0226\0116\0154\0020\0226\0247\0047\0312\0330\0015\0021\0223\0223\0223\0150\0304\0343\0376\0267\0105\0170\0043\0257\0130\0000\0020\0213\0305\0300\0343\0017\0327\0360\0305\0357\0246\0355\0000\0032\0312\0124\0125\0125\0371\0155\0210\0256\0313\0354\0263\0060\0110\0257\0372\0372\0172\0277\0015\0231\0015\0142\0351\0063\0172\0025\0366\0343\0235\0014\0231\0035\0142\0351\0063\0172\0371\0373\0146\0224\0142\0357\0216\0033\0222\0311\0144\0155\0155\0255\0233\0237\0264\0343\0107\0100\0057\0375\0143\0065\0327\0110\0035\0072\0310\0106\0111\0054\0017\0224\0304\0362\0100\0111\0054\0017\0224\0304\0362\0100\0111\0054\0017\0374\0007\0045\0367\0037\0310\0075\0064\0164\0315\0000\0000\0000\0000\0111\0105\0116\0104\0256\0102\0140\0202
_FACE

    __bin_write;
}

_featherpad_conf() {
    FILE_PATH \
<<FP_CONF
$home/.config/featherpad/fp.conf
FP_CONF

    FILE \
<<'FP_CONF'
[text]
appendEmptyLine=true
autoBracket=false
autoReplace=false
autoSave=false
autoSaveInterval=1
darkBgColorValue=30
darkColorScheme=true
dateFormat=
dictionaryPath=
executeCommand=
executeScripts=false
font="Source Code Pro,12,-1,5,50,0,0,0,0,0"
inertialScrolling=false
lightBgColorValue=255
lineNumbers=true
maxSHSize=2
noIndent=false
noSyntaxHighlighting=false
noWrap=false
pastePaths=false
recentFiles=
recentFilesNumber=10
recentOpened=false
removeTrailingSpaces=false
saveLastFilesList=false
saveUnmodified=false
scrollJumpWorkaround=false
selectionHighlighting=false
showEndings=false
showWhiteSpace=false
skipNonText=true
spellCheckFromStart=false
textMargin=false
textTabSize=8
thickCursor=false
vLineDistance=80

[window]
closeWithLastTab=false
disableMenubarAccel=false
fullscreen=false
hideSearchbar=false
hideSingleTab=false
max=true
menubarTitle=false
nativeDialog=true
noMenubar=false
noToolbar=true
openInWindows=false
position=none
prefSize=@Size(497 530)
sharedSearchHistory=false
showCursorPos=false
showLangSelector=false
showStatusbar=true
sidePaneMode=false
size=@Size(700 500)
splitterPos=20
startSize=@Size(700 500)
sysIcons=false
tabPosition=0
tabWrapAround=false
FP_CONF

    __file_write;
}

_firefox_conf() {
    __git_get \
        "$home/02-GIT/firefox-profiles" \
        'https://github.com/mscalindt/firefox-profiles'

    FILE_PATH \
<<MSCALINDT
$tmpd/firefox-profiles/src/mscalindt
MSCALINDT

    FILE_PATH_TARGET \
<<MSCALINDT
$home/.mozilla/firefox/mscalindt
MSCALINDT

    __dir_target_write;

    FILE_PATH \
<<PROFILES_INI
$tmpd/firefox-profiles/src/profiles.ini
PROFILES_INI

    FILE_PATH_TARGET \
<<PROFILES_INI
$home/.mozilla/firefox/profiles.ini
PROFILES_INI

    __file_write_overwrite;

    FILE_PATH \
<<INSTALLS_INI
$home/.mozilla/firefox/installs.ini
INSTALLS_INI

    __loc_delete;
}

_fontconfig_conf() {
    FILE_PATH \
<<01_FONT_CONF
$home/.config/fontconfig/conf.d/01-font.conf
01_FONT_CONF

    FILE \
<<'01_FONT_CONF'
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE fontconfig SYSTEM "fonts.dtd">
<fontconfig>
  <alias>
    <family>serif</family>
    <prefer>
      <family>DejaVu Serif</family>
    </prefer>
  </alias>
  <alias>
    <family>DejaVu Serif</family>
    <default>
      <family>serif</family>
    </default>
  </alias>

  <alias>
    <family>sans-serif</family>
    <prefer>
      <family>Cantarell</family>
    </prefer>
  </alias>
  <alias>
    <family>Cantarell</family>
    <default>
      <family>sans-serif</family>
    </default>
  </alias>

  <alias>
    <family>monospace</family>
    <prefer>
      <family>Cantarell</family>
    </prefer>
  </alias>
  <alias>
    <family>Cantarell</family>
    <default>
      <family>monospace</family>
    </default>
  </alias>
</fontconfig>
01_FONT_CONF

    __file_write;
}

_fuse_conf() {
    FILE_PATH \
<<'FUSE_CONF'
/etc/fuse.conf
FUSE_CONF

    FILE \
<<'FUSE_CONF'
user_allow_other
FUSE_CONF

    __file_write_overwrite;
}

_gai_conf() {
    FILE_PATH \
<<'GAI_CONF'
/etc/gai.conf
GAI_CONF

    if [ "$ipv6" = 1 ]; then
        __loc_delete;
    else
        FILE \
<<'GAI_CONF'
precedence ::ffff:0:0/96  100
GAI_CONF

        __file_write_overwrite;
    fi
}

_git_conf() {
    FILE_PATH \
<<_GITCONFIG
$home/.gitconfig
_GITCONFIG

    FILE \
<<'_GITCONFIG'
[core]
	editor = nano
[credential]
	helper = cache --timeout=86400
[http]
	version = HTTP/2
[merge]
	log = 10000
[rerere]
	enabled = true
[sendemail]
        smtpuser = mscalindt@gmail.com
	smtpserver = smtp.gmail.com
	smtpencryption = tls
	smtpserverport = 587
[user]
	email = mscalindt@protonmail.com
	name = Dimitar Yurukov
	signingkey = 7D1F56FAD6FB86652A60BEE65BC3343816EAB179
[commit]
	gpgsign = 1
[color "diff"]
	old = red
	new = yellow
_GITCONFIG

    __file_write;
}

_gov_performance() {
    FILE_PATH \
<<'CPU'
/sys/devices/system/cpu
CPU

    if ! exist "$FILE_PATH"/cpu0/cpufreq/scaling_governor; then
        ENOENT;
        ftype "$FILE_PATH"/cpu0/cpufreq/scaling_governor -err || :
        err - - " $FILE_PATH"/cpu0/cpufreq/scaling_governor
        exit 2
    fi

    for core in "$FILE_PATH"/cpu*/cpufreq/scaling_governor; do
        FILE_PATH \
<<SCALING_GOVERNOR
$core
SCALING_GOVERNOR

        FILE \
<<'SCALING_GOVERNOR'
performance
SCALING_GOVERNOR

        __file_write_overwrite_soft;
    done
}

_gov_schedutil() {
    FILE_PATH \
<<'CPU'
/sys/devices/system/cpu
CPU

    if ! exist "$FILE_PATH"/cpu0/cpufreq/scaling_governor; then
        ENOENT;
        ftype "$FILE_PATH"/cpu0/cpufreq/scaling_governor -err || :
        err - - " $FILE_PATH"/cpu0/cpufreq/scaling_governor
        exit 2
    fi

    for core in "$FILE_PATH"/cpu*/cpufreq/scaling_governor; do
        FILE_PATH \
<<SCALING_GOVERNOR
$core
SCALING_GOVERNOR

        FILE \
<<'SCALING_GOVERNOR'
schedutil
SCALING_GOVERNOR

        __file_write_overwrite_soft;
    done
}

# "Removable" GRUB UEFI installation (NVRAM-less... when no NVRAM entries)
_grub() {
    is_uefi || EERROR 'Not in UEFI mode.'

    __cmd grub-install \
        --target=x86_64-efi \
        --efi-directory="$efi_mnt" \
        --boot-directory="$efi_mnt"/EFI/BOOT \
        --removable \
        --no-nvram

    __cmd grub-mkconfig -o "$efi_mnt"/EFI/BOOT/grub/grub.cfg
}

# To simulate a config file, we drop-in our replacement of /etc/default/grub,
# even though this shall usually only be done in a predefined environment
# (such as ours: 'syscfg grub grub-conf')
#
# As indicated by the above statement, GRUB is old and rather fixed on its
# configuration; that is, it does not provide the same flexibility as, for
# example, the configuration of rEFInd. rEFInd should be considered as a
# replacement.
_grub_conf() {
    is_uefi || EERROR 'Not in UEFI mode.'

    FILE_PATH \
<<'GRUB'
/etc/default/grub
GRUB

    FILE \
<<'GRUB'
GRUB_PRELOAD_MODULES="part_gpt"
GRUB_TIMEOUT_STYLE=menu
GRUB_TERMINAL_INPUT=console
GRUB_GFXMODE=auto
GRUB_GFXPAYLOAD_LINUX=keep
GRUB_DISABLE_RECOVERY=true

GRUB_DEFAULT=0
GRUB_TIMEOUT=5
GRUB_CMDLINE_LINUX="\
loglevel=3 nowatchdog mitigations=off processor.ignore_ppc=1 \
usbhid.mousepoll=1 tsc=unstable \
GRUB

    if [ "$ipv6" != 1 ]; then
        FILE \
<<'GRUB'
ipv6.disable=1 \
GRUB
    fi

    FILE \
<<'GRUB'
"
GRUB

    if [ "$arch_linux" = 1 ]; then
        FILE \
<<'GRUB'
GRUB_DISTRIBUTOR="Arch"
GRUB
    fi

    __file_write_overwrite;

    __cmd grub-mkconfig -o "$efi_mnt"/EFI/BOOT/grub/grub.cfg
}

_gtk_conf() {
    FILE_PATH \
<<_GTKRC_2_0
$home/.gtkrc-2.0
_GTKRC_2_0

    FILE \
<<'_GTKRC_2_0'
gtk-cursor-theme-name="Breeze"
gtk-font-name="Cantarell 12"
#gtk-document-font-name="DejaVu Serif 12"
#gtk-monospace-font-name="Cantarell 12"
gtk-cursor-theme-size=0
gtk-application-prefer-dark-theme=true
gtk-enable-primary-paste=false
gtk-toolbar-style=GTK_TOOLBAR_ICONS
gtk-toolbar-icon-size=GTK_ICON_SIZE_LARGE_TOOLBAR
gtk-button-images=1
gtk-menu-images=1
gtk-enable-event-sounds=0
gtk-enable-input-feedback-sounds=0
gtk-xft-antialias=1
gtk-xft-hinting=1
gtk-xft-hintstyle=hintfull
gtk-xft-rgba=rgb
_GTKRC_2_0

    __file_write;

    FILE_PATH \
<<GTK_CSS
$home/.config/gtk-3.0/gtk.css
GTK_CSS

    FILE \
<<'GTK_CSS'
.titlebar,
window {
	border-radius: 0;
	box-shadow: none;
}

decoration {
	box-shadow: none;
}

decoration:backdrop {
	box-shadow: none;
}
GTK_CSS

    __file_write;

    FILE_PATH \
<<SETTINGS_INI
$home/.config/gtk-3.0/settings.ini
SETTINGS_INI

    FILE \
<<'SETTINGS_INI'
[Settings]
gtk-cursor-theme-name="Breeze"
gtk-font-name="Cantarell 12"
#gtk-document-font-name="DejaVu Serif 12"
#gtk-monospace-font-name="Cantarell 12"
gtk-cursor-theme-size=0
gtk-application-prefer-dark-theme=true
gtk-enable-primary-paste=false
gtk-toolbar-style=GTK_TOOLBAR_ICONS
gtk-toolbar-icon-size=GTK_ICON_SIZE_LARGE_TOOLBAR
gtk-button-images=1
gtk-menu-images=1
gtk-enable-event-sounds=0
gtk-enable-input-feedback-sounds=0
gtk-xft-antialias=1
gtk-xft-hinting=1
gtk-xft-hintstyle=hintfull
gtk-xft-rgba=rgb
SETTINGS_INI

    __file_write;
}

_hostname() {
    FILE_PATH \
<<'HOSTNAME'
/etc/hostname
HOSTNAME

    if [ "$m533ia" = 1 ]; then
        FILE \
<<'HOSTNAME'
m533ia
HOSTNAME
    else
        FILE \
<<HOSTNAME
$hostname
HOSTNAME
    fi

    __file_write;
}

_hosts() {
    FILE_PATH \
<<'HOSTS'
/etc/hosts
HOSTS

    if [ "$ipv6" = 1 ]; then
        FILE \
<<'HOSTS'
::1              localhost
127.0.0.1        localhost
HOSTS
    else
        FILE \
<<'HOSTS'
127.0.0.1        localhost
HOSTS
    fi

    if [ "$m533ia" = 1 ]; then
        FILE \
<<'HOSTS'
127.0.1.1        m533ia
HOSTS
    fi

    __file_write;
}

_imv_conf() {
    FILE_PATH \
<<CONFIG
$home/.config/imv/config
CONFIG

    FILE \
<<'CONFIG'
[options]
background = 696969
CONFIG

    __file_write;
}

_initramfs_conf() {
    if [ "$arch_linux" != 1 ]; then
        _info -white - 'Nothing to be done.'

        return 0
    fi

    FILE_PATH \
<<'MKINITCPIO_CONF'
/etc/mkinitcpio.conf
MKINITCPIO_CONF

    if [ "$m533ia" = 1 ]; then
        FILE \
<<'MKINITCPIO_CONF'
MODULES=(amdgpu pinctrl-amd)
MKINITCPIO_CONF
    else
        FILE \
<<'MKINITCPIO_CONF'
MODULES=()
MKINITCPIO_CONF
    fi

    FILE \
<<'MKINITCPIO_CONF'
BINARIES=()
FILES=()
HOOKS=(base udev autodetect microcode modconf keyboard block filesystems fsck)
MODULES_DECOMPRESS="yes"
MKINITCPIO_CONF

    __file_write_overwrite;

    __cmd mkinitcpio -P
}

_iwd_conf() {
    FILE_PATH \
<<'MAIN_CONF'
/etc/iwd/main.conf
MAIN_CONF

    FILE \
<<'MAIN_CONF'
[General]
EnableNetworkConfiguration=true
AddressRandomization=network
AddressRandomizationRange=nic

[Network]
MAIN_CONF

    if [ "$ipv6" = 1 ]; then
        FILE \
<<'MAIN_CONF'
EnableIPv6=true
MAIN_CONF
    else
        FILE \
<<'MAIN_CONF'
EnableIPv6=false
MAIN_CONF
    fi

    FILE \
<<'MAIN_CONF'
NameResolvingService=none

[Scan]
DisablePeriodicScan=true
MAIN_CONF

    __file_write;
}

_kitty_conf() {
    FILE_PATH \
<<KITTY_CONF
$home/.config/kitty/kitty.conf
KITTY_CONF

    FILE \
<<'KITTY_CONF'
font_family Source Code Pro
font_size 10.0
cursor_text_color background
cursor_shape beam
cursor_beam_thickness 1.0
cursor_stop_blinking_after 0.0
scrollback_lines 300000
wheel_scroll_multiplier 3.0
mouse_hide_wait 0.0
url_color #FFFFFF
url_style single
select_by_word_characters -A-Za-z0-9,./?%&#:_=+@~
enable_audio_bell no
remember_window_size no
initial_window_width 814
initial_window_height 498
hide_window_decorations yes
background_opacity 0.5
update_check_interval 0
shell_integration disabled
confirm_os_window_close 0
color0 #767676
color1 #f2201f
color2 #23fd00
color3 #fffd00
color4 #1a8fff
color5 #fd28ff
color6 #14ffff
color7 #ffffff
background #300924
map kitty_mod+a scroll_page_up
map kitty_mod+s scroll_page_down
map kitty_mod+z scroll_home
map kitty_mod+x scroll_end
KITTY_CONF

    __file_write;
}

_kvantum_conf() {
    FILE_PATH \
<<KVANTUM_KVCONFIG
$home/.config/Kvantum/kvantum.kvconfig
KVANTUM_KVCONFIG

    FILE \
<<'KVANTUM_KVCONFIG'
[General]
theme=KvArcDark#
KVANTUM_KVCONFIG

    __file_write;

    FILE_PATH \
<<KVARCDARK__KVCONFIG
$home/.config/Kvantum/KvArcDark#/KvArcDark#.kvconfig
KVARCDARK__KVCONFIG

    FILE \
<<'KVARCDARK__KVCONFIG'
[%General]
author=Tsu Jan
comment=A minimalistic dark theme inspired by the Arc GTK theme
x11drag=menubar_and_primary_toolbar
alt_mnemonic=true
left_tabs=true
attach_active_tab=true
mirror_doc_tabs=true
group_toolbar_buttons=false
toolbar_item_spacing=1
toolbar_interior_spacing=3
spread_progressbar=true
composite=false
menu_shadow_depth=5
menu_separator_height=6
tooltip_shadow_depth=6
splitter_width=4
scroll_width=9
scroll_arrows=false
scroll_min_extent=60
slider_width=6
slider_handle_width=18
slider_handle_length=18
center_toolbar_handle=true
check_size=14
textless_progressbar=false
progressbar_thickness=3font
menubar_mouse_tracking=true
toolbutton_style=0
click_behavior=0
translucent_windows=false
blurring=false
popup_blurring=false
vertical_spin_indicators=false
spin_button_width=32
fill_rubberband=false
merge_menubar_with_toolbar=true
small_icon_size=16
large_icon_size=32
button_icon_size=16
toolbar_icon_size=22
combo_as_lineedit=true
animate_states=false
combo_menu=true
hide_combo_checkboxes=true
combo_focus_rect=true
groupbox_top_label=true
inline_spin_indicators=false
joined_inactive_tabs=false
layout_spacing=6
layout_margin=9
scrollbar_in_view=true
transient_scrollbar=true
transient_groove=true
submenu_overlap=3
tooltip_delay=-1
tree_branch_line=true
dark_titlebar=true
contrast=1.00
dialog_button_layout=0
drag_from_buttons=false
intensity=1.00
menu_blur_radius=0
no_inactiveness=false
no_window_pattern=false
opaque=kaffeine,kmplayer,subtitlecomposer,kdenlive,vlc,smplayer,smplayer2,avidemux,avidemux2_qt4,avidemux3_qt4,avidemux3_qt5,kamoso,QtCreator,VirtualBox,VirtualBoxVM,trojita,dragon,digikam,lyx
reduce_menu_opacity=0
reduce_window_opacity=0
respect_DE=true
saturation=1.00
scrollable_menu=true
shadowless_popup=false
submenu_delay=250
tooltip_blur_radius=0

[GeneralColors]
window.color=#383c4a
base.color=#404552
alt.base.color=#3c434f
button.color=#414654
light.color=#5f677f
mid.light.color=#313131
dark.color=black
mid.color=#191919
highlight.color=#5294e2
inactive.highlight.color=#5294e2
text.color=#ffffffc8
window.text.color=#ffffffc8
button.text.color=#ffffffc8
disabled.text.color=#ffffff73
tooltip.text.color=#eefcff
highlight.text.color=white
link.color=#009DFF
link.visited.color=#9E4FFF
progress.indicator.text.color=white

[Hacks]
transparent_ktitle_label=false
transparent_dolphin_view=false
transparent_pcmanfm_sidepane=false
blur_translucent=false
transparent_menutitle=false
respect_darkness=true
force_size_grip=true
iconless_pushbutton=true
iconless_menu=false
disabled_icon_opacity=100
lxqtmainmenu_iconsize=22
normal_default_pushbutton=true
single_top_toolbar=true
tint_on_mouseover=0
transparent_pcmanfm_view=false
blur_only_active_window=false
centered_forms=false
kinetic_scrolling=false
middle_click_scroll=false
no_selection_tint=false
noninteger_translucency=false
style_vertical_toolbars=false

[PanelButtonCommand]
frame=true
frame.element=button
frame.top=3
frame.bottom=3
frame.left=3
frame.right=3
interior=true
interior.element=button
indicator.size=9
text.normal.color=#ffffffc8
text.focus.color=white
text.press.color=white
text.toggle.color=white
text.shadow=0
text.margin=1
text.iconspacing=4
indicator.element=arrow
text.margin.top=2
text.margin.bottom=2
text.margin.left=2
text.margin.right=2
min_width=+0.3font
min_height=+0.3font
frame.expansion=6

[PanelButtonTool]
inherits=PanelButtonCommand

[Dock]
inherits=PanelButtonCommand
interior.element=dock
frame.element=dock
frame.top=1
frame.bottom=1
frame.left=1
frame.right=1
text.normal.color=#ffffffc8

[DockTitle]
inherits=PanelButtonCommand
frame=false
interior=false
text.normal.color=#ffffff96
text.focus.color=white
text.bold=true

[IndicatorSpinBox]
inherits=PanelButtonCommand
frame=true
interior=true
frame.left=1
indicator.element=spin
indicator.size=10
text.normal.color=#ffffffc8

[RadioButton]
inherits=PanelButtonCommand
frame=false
interior.element=radio
text.normal.color=#ffffffc8
text.focus.color=white

[CheckBox]
inherits=PanelButtonCommand
frame=false
interior.element=checkbox
text.normal.color=#ffffffc8
text.focus.color=white

[Focus]
inherits=PanelButtonCommand
frame=true
frame.element=focus
frame.top=1
frame.bottom=1
frame.left=1
frame.right=1
frame.patternsize=20

[GenericFrame]
inherits=PanelButtonCommand
frame=true
interior=false
frame.element=common
interior.element=common
frame.top=3
frame.bottom=3
frame.left=3
frame.right=3

[LineEdit]
inherits=PanelButtonCommand
frame.element=lineedit
interior.element=lineedit
text.margin.left=1
text.margin.right=1

[DropDownButton]
inherits=PanelButtonCommand
indicator.element=arrow-down

[IndicatorArrow]
indicator.element=arrow
indicator.size=9

[ToolboxTab]
inherits=PanelButtonCommand
text.normal.color=#ffffffc8
text.press.color=#ffffff96
text.focus.color=white

[Tab]
inherits=PanelButtonCommand
interior.element=tab
text.margin.left=8
text.margin.right=8
text.margin.top=2
text.margin.bottom=2
frame.element=tab
indicator.element=tab
frame.top=4
frame.bottom=4
frame.left=4
frame.right=4
text.normal.color=#ffffff78
text.focus.color=#ffffffb4
text.toggle.color=#ffffffd2
frame.expansion=0

[TabFrame]
inherits=PanelButtonCommand
frame.element=tabframe
interior.element=tabframe
frame.top=4
frame.bottom=4
frame.left=4
frame.right=4

[TreeExpander]
inherits=PanelButtonCommand
indicator.size=12
indicator.element=tree

[HeaderSection]
inherits=PanelButtonCommand
interior.element=header
frame.element=header
frame.top=3
frame.bottom=3
frame.left=1
frame.right=1
text.bold=true
text.normal.color=#ffffff96
text.focus.color=#5796e8
text.toggle.color=white
frame.expansion=0

[SizeGrip]
indicator.element=resize-grip

[Toolbar]
inherits=PanelButtonCommand
indicator.element=toolbar
indicator.size=5
text.margin=0
frame=false
interior.element=menubar
frame.element=menubar
text.normal.color=#ffffffc8
text.focus.color=white
frame.bottom=0
frame.expansion=0

[Slider]
inherits=PanelButtonCommand
frame.element=slider
interior.element=slider
frame.top=3
frame.bottom=3
frame.left=3
frame.right=3

[SliderCursor]
inherits=PanelButtonCommand
frame=false
interior.element=slidercursor

[Progressbar]
inherits=PanelButtonCommand
frame.element=progress
interior.element=progress
text.margin=0
text.normal.color=#ffffffc8
text.focus.color=white
text.press.color=white
text.toggle.color=white
text.bold=false
frame.expansion=8

[ProgressbarContents]
inherits=PanelButtonCommand
frame=true
frame.element=progress-pattern
interior.element=progress-pattern

[ItemView]
inherits=PanelButtonCommand
text.margin=0
frame.element=itemview
interior.element=itemview
frame.top=2
frame.bottom=2
frame.left=2
frame.right=2
text.margin.top=2
text.margin.bottom=2
text.margin.left=4
text.margin.right=4
text.normal.color=#ffffffc8
text.focus.color=white
text.press.color=white
text.toggle.color=white
frame.expansion=0

[Splitter]
indicator.size=48

[Scrollbar]
inherits=PanelButtonCommand
indicator.element=arrow
indicator.size=10

[ScrollbarSlider]
inherits=PanelButtonCommand
frame.element=scrollbarslider
interior=false
frame.left=6
frame.right=6
frame.top=6
frame.bottom=6
indicator.element=grip
indicator.size=13
frame.expansion=48

[ScrollbarGroove]
inherits=PanelButtonCommand
interior=false
frame=false

[MenuItem]
inherits=PanelButtonCommand
frame=true
frame.element=menuitem
interior.element=menuitem
indicator.element=menuitem
text.normal.color=#ffffffc8
text.focus.color=white
text.margin.top=1
text.margin.bottom=1
text.margin.left=15
text.margin.right=5
frame.top=3
frame.bottom=3
frame.left=3
frame.right=3
frame.expansion=0

[MenuBar]
inherits=PanelButtonCommand
frame.element=menubar
interior.element=menubar
frame.bottom=0
frame.expansion=0

[MenuBarItem]
inherits=PanelButtonCommand
interior=true
interior.element=menubaritem
frame.element=menubaritem
frame.top=2
frame.bottom=2
frame.left=2
frame.right=2
text.margin.left=4
text.margin.right=4
text.margin.top=0
text.margin.bottom=0
text.normal.color=#000000b4
text.focus.color=white
frame.expansion=0

[TitleBar]
inherits=PanelButtonCommand
frame=false
interior.element=titlebar
indicator.size=12
indicator.element=mdi
text.normal.color=#787878
text.focus.color=white
text.bold=true
text.italic=true
frame.expansion=0

[ComboBox]
inherits=PanelButtonCommand
interior.element=combo
frame.element=combo
text.press.color=#ffffffc8
indicator.element=carrow

[Menu]
inherits=PanelButtonCommand
frame.top=1
frame.bottom=1
frame.left=1
frame.right=1
frame.element=menu
interior.element=menu
text.normal.color=#ffffffc8
text.shadow=false
frame.expansion=0

[GroupBox]
inherits=GenericFrame
frame=false
text.shadow=0
text.margin=0
text.normal.color=#ffffff96
text.focus.color=white
text.bold=true
frame.expansion=0

[TabBarFrame]
inherits=GenericFrame
frame=true
frame.element=tabBarFrame
interior=false
frame.top=4
frame.bottom=4
frame.left=4
frame.right=4

[ToolTip]
inherits=GenericFrame
frame.top=3
frame.bottom=3
frame.left=3
frame.right=3
interior=true
text.shadow=0
text.margin=0
interior.element=tooltip
frame.element=tooltip
frame.expansion=0

[StatusBar]
inherits=GenericFrame
frame=false
interior=false

[Window]
interior=true
interior.element=window
KVARCDARK__KVCONFIG

    __file_write;
}

# English locale config
_locale() {
    FILE_PATH \
<<'LOCALE_CONF'
/etc/locale.conf
LOCALE_CONF

    FILE \
<<'LOCALE_CONF'
LANG=en_US.UTF-8
LOCALE_CONF

    __file_write;

    FILE_PATH \
<<'LOCALE_GEN'
/etc/locale.gen
LOCALE_GEN

    FILE \
<<'LOCALE_GEN'
bg_BG.UTF-8 UTF-8
en_US.UTF-8 UTF-8
LOCALE_GEN

    __file_write;

    __cmd locale-gen
}

_makepkg_conf() {
    if [ "$arch_linux" != 1 ]; then
        _info -white - 'Nothing to be done.'

        return 0
    fi

    FILE_PATH \
<<'MAKEPKG_CONF'
/etc/makepkg.conf
MAKEPKG_CONF

    __fed '' "$logf" \
        -m p -s \
        'CFLAGS="-march=x86-64 -mtune=' \
        'CFLAGS="-march=x86-64 -mtune=native -O2 -pipe -fno-plt -fexceptions \' \
        -s \
        'MAKEFLAGS="-j' \
        'MAKEFLAGS="-j6"'

    __file_write_overwrite;
}

_moc_conf() {
    FILE_PATH \
<<CONFIG
$home/.moc/config
CONFIG

    FILE \
<<'CONFIG'
SoundDriver = ALSA
Theme = transparent-background
CONFIG

    __file_write;
}

# Fix pop on idle resume
_modprobe_conf() {
    FILE_PATH \
<<'99_SND_POWERSAVE_CONF'
/etc/modprobe.d/99-snd_powersave.conf
99_SND_POWERSAVE_CONF

    FILE \
<<'99_SND_POWERSAVE_CONF'
options snd_hda_intel power_save=0 power_save_controller=N
99_SND_POWERSAVE_CONF

    __file_write;
}

_mpv_conf() {
    FILE_PATH \
<<MPV_CONF
$home/.config/mpv/mpv.conf
MPV_CONF

    FILE \
<<'MPV_CONF'
profile=gpu-hq
scale=ewa_lanczossharp
cscale=ewa_lanczossharp
override-display-fps=60
video-sync=display-resample
interpolation=yes
tscale=oversample
hwdec=auto
border=no
msg-color=yes
cursor-autohide=1000
screenshot-template="%F - [%P]v%#01n"
save-position-on-quit=yes
alang=en
slang=en
sub-auto=fuzzy
sub-bold=yes
MPV_CONF

    __file_write;
}

_mutt_conf() {
    FILE_PATH \
<<MUTTRC
$home/.mutt/muttrc
MUTTRC

    FILE \
<<'MUTTRC'
# Personal
set realname = "Dimitar Yurukov"
set from = "mscalindt@gmail.com"

# SMTP
set smtp_url = "smtps://mscalindt@smtp.gmail.com"
set ssl_force_tls = yes

# IMAP
set imap_user = "mscalindt@gmail.com"
set folder = "imaps://imap.gmail.com"
set spoolfile = "imaps://imap.gmail.com/INBOX"

# Settings
set signature="~/.mutt/muttsig"
set send_charset="us-ascii:utf-8"
set charset = UTF-8
set edit_headers = yes
set use_from = yes
set envelope_from = yes
unset use_domain

# Keybindings
bind index "^" imap-fetch-mail
MUTTRC

    __file_write;

    FILE_PATH \
<<MUTTSIG
$home/.mutt/muttsig
MUTTSIG

    FILE \
<<'MUTTSIG'
PGP: https://github.com/mscalindt.gpg
Email: mscalindt@gmail.com
MUTTSIG

    __file_write;
}

_nano_conf() {
    FILE_PATH \
<<_NANORC
$home/.nanorc
_NANORC

    FILE \
<<'_NANORC'
set fill 72
set breaklonglines
_NANORC

    __file_write;
}

# Delete all boot entries (UEFI)
_nvram_clr() {
    is_uefi || EERROR 'Not in UEFI mode.'

    set -- '/sys/firmware/efi/efivars'/Boot0*

    if ! exist "$1"; then
        _info -white - 'No valid entries have been found.'
        return 0
    fi

    set -- \
        '/sys/firmware/efi/efivars'/BootOrder* \
        '/sys/firmware/efi/efivars'/Boot0*

    if cmd 'chattr'; then
        __cmd chattr -ia "$@"
    fi

    __cmd rm -f "$@"

    set -- '/sys/firmware/efi/efivars'/Boot0*

    if exist "$1"; then
        EERROR 'Entry removal failed.'
    fi

    _info -white - 'The entries were removed; firmware will attempt recovery.'
}

_openal_conf() {
    FILE_PATH \
<<'ALSOFT_CONF'
/etc/openal/alsoft.conf
ALSOFT_CONF

    FILE \
<<'ALSOFT_CONF'
frequency = 48000
ALSOFT_CONF

    __file_write;
}

_pacman_conf() {
    if [ "$arch_linux" != 1 ]; then
        _info -white - 'Nothing to be done.'

        return 0
    fi

    FILE_PATH \
<<'PACMAN_CONF'
/etc/pacman.conf
PACMAN_CONF

    __fed '' "$logf" \
        -m s -s \
        'Color' \
        'Color' \
        -s \
        'ParallelDownloads' \
        'ParallelDownloads = 5' \
        -m s -s \
        'VerbosePkgLists' \
        'VerbosePkgLists' \
        -s \
        'NoExtract' \
        'NoExtract = etc/xdg/autostart/*.desktop'

    # 2066821928 CRC32:
    # `'-s' '92' '[multilib]'` \
    # `'-s' '93' 'Include = /etc/pacman.d/mirrorlist'`
    __fed 2066821928 "$logf" \
        -m s -s \
        '[multilib]' \
        '[multilib]' \
        -m 93 -s \
        '' \
        "Include = $arch_mirlist"

    __file_write_overwrite;
}

_pam_conf() {
    FILE_PATH \
<<'FAILLOCK_CONF'
/etc/security/faillock.conf
FAILLOCK_CONF

    FILE \
<<'FAILLOCK_CONF'
deny=7
even_deny_root
nodelay
root_unlock_time=8400
unlock_time=600
FAILLOCK_CONF

    __file_write_overwrite;

    FILE_PATH \
<<'LOGIN_DEFS'
/etc/login.defs
LOGIN_DEFS

    __fed '' "$logf" \
        -m p -s \
        'FAIL_DELAY' \
        'FAIL_DELAY 0'

    __file_write_overwrite;

    FILE_PATH \
<<'SU'
/etc/pam.d/su
SU

    # 3615679525 CRC32:
    # `'-s' '7' 'auth            required        pam_unix.so nodelay'`
    __fed 3615679525 "$logf" \
        -m 7 -s \
        '' \
        'auth            required        pam_unix.so nodelay'

    __file_write_overwrite;

    FILE_PATH \
<<'SYSTEM_AUTH'
/etc/pam.d/system-auth
SYSTEM_AUTH

    # 1797369364 CRC32:
    # `'-s' '7' 'auth       [success=1 default=bad]     ` \
    # `pam_unix.so          try_first_pass nullok nodelay'`
    __fed 1797369364 "$logf" \
        -m mof -m s -s \
        'try_first_pass nullok' \
        'try_first_pass nullok nodelay'

    __file_write_overwrite;
}

_pipewire_conf() {
    FILE_PATH \
<<'CLIENT_CONF'
/etc/pipewire/client.conf.d/client.conf
CLIENT_CONF

    FILE \
<<'CLIENT_CONF'
context.properties = {
    module.rt = false  # disable rtkit module

    mem.allow-mlock = false  # swap is not used -> mlock is useless overhead

    default.clock.quantum-limit = 8192
}

filter.properties = {
    node.latency = 1024/44100  # 44.1k with ~23.2ms
}

stream.properties = {
    node.latency = 1024/44100  # 44.1k with ~23.2ms
CLIENT_CONF

    if [ "$audio_hq_resamp" = 1 ]; then
        FILE \
<<'CLIENT_CONF'
    resample.quality = 15
CLIENT_CONF
    else
        FILE \
<<'CLIENT_CONF'
    resample.quality = 9
CLIENT_CONF
    fi

    FILE \
<<'CLIENT_CONF'
}

alsa.properties = {
    alsa.rate = 44100  # 44.100 kHz
}
CLIENT_CONF

    __file_write;

    FILE_PATH \
<<'PIPEWIRE_CONF'
/etc/pipewire/pipewire.conf.d/pipewire.conf
PIPEWIRE_CONF

    FILE \
<<'PIPEWIRE_CONF'
context.properties = {
    module.rt = false  # disable rtkit module
    module.x11.bell = false  # disable x11 bell module
PIPEWIRE_CONF

    if [ "$portal" != 1 ]; then
        FILE \
<<'PIPEWIRE_CONF'

    module.portal = false  # disable portal module
PIPEWIRE_CONF
    fi

    FILE \
<<'PIPEWIRE_CONF'

    mem.allow-mlock = false  # swap is not used -> mlock is useless overhead

    loop.rt-prio = 0  # disable module-rt prio

    # 44.1k with ~23.2ms; related limits noted for explicit config
    default.clock.rate = 44100
    default.clock.allowed-rates = [ 44100 ]
    default.clock.quantum = 1024
    default.clock.min-quantum = 32
    default.clock.max-quantum = 2048
    default.clock.quantum-limit = 8192
    default.clock.quantum-floor = 4
}
PIPEWIRE_CONF

    __file_write;

    FILE_PATH \
<<'PIPEWIRE_PULSE_CONF'
/etc/pipewire/pipewire-pulse.conf.d/pipewire-pulse.conf
PIPEWIRE_PULSE_CONF

    FILE \
<<'PIPEWIRE_PULSE_CONF'
context.properties = {
    mem.allow-mlock = false  # swap is not used -> mlock is useless overhead

    default.clock.quantum-limit = 8192
}

pulse.properties = {
    pulse.allow-module-loading = false  # we use no modules
    # 44.1k with ~23.2ms
    pulse.min.req = 128/44100  # ~2.9ms
    pulse.default.req = 1024/44100  # ~23.2ms
    pulse.min.frag = 128/44100  # ~2.9ms
    pulse.default.frag = 88200/44100  # 2s
    pulse.default.tlength = 88200/44100  # 2s
    pulse.min.quantum = 128/44100  # ~2.9ms
    pulse.idle.timeout = 0  # I guess disables suspend functionality
}

stream.properties = {
    node.latency = 1024/44100  # 44.1k with ~23.2ms
PIPEWIRE_PULSE_CONF

    if [ "$audio_hq_resamp" = 1 ]; then
        FILE \
<<'PIPEWIRE_PULSE_CONF'
    resample.quality = 15
PIPEWIRE_PULSE_CONF
    else
        FILE \
<<'PIPEWIRE_PULSE_CONF'
    resample.quality = 9
PIPEWIRE_PULSE_CONF
    fi

    FILE \
<<'PIPEWIRE_PULSE_CONF'
}
PIPEWIRE_PULSE_CONF

    __file_write;
}

_pipewire_media_session_conf() {
    FILE_PATH \
<<'MEDIA_SESSION_CONF'
/etc/pipewire/media-session.d/media-session.conf
MEDIA_SESSION_CONF

    FILE \
<<'MEDIA_SESSION_CONF'
context.properties = {
    support.dbus = true
    default-profile.restore-bluetooth = true
}

context.spa-libs = {
    api.bluez5.*    = bluez5/libspa-bluez5
    api.alsa.*      = alsa/libspa-alsa
    api.v4l2.*      = v4l2/libspa-v4l2
    api.libcamera.* = libcamera/libspa-libcamera
}

context.modules = [
    { name = libpipewire-module-protocol-native }
    { name = libpipewire-module-client-node }
    { name = libpipewire-module-client-device }
    { name = libpipewire-module-adapter }
    { name = libpipewire-module-metadata }
    { name = libpipewire-module-session-manager }
]

session.modules = {
    default = [
        alsa-monitor
        alsa-seq
        default-nodes
        default-profile
        default-routes
        metadata
        policy-node
        restore-stream
        streams-follow-default
        v4l2
MEDIA_SESSION_CONF

    if [ "$bluetooth" = 1 ]; then
        FILE \
<<'MEDIA_SESSION_CONF'
        bluez5
        bluez5-autoswitch
MEDIA_SESSION_CONF
    fi

    if [ "$portal" = 1 ]; then
        FILE \
<<'MEDIA_SESSION_CONF'
        portal
MEDIA_SESSION_CONF
    fi

    FILE \
<<'MEDIA_SESSION_CONF'
    ]
}
MEDIA_SESSION_CONF

    __file_write;

    if [ "$bluetooth" = 1 ]; then
        FILE_PATH \
<<'BLUEZ_MONITOR_CONF'
/etc/pipewire/media-session.d/bluez-monitor.conf
BLUEZ_MONITOR_CONF

        FILE \
<<'BLUEZ_MONITOR_CONF'
properties = {
    bluez5.enable-sbc-xq = false
    bluez5.enable-msbc = false
    bluez5.enable-hw-volume = true
    bluez5.enable-faststream = false

    bluez5.codecs = [ aac ]

    bluez5.default.rate = 44100  # 44.100 kHz
}

rules = [
    {
        matches = [
            {
                device.name = "~bluez_card.*"
            }
        ]
        actions = {
            update-props = {
                bluez5.auto-connect = [ a2dp_sink ]
                bluez5.a2dp.aac.bitratemode = 0  # CBR 256 kbps
                bluez5.profile = a2dp-sink
                bluez5.autoswitch-profile = false
            }
        }
    }
    {
        matches = [
            {
                node.name = "~bluez_input.*"
            }
            {
                node.name = "~bluez_output.*"
            }
        ]
        actions = {
            update-props = {
                node.pause-on-idle = false
BLUEZ_MONITOR_CONF

        if [ "$audio_hq_resamp" = 1 ]; then
            FILE \
<<'BLUEZ_MONITOR_CONF'
                resample.quality = 15
BLUEZ_MONITOR_CONF
        else
            FILE \
<<'BLUEZ_MONITOR_CONF'
                resample.quality = 9
BLUEZ_MONITOR_CONF
        fi

        FILE \
<<'BLUEZ_MONITOR_CONF'
                session.suspend-timeout-seconds = 0
                bluez5.media-source-role = playback
            }
        }
    }
]
BLUEZ_MONITOR_CONF

        __file_write;
    fi
}

_ranger_conf() {
    FILE_PATH \
<<RC_CONF
$home/.config/ranger/rc.conf
RC_CONF

    FILE \
<<'RC_CONF'
map D console delete
copymap J <C-z>
copymap K <C-x>
copymap S <C-s>
set autosave_bookmarks false
set display_free_space_in_status_bar false
set display_size_in_status_bar false
set draw_borders both
set hostname_in_titlebar false
set idle_delay 100
set max_console_history_size 100
set mouse_enabled false
set preview_images_method kitty
set tilde_in_titlebar true
RC_CONF

    __file_write;

    FILE_PATH \
<<RIFLE_CONF
$home/.config/ranger/rifle.conf
RIFLE_CONF

    FILE \
<<'RIFLE_CONF'
# Video
mime ^video, has mpv,       X,  flag f = mpv -- "$@"
mime ^video, has parole,    X,  flag f = parole -- "$@"
mime ^video, has vlc,       X,  flag f = vlc -- "$@"
mime ^video, has mpv,       !X, terminal = mpv -- "$@"

# Audio
ext midi?, has wildmidi,    terminal = wildmidi -- "$@"
mime ^audio, has mocp,      terminal = mocp -l -- "$@"
mime ^audio, has mpv,       terminal = mpv -- "$@"
mime ^audio, has parole,    X, flag f = parole -- "$@"
mime ^audio, has vlc,       X, flag f = vlc -- "$@"

# Images
ext xcf, has gimp,                X, flag f = gimp -- "$@"
mime ^image/svg, has inkscape,    X, flag f = inkscape -- "$@"
mime ^image/svg, has display,     X, flag f = display -- "$@"
mime ^image, has swayimg,         X, flag f = swayimg -- "$@"
mime ^image, has imv,             X, flag f = imv -- "$@"
mime ^image, has ristretto,       X, flag f = ristretto "$@"
mime ^image, has gimp,            X, flag f = gimp -- "$@"

# PDF/Books
ext pdf, has firefox,          X, flag f = firefox -- "$@"
ext pdf, has zathura,          X, flag f = zathura -- "$@"
ext djvu, has zathura,         X, flag f = zathura -- "$@"
ext djvu, has djview,          X, flag f = djview -- "$@"
ext epub, has zathura,         X, flag f = zathura -- "$@"
ext epub, has ebook-viewer,    X, flag f = ebook-viewer -- "$@"
ext mobi, has ebook-viewer,    X, flag f = ebook-viewer -- "$@"
ext cbr|cbz, has zathura,      X, flag f = zathura -- "$@"

# Archives (atool)
ext 7z|ace|ar|arc|bz2?|cab|cpio|cpt|deb|dgc|dmg|gz|iso|jar|msi|pkg|rar|shar|tar|tgz|xar|xpi|xz|zip,    has atool = atool --list --each -- "$@" | "$PAGER"
ext 7z|ace|ar|arc|bz2?|cab|cpio|cpt|deb|dgc|dmg|gz|iso|jar|msi|pkg|rar|shar|tar|tgz|xar|xpi|xz|zip,    has atool = atool --extract --each -- "$@"

# Archives
ext 7z      has 7z = 7z -p l "$@" | "$PAGER"
ext 7z,     has 7z = for file in "$@"; do 7z -p -o"${file%???}" x -- "$file"; done
ext ace,    has unace = unace l "$1" | less
ext ace,    has unace = for file in "$@"; do unace e "$file"; done
ext bz2,    has tar = tar vvtf "$1" | "$PAGER"
ext bz2,    has tar = for file in "$@"; do tar vvxf "$file"; done
ext bz2,    has bzip2 = for file in "$@"; do bzip2 -dk "$file"; done
ext gz,     has tar = tar vvtf "$1" | "$PAGER"
ext gz,     has tar = for file in "$@"; do tar vvxf "$file"; done
ext rar,    has unrar = unrar l "$1" | less
ext rar,    has unrar = for file in "$@"; do unrar x "$file"; done
ext tar,    has tar = tar vvtf "$1" | "$PAGER"
ext tar,    has tar = for file in "$@"; do tar vvxf "$file"; done
ext xz,     has tar = tar vvtf "$1" | "$PAGER"
ext xz,     has tar = for file in "$@"; do tar vvxf "$file"; done
ext zip,    has unzip = unzip -l "$1" | less
ext zip,    has unzip = for file in "$@"; do unzip -d "${file%.*}" "$file"; done
ext zst,    has tar = tar vvtf "$1" | "$PAGER"
ext zst,    has tar = for file in "$@"; do tar vvxf "$file"; done

# HTML
ext x?html?, has firefox,     X, flag f = firefox -- "$@"
ext x?html?, has midori,      X, flag f = midori -- "$@"
ext x?html?, has chromium,    X, flag f = midori -- "$@"

# Docs/Text
ext sh,    has featherpad,     X, flag f = featherpad "$@"
ext shfn,  has featherpad,     X, flag f = featherpad "$@"
ext ini,   has featherpad,     X, flag f = featherpad "$@"
ext docx?, has catdoc,         terminal = catdoc -- "$@" | "$PAGER"
mime ^text, has featherpad,    X, flag f = featherpad "$@"
mime ^text, label editor                 = "${VISUAL:-$EDITOR}" -- "$@"
mime ^text, label pager                  = "$PAGER" -- "$@"

# Misc exts
ext 1|5 = man "$1"
ext exe = wine "$1"

# Misc mEmes
mime application/x-executable               = "$1"
mime ^font, has fontforge, X, flag f        = fontforge "$@"
mime ^ranger/x-terminal-emulator, has kitty = kitty -- "$@"

label open,   has xdg-open = xdg-open "$@"
label editor, !mime ^text, = "${VISUAL:-$EDITOR}" -- "$@"
label pager,  !mime ^text, = "$PAGER" -- "$@"
RIFLE_CONF

    __file_write;
}

_reflector() {
    if [ "$arch_linux" != 1 ]; then
        _info -white - 'Nothing to be done.'

        return 0
    fi

    if [ "$bg" = 1 ]; then
        _reflector_bg;
    elif [ "$de" = 1 ]; then
        _reflector_de;
    fi
}

_reflector_bg() {
    if [ "$arch_linux" != 1 ]; then
        _info -white - 'Nothing to be done.'

        return 0
    fi

    FILE_PATH \
<<MIRRORLIST
$arch_mirlist
MIRRORLIST

    __FILE_cmd reflector \
        --country Bulgaria \
        --connection-timeout 1 \
        --download-timeout 20 \
        --protocol https \
        --completion-percent 100 \
        --sort rate \
        --threads 8 \
        --latest 10 \
        --number 3

    __fed '' '' \
        -m mof -m p -s \
        'Server =' \
        'Server =' \
        -r '' \
        - ''

    [ "$FILE" ] || {
        _err -red - 'reflector: Failed.'
        _err -red - 'Try again on a static network condition.'; exit 1
    }

    __file_write_overwrite;
}

_reflector_de() {
    if [ "$arch_linux" != 1 ]; then
        _info -white - 'Nothing to be done.'

        return 0
    fi

    FILE_PATH \
<<MIRRORLIST
$arch_mirlist
MIRRORLIST

    __FILE_cmd reflector \
        --country Germany \
        --connection-timeout 1 \
        --download-timeout 60 \
        --protocol https \
        --completion-percent 100 \
        --sort rate \
        --threads 8 \
        --latest 15 \
        --number 3

    __fed '' '' \
        -m mof -m p -s \
        'Server =' \
        'Server =' \
        -r '' \
        - ''

    [ "$FILE" ] || {
        _err -red - 'reflector: Failed.'
        _err -red - 'Try again on a static network condition.'; exit 1
    }

    __file_write_overwrite;
}

_resolv_conf() {
    FILE_PATH \
<<'RESOLV_CONF'
/etc/resolv.conf
RESOLV_CONF

    if [ "$dns" = localhost ]; then
        if [ "$ipv6" = 1 ]; then
            FILE \
<<'RESOLV_CONF'
nameserver ::1
nameserver 127.0.0.1
RESOLV_CONF
        else
            FILE \
<<'RESOLV_CONF'
nameserver 127.0.0.1
RESOLV_CONF
        fi

        if [ "$dns0" = dnsmasq ]; then
            FILE \
<<'RESOLV_CONF'
options trust-ad
RESOLV_CONF
        fi

        __file_write;
        __loc_chattr 'i'
    elif [ "$dns" = none ] || [ ! "$dns" ]; then
        __loc_delete;
    fi
}

_sh() {
    FILE_PATH \
<<'DASH'
/usr/bin/dash
DASH

    FILE_PATH_TARGET \
<<'SH'
/usr/bin/sh
SH

    __loc_target_link_overwrite;

    if [ "$arch_linux" = 1 ]; then
        FILE_PATH \
<<'DASHBINSH_HOOK'
/usr/share/libalpm/hooks/dashbinsh.hook
DASHBINSH_HOOK

        FILE \
<<'DASHBINSH_HOOK'
[Trigger]
Type = Package
Operation = Install
Operation = Upgrade
Target = bash

[Action]
Description = Updating /bin/sh symlink to dash...
When = PostTransaction
Exec = /usr/bin/ln -sf /usr/bin/dash /usr/bin/sh
Depends = dash
DASHBINSH_HOOK

        __file_write;
    else
        FILE_PATH \
<<'DASHBINSH_HOOK'
/usr/share/libalpm/hooks/dashbinsh.hook
DASHBINSH_HOOK

        __loc_delete;
    fi
}

_sudo_conf() {
    FILE_PATH \
<<'WHEEL'
/etc/sudoers.d/wheel
WHEEL

    FILE \
<<'WHEEL'
%wheel ALL=(ALL:ALL) ALL
WHEEL

    __file_write;
    __loc_chmod '0440'
}

_sway_conf() {
    FILE_PATH \
<<CONFIG
$home/.config/sway/config
CONFIG

    FILE \
<<'CONFIG'
output * adaptive_sync off
output * allow_tearing yes
output * max_render_time off

# Mod4 = Super key
set $mod Mod4
set $term kitty
set $menu exec \
    $term --class=sway-app-launcher \
    /usr/bin/sway-launcher-desktop

focus_follows_mouse always

# Prevent annoying apps from disrupting active focus by pinning them to a
# certain workplace, in our case `7`, used as a last resort workspace or "bag".
# Steam's "launcher"
assign [title="Steam"] 7
# Steam
assign [class="steam"] 7

# Pin specific apps to specific workspaces.
# FeatherPad
assign [app_id="featherpad"] 2

for_window [app_id="sway-app-launcher"] \
    floating enable, sticky enable, resize set 30 ppt 60 ppt, border pixel 5
for_window [app_id="firefox"] \
    border none

input type:touchpad {
    dwt disabled
    tap enabled
}

input type:keyboard {
    xkb_layout us,bg(phonetic)
    xkb_model pc86
    xkb_options grp:alt_shift_toggle,caps:super
    repeat_delay 222
    repeat_rate 50
}

# Disable mouse acceleration
input type:pointer {
    accel_profile flat
}

# Appearance {
    output * bg #241f31 solid_color
    default_border pixel
    client.focused #0A75AD #0A75AD #0A75AD #0A75AD #0A75AD
    font pango:Cantarell 12
    seat seat0 xcursor_theme Breeze
    exec_always /home/$USER/.config/sway/import-gsettings
    exec_always /home/$USER/.config/sway/wp-handler
# }

# App keybindings {
    bindsym $mod+Return exec $term
    bindsym $mod+a exec $menu
    bindsym $mod+t exec /usr/bin/Telegram
    bindsym $mod+b exec /usr/bin/blueman-manager
# }

# Control keybindings {
    bindsym $mod+1 workspace number 1
    bindsym $mod+2 workspace number 2
    bindsym $mod+3 workspace number 3
    bindsym $mod+4 workspace number 4
    bindsym $mod+5 workspace number 5
    bindsym $mod+6 workspace number 6
    bindsym $mod+7 workspace number 7

    bindsym $mod+Left focus left
    bindsym $mod+Down focus down
    bindsym $mod+Up focus up
    bindsym $mod+Right focus right
    bindsym Alt+Tab focus right
    bindsym Alt+Shift+Tab focus left

    # Basic functions
    bindsym $mod+z exec pamixer -d5
    bindsym $mod+x exec pamixer -i5
    bindsym $mod+c exec brightnessctl s 5%-
    bindsym $mod+v exec brightnessctl s 5%+
    bindsym print exec grim -l 9 $(date +'SS_%Y-%m-%d_%H%M%S.png')
    bindsym $mod+p exec grim -l 9 -g "$(slurp)" \
                            $(date +'SS_%Y-%m-%d_%H%M%S.png')
    bindsym $mod+Shift+p exec grim -l 9 -g "$(slurp; sleep 2.5)" \
                                  $(date +'SS_%Y-%m-%d_%H%M%S.png')

    # Extended functions
    # get hex color of a pixel
    bindsym $mod+h exec grim -g "$(slurp -p)" -t ppm - | \
                        convert - -format '%[pixel:p{0,0}]' txt:- | \
                        tail -n 1 | cut -d ' ' -f 4 | wl-copy -n
    # toggle audio playback
    bindsym $mod+Space exec /home/$USER/.config/sway/music_toggle

    # Kill window
    bindsym $mod+q kill

    # Force kill window
    bindsym $mod+Shift+q exec /home/$USER/.config/sway/fkill

    # Fullscreen window
    bindsym $mod+f fullscreen

    # Drag window by holding down $mod + LMB
    # Resize window by holding down $mod + RMB
    floating_modifier $mod normal

    # Invoke swaylock
    bindsym $mod+l exec swaylock

    # Reload the config
    bindsym $mod+Shift+c reload
# }

mode "nointercept" {
    bindsym $mod+Escape mode "default"
}
bindsym $mod+Shift+Escape mode "nointercept"

bar {
    status_command while /home/$USER/.config/sway/status; do sleep 0.1; done
    position top
    font pango:Source Code Pro 10

    colors {
        statusline #ffffff
        background #2b2e37
        inactive_workspace #32323200 #32323200 #5c5c5c
    }
}

CONFIG

    if [ "$arch_linux" = 1 ]; then
        FILE \
<<'CONFIG'
exec /home/$USER/.config/sway/systemd-handler
CONFIG
    fi

    FILE \
<<'CONFIG'
exec_always sh -c 'rm -f "${TMPDIR:-/tmp}"/nettotal'
CONFIG

    __file_write;

    if [ "$arch_linux" = 1 ]; then
        FILE_PATH \
<<SYSTEMD_HANDLER
$home/.config/sway/systemd-handler
SYSTEMD_HANDLER

        FILE \
<<'SYSTEMD_HANDLER'
#!/bin/sh

systemctl --user import-environment \
    DISPLAY WAYLAND_DISPLAY SWAYSOCK XDG_CURRENT_DESKTOP XDG_SESSION_DESKTOP \
    DESKTOP_SESSION
dbus-update-activation-environment --systemd \
    DISPLAY WAYLAND_DISPLAY SWAYSOCK XDG_CURRENT_DESKTOP XDG_SESSION_DESKTOP \
    DESKTOP_SESSION
SYSTEMD_HANDLER

        if [ "$portal" = 1 ]; then
            FILE \
<<'SYSTEMD_HANDLER'

systemctl --user start \
    xdg-desktop-portal xdg-desktop-portal-gtk xdg-desktop-portal-wlr \
    xdg-document-portal xdg-permission-store
SYSTEMD_HANDLER
        fi

        FILE \
<<'SYSTEMD_HANDLER'

if [ -f /usr/lib/polkit-gnome/polkit-gnome-authentication-agent-1 ]; then
    exec /usr/lib/polkit-gnome/polkit-gnome-authentication-agent-1
fi
SYSTEMD_HANDLER

        __file_write;
        __file_executable;
    else
        FILE_PATH \
<<SYSTEMD_HANDLER
$home/.config/sway/systemd-handler
SYSTEMD_HANDLER

        __loc_delete;
    fi

    FILE_PATH \
<<FKILL
$home/.config/sway/fkill
FKILL

    FILE \
<<'FKILL'
#!/bin/sh

PID=$(
    swaymsg -t get_tree | \
    jq '.. | select(.type?) | select(.focused==true).pid'
)

kill -9 "$PID"
FKILL

    __file_write;
    __file_executable;

    FILE_PATH \
<<IMPORT_GSETTINGS
$home/.config/sway/import-gsettings
IMPORT_GSETTINGS

    FILE \
<<'IMPORT_GSETTINGS'
#!/bin/sh

cfg="${XDG_CONFIG_HOME:-$HOME/.config}/gtk-3.0/settings.ini"

[ -f "$cfg" ] || return 1

gnome_schema='org.gnome.desktop.interface'

while read -r LINE; do
    case "$LINE" in
        'gtk-theme-name='*)
            gsettings set "$gnome_schema" gtk-theme "${LINE#*=}"
        ;;
        'gtk-icon-theme-name='*)
            gsettings set "$gnome_schema" icon-theme "${LINE#*=}"
        ;;
        'gtk-cursor-theme-name='*)
            gsettings set "$gnome_schema" cursor-theme "${LINE#*=}"
        ;;
        'gtk-font-name='*)
            gsettings set "$gnome_schema" font-name "${LINE#*=}"
        ;;
        '#gtk-document-font-name='*)
            gsettings set "$gnome_schema" document-font-name "${LINE#*=}"
        ;;
        '#gtk-monospace-font-name='*)
            gsettings set "$gnome_schema" monospace-font-name "${LINE#*=}"
        ;;
        'gtk-application-prefer-dark-theme='*true*)
            gsettings set "$gnome_schema" color-scheme prefer-dark
        ;;
    esac
done < "$cfg"
IMPORT_GSETTINGS

    __file_write;
    __file_executable;

    FILE_PATH \
<<STATUS
$home/.config/sway/status
STATUS

    FILE \
<<'STATUS'
#!/bin/sh

NET_INTERFACE=wlan0

replchars() {
    replchar() {
        IFS="$1"; _chars="$2"

        set -f; set -- $3 "$3"; set +f

        _str=; while [ "$#" -ge 3 ]; do
            _str="$_str$1$_chars"; shift
        done

        case "$IFS" in
            *"${2#"${2%?}"}"*) _str="$_str$1$_chars" ;;
            *) _str="$_str$1" ;;
        esac
    }

    _old_IFS="$IFS" 2> /dev/null
    ${IFS+':'} unset _old_IFS 2> /dev/null

    replchar "$1" "$2" "$3"

    IFS="$_old_IFS" 2> /dev/null
    ${_old_IFS+':'} unset IFS 2> /dev/null
}

TITLE=$(
    swaymsg -t get_tree | \
    jq -r '.. | select(.type?) | select(.focused==true).name' 2> /dev/null
)
if [ "$TITLE" ]; then
    replchars '&' '&amp;' "$TITLE"; TITLE="$_str";
fi

MEMHOG=$(ps aux 2> /dev/null)
{
CUR=
CUR_F_PERC=
CUR_S_PERC=
while IFS= read -r LINE; do
    set -- $LINE

    case "$4" in
        '%MEM') continue ;;
    esac

    f_perc="${4%.*}"
    s_perc="${4#*.}"

    if [ "$CUR_F_PERC" ]; then
        if [ "$f_perc" -gt "$CUR_F_PERC" ]; then
            CUR="$LINE"
            CUR_F_PERC="$f_perc"
            CUR_S_PERC="$s_perc"
        elif [ "$f_perc" -eq "$CUR_F_PERC" ]; then
            if [ "$s_perc" -gt "$CUR_S_PERC" ]; then
                CUR="$LINE"
                CUR_S_PERC="$s_perc"
            fi
        fi
    else
        CUR="$LINE"
        CUR_F_PERC="$f_perc"
        CUR_S_PERC="$s_perc"
    fi
done \
<<EOF
$MEMHOG
EOF

read -r _ MEMTOTAL_BYTES _ < /proc/meminfo
MEMTOTAL_BYTES=$((MEMTOTAL_BYTES * 1024))

MEMHOG=$(
    set -- $CUR
    printf "%s" "$2 /"  # pid

    CUR="${CUR#*/}"
    set -- $CUR
    printf "%s" "${1##*/} /"  # cmd

    MEMHOG_BYTES=$((MEMTOTAL_BYTES * $CUR_F_PERC$CUR_S_PERC / 1000))  # base 2
    awk -v 'bytes_memhog'="$MEMHOG_BYTES" '
	function hsize(x, base) {
		basesuf = (base == "1024") ? "iB" : "B"

		s = "BKMGTEPYZ"
		while (x >= base && length(s) > 1)
			{x /= base; s = substr(s, 2)}
		s = substr(s, 1, 1)

		xf = (s == "B") ? "%d" : "%.2f"

		if (s != "B")
			s = s basesuf

		printf((xf " %s"), x, s)
	}

	BEGIN {
		printf hsize(bytes_memhog, 1000)
	}
    '  # mem_usage
)
} 2> /dev/null

while :; do
NET_USAGE=
if [ -h /sys/class/net/"$NET_INTERFACE" ]; then
    PREV_TX=0
    PREV_RX=0
    TOTAL=0
    if [ -f "${TMPDIR:-/tmp}"/netprevtx ]; then
        read -r PREV_TX < "${TMPDIR:-/tmp}"/netprevtx
    fi
    if [ -f "${TMPDIR:-/tmp}"/netprevrx ]; then
        read -r PREV_RX < "${TMPDIR:-/tmp}"/netprevrx
    fi
    if [ -f "${TMPDIR:-/tmp}"/nettotal ]; then
        read -r TOTAL < "${TMPDIR:-/tmp}"/nettotal
    fi
    read -r TX < /sys/class/net/"$NET_INTERFACE"/statistics/tx_bytes
    read -r RX < /sys/class/net/"$NET_INTERFACE"/statistics/rx_bytes
    [ "$TX" ] || break
    [ "$RX" ] || break

    if [ "$PREV_TX" = 0 ]; then
        printf "%s\n" "$TX" > "${TMPDIR:-/tmp}"/netprevtx; TX=0
    else
        CUR_TX=$((TX - PREV_TX))
    fi

    if [ "$PREV_RX" = 0 ]; then
        printf "%s\n" "$RX" > "${TMPDIR:-/tmp}"/netprevrx; RX=0
    else
        CUR_RX=$((RX - PREV_RX))
    fi

    if [ "$TX" = 0 ] || [ "$RX" = 0 ]; then
        break
    fi

    TOTAL=$((TOTAL + (CUR_TX + CUR_RX)))

    printf "%s\n" "$TX" > "${TMPDIR:-/tmp}"/netprevtx
    printf "%s\n" "$RX" > "${TMPDIR:-/tmp}"/netprevrx
    printf "%s\n" "$TOTAL" > "${TMPDIR:-/tmp}"/nettotal

    NET_USAGE=$(awk -v 'bytes_tx'="$CUR_TX" -v 'bytes_rx'="$CUR_RX" \
                    -v 'bytes_total'="$TOTAL" '
	function hsize(x, base) {
		basesuf = (base == "1024") ? "iB" : "B"

		s = "BKMGTEPYZ"
		while (x >= base && length(s) > 1)
			{x /= base; s = substr(s, 2)}
		s = substr(s, 1, 1)

		xf = (s == "B") ? "%d" : "%.2f"

		if (s != "B")
			s = s basesuf

		printf((xf " %s"), x, s)
	}

	BEGIN {
		printf "UDT"
		printf " /"
		printf hsize(bytes_tx, 1000)
		printf " /"
		printf hsize(bytes_rx, 1000)
		printf " /"
		printf hsize(bytes_total, 1000)
	}
    ' 2> /dev/null)
fi
break; done

PREV_IDLE=0
PREV_TOTAL=0
if [ -f "${TMPDIR:-/tmp}"/cpustatprevi ]; then
    read -r PREV_IDLE < "${TMPDIR:-/tmp}"/cpustatprevi
fi
if [ -f "${TMPDIR:-/tmp}"/cpustatprevt ]; then
    read -r PREV_TOTAL < "${TMPDIR:-/tmp}"/cpustatprevt
fi
read -r line < /proc/stat
PFIX="${line%%[0123456789]*}"
SFIX="${line#*[0123456789]}"
case "$SFIX" in
    [0123456789]*)
        SFIX="${SFIX#"${SFIX%%[!0123456789]*}"}"
    ;;
esac
IDLE="${line#"$PFIX"}"
IDLE="${IDLE%"$SFIX"}"
LINE="$PFIX$IDLE$SFIX"
x=0; while [ "$x" -ne 3 ]; do
    LINE="${LINE#"$PFIX$IDLE"}"
    PFIX="$PFIX$IDLE${LINE%%[0123456789]*}"
    SFIX="${LINE#*[0123456789]}"
    case "$SFIX" in
        [0123456789]*)
            SFIX="${SFIX#"${SFIX%%[!0123456789]*}"}"
        ;;
    esac
    IDLE="${LINE#"${LINE%%[0123456789]*}"}"
    IDLE="${IDLE%"$SFIX"}"
    LINE="$PFIX$IDLE$SFIX"
    x=$((x + 1))
done
PFIX="${line%%[0123456789]*}"
SFIX="${line#*[0123456789]}"
case "$SFIX" in
    [0123456789]*)
        SFIX="${SFIX#"${SFIX%%[!0123456789]*}"}"
    ;;
esac
_TOTAL="${line#"$PFIX"}"
_TOTAL="${_TOTAL%"$SFIX"}"
TOTAL="$_TOTAL"
LINE="$PFIX$_TOTAL$SFIX"
x=0; while [ "$x" -ne 6 ]; do
    LINE="${LINE#"$PFIX$_TOTAL"}"
    PFIX="$PFIX$_TOTAL${LINE%%[0123456789]*}"
    SFIX="${LINE#*[0123456789]}"
    case "$SFIX" in
        [0123456789]*)
            SFIX="${SFIX#"${SFIX%%[!0123456789]*}"}"
        ;;
    esac
    _TOTAL="${LINE#"${LINE%%[0123456789]*}"}"
    _TOTAL="${_TOTAL%"$SFIX"}"
    TOTAL=$((TOTAL + _TOTAL))
    LINE="$PFIX$_TOTAL$SFIX"
    x=$((x + 1))
done
printf "%s\n" "$IDLE" > "${TMPDIR:-/tmp}"/cpustatprevi
printf "%s\n" "$TOTAL" > "${TMPDIR:-/tmp}"/cpustatprevt
DIFF_IDLE=$((IDLE - PREV_IDLE))
DIFF_TOTAL=$((TOTAL - PREV_TOTAL))
CPU=$(((1000 * (DIFF_TOTAL - DIFF_IDLE) / DIFF_TOTAL + 5) / 10))

{ while read -r LINE; do
    case "$LINE" in
        'MemAvailable:'*)
            PFIX="${LINE%%[0123456789]*}"
            SFIX="${LINE#*[0123456789]}"
            case "$SFIX" in
                [0123456789]*)
                    SFIX="${SFIX#"${SFIX%%[!0123456789]*}"}"
                ;;
            esac

            MEMORY="${LINE#"$PFIX"}"
            MEMORY="${MEMORY%"$SFIX"}"
            MEMORY=$((MEMORY * 1024))

            MEMORY=$(awk -v 'bytes'="$MEMORY" '
function hsize(x, base) {
	basesuf = (base == "1024") ? "iB" : "B"

	s = "BKMGTEPYZ"
	while (x >= base && length(s) > 1)
		{x /= base; s = substr(s, 2)}
	s = substr(s, 1, 1)

	xf = (s == "B") ? "%d" : "%.2f"

	if (s != "B")
		s = s basesuf

	printf((xf " %s"), x, s)
}

BEGIN {
	printf hsize(bytes, 1000)
}
            ' 2> /dev/null)
        ;;
    esac
done < /proc/meminfo; } 2> /dev/null

{ read -r BATTERY < /sys/class/power_supply/BAT0/capacity; } 2> /dev/null

VOLUME=$(pamixer --get-volume 2> /dev/null)

AUDIO_SINK=$(pactl list sinks 2> /dev/null)
{
_STATE=; _NAME=
while IFS= read -r LINE; do
    case "$LINE" in
        *'State: RUNNING'*) _STATE=1 ;;
    esac

    case "$LINE" in
        *'Name: '*)
            if [ "$_STATE" = 1 ]; then
                _NAME="${LINE#*Name: }"; break
            fi
        ;;
    esac
done \
<<EOF
$AUDIO_SINK
EOF

AUDIO_SINK="$_NAME"
} 2> /dev/null
case "$AUDIO_SINK" in
    'alsa_output'*) AUDIO_SINK=ALSA ;;
    'bluez_output'*) AUDIO_SINK=BLUEZ ;;
esac

KB_LAYOUT=$(
    swaymsg -t get_inputs | \
    jq 'map(select(has("xkb_active_layout_name")))[0].xkb_active_layout_name'
)
case "$KB_LAYOUT" in
    *'English'*)
        KB_LAYOUT=EN
    ;;
    *'Bulgarian'*)
        KB_LAYOUT=BG
    ;;
esac

DATE=$(date "+%A%_d,%_I:%M %p" 2> /dev/null)
while :; do case "$DATE" in
    *[0123456789]','[0123456789]*)
        DATE="${DATE%\,*}, ${DATE#*\,}"
    ;;
    *'day'[0123456789]*)
        DATE="${DATE%day*}day ${DATE#*day}"
    ;;
    *)
        break
    ;;
esac done

STATUS="$TITLE | $MEMHOG"
if [ "$NET_USAGE" ]; then
    STATUS="$STATUS | $NET_USAGE"
fi
STATUS="$STATUS | ${CPU}% | $MEMORY"
case "$BATTERY" in
    100) : ;;
    *) STATUS="$STATUS | ~${BATTERY}%" ;;
esac
STATUS="$STATUS | ${VOLUME}%"
if [ "$AUDIO_SINK" ]; then
    STATUS="$STATUS | $AUDIO_SINK"
fi
STATUS="$STATUS | $KB_LAYOUT | $DATE |"

printf "%s" "$STATUS"
STATUS

    __file_write;
    __file_executable;

    FILE_PATH \
<<MUSIC_TOGGLE
$home/.config/sway/music_toggle
MUSIC_TOGGLE

    FILE \
<<'MUSIC_TOGGLE'
#!/bin/sh

MOCP_STATE=$(mocp -Q %state)
MOCP_PAUSE_FILE="${TMPDIR:-/tmp}"/music_toggle_mocp

if [ -f "$MOCP_PAUSE_FILE" ]; then
    if playerctl status 2> /dev/null | grep -q 'Playing'; then
        playerctl play-pause
    elif [ "$MOCP_STATE" = 'PAUSE' ]; then
        mocp -U
    fi

    rm -f "$MOCP_PAUSE_FILE"
    exit 0
elif [ "$MOCP_STATE" = 'PLAY' ]; then
    mocp -P
    : > "$MOCP_PAUSE_FILE"
    exit 0
fi

playerctl play-pause > /dev/null 2>&1
MUSIC_TOGGLE

    __file_write;
    __file_executable;

    FILE_PATH \
<<WP_HANDLER
$home/.config/sway/wp-handler
WP_HANDLER

    FILE \
<<'WP_HANDLER'
#!/bin/sh

WP_HANDLER

    FILE \
<<WP_HANDLER
WP=$home/.config/sway/wp
WP_HANDLER

    FILE \
<<'WP_HANDLER'
WP_NEW="${TMPDIR:-/tmp}"/wp

if [ -f "$WP_NEW" ]; then
    swaymsg output '*' bg "$WP_NEW" fill
elif [ -f "$WP" ]; then
    swaymsg output '*' bg "$WP" fill
fi
WP_HANDLER

    __file_write;
    __file_executable;
}

_sway_conf_gaming() {
    FILE_PATH \
<<CONFIG
$home/.config/sway/config
CONFIG

    FILE \
<<'CONFIG'
output * adaptive_sync off
output * allow_tearing yes
output * max_render_time off

# Mod4 = Super key
set $mod Mod4
set $term kitty
set $menu exec \
    $term --class=sway-app-launcher \
    /usr/bin/sway-launcher-desktop

focus_follows_mouse always

# Prevent annoying apps from disrupting active focus by pinning them to a
# certain workplace, in our case `7`, used as a last resort workspace or "bag".
# Steam's "launcher"
assign [title="Steam"] 7
# Steam
assign [class="steam"] 7

# Pin specific apps to specific workspaces.
# FeatherPad
assign [app_id="featherpad"] 2

for_window [app_id="sway-app-launcher"] \
    floating enable, sticky enable, resize set 30 ppt 60 ppt, border pixel 5
for_window [app_id="firefox"] \
    border none

input type:touchpad {
    dwt disabled
    tap enabled
}

input type:keyboard {
    xkb_layout us,bg(phonetic)
    xkb_model pc86
    xkb_options grp:alt_shift_toggle
    repeat_delay 222
    repeat_rate 50
}

# Disable mouse acceleration
input type:pointer {
    accel_profile flat
}

# Appearance {
    output * bg #241f31 solid_color
    default_border pixel
    client.focused #0A75AD #0A75AD #0A75AD #0A75AD #0A75AD
    font pango:Cantarell 12
    seat seat0 xcursor_theme Breeze
    exec_always /home/$USER/.config/sway/import-gsettings
    exec_always /home/$USER/.config/sway/wp-handler
# }

# App keybindings {
    bindsym $mod+Return exec $term
    bindsym $mod+a exec $menu
    bindsym $mod+t exec /usr/bin/Telegram
    bindsym $mod+b exec /usr/bin/blueman-manager
# }

# Control keybindings {
    bindsym $mod+1 workspace number 1
    bindsym $mod+2 workspace number 2
    bindsym $mod+3 workspace number 3
    bindsym $mod+4 workspace number 4
    bindsym $mod+5 workspace number 5
    bindsym $mod+6 workspace number 6
    bindsym $mod+7 workspace number 7

    bindsym $mod+Left focus left
    bindsym $mod+Down focus down
    bindsym $mod+Up focus up
    bindsym $mod+Right focus right
    bindsym Alt+Tab focus right
    bindsym Alt+Shift+Tab focus left

    # Basic functions
    bindsym $mod+z exec pamixer -d5
    bindsym $mod+x exec pamixer -i5
    bindsym $mod+c exec brightnessctl s 5%-
    bindsym $mod+v exec brightnessctl s 5%+
    bindsym print exec grim -l 9 $(date +'SS_%Y-%m-%d_%H%M%S.png')
    bindsym $mod+p exec grim -l 9 -g "$(slurp)" \
                            $(date +'SS_%Y-%m-%d_%H%M%S.png')
    bindsym $mod+Shift+p exec grim -l 9 -g "$(slurp; sleep 2.5)" \
                                  $(date +'SS_%Y-%m-%d_%H%M%S.png')

    # Extended functions
    # get hex color of a pixel
    bindsym $mod+h exec grim -g "$(slurp -p)" -t ppm - | \
                        convert - -format '%[pixel:p{0,0}]' txt:- | \
                        tail -n 1 | cut -d ' ' -f 4 | wl-copy -n
    # toggle audio playback
    bindsym $mod+Space exec /home/$USER/.config/sway/music_toggle

    # Kill window
    bindsym $mod+q kill

    # Force kill window
    bindsym $mod+Shift+q exec /home/$USER/.config/sway/fkill

    # Fullscreen window
    bindsym $mod+f fullscreen

    # Drag window by holding down $mod + LMB
    # Resize window by holding down $mod + RMB
    floating_modifier $mod normal

    # Invoke swaylock
    bindsym $mod+l exec swaylock

    # Reload the config
    bindsym $mod+Shift+c reload
# }

mode "nointercept" {
    bindsym $mod+Escape mode "default"
}
bindsym $mod+Shift+Escape mode "nointercept"

bar {
    position top
    font pango:Source Code Pro 10

    colors {
        statusline #ffffff
        background #2b2e37
        inactive_workspace #32323200 #32323200 #5c5c5c
    }
}

CONFIG

    if [ "$arch_linux" = 1 ]; then
        FILE \
<<'CONFIG'
exec /home/$USER/.config/sway/systemd-handler
CONFIG
    fi

    FILE \
<<'CONFIG'
exec_always sh -c 'rm -f "${TMPDIR:-/tmp}"/nettotal'
CONFIG

    __file_write_overwrite;
}

_swaylock_conf() {
    FILE_PATH \
<<CONFIG
$home/.swaylock/config
CONFIG

    FILE \
<<'CONFIG'
color=2b2e37
indicator-idle-visible
inside-color=2b2e37
ring-color=0A75AD
layout-bg-color=2b2e37
layout-border-color=2b2e37
CONFIG

    __file_write;
}

_sysctl_conf() {
    FILE_PATH \
<<'99_SYSCTL_CONF'
/etc/sysctl.d/99-sysctl.conf
99_SYSCTL_CONF

    FILE \
<<'99_SYSCTL_CONF'
kernel.sysrq = 1
99_SYSCTL_CONF

    __file_write;
}

_tz() {
    if [ "$bg" = 1 ]; then
        _tz_bg;
    elif [ "$de" = 1 ]; then
        _tz_de;
    else
        _info -white - 'Nothing to be done.'

        return 0
    fi
}

# Bulgarian timezone (Europe/Sofia)
_tz_bg() {
    FILE_PATH \
<<'SOFIA'
/usr/share/zoneinfo/Europe/Sofia
SOFIA

    FILE_PATH_TARGET \
<<'LOCALTIME'
/etc/localtime
LOCALTIME

    __loc_target_link_overwrite;

    __cmd hwclock -w
}

# German timezone (Europe/Berlin)
_tz_de() {
    FILE_PATH \
<<'BERLIN'
/usr/share/zoneinfo/Europe/Berlin
BERLIN

    FILE_PATH_TARGET \
<<'LOCALTIME'
/etc/localtime
LOCALTIME

    __loc_target_link_overwrite;

    __cmd hwclock -w
}

_xdg_conf() {
    FILE_PATH \
<<MIMEAPPS_LIST
$home/.config/mimeapps.list
MIMEAPPS_LIST

    FILE \
<<'MIMEAPPS_LIST'
# Programs that support:
[Added Associations]
application/json=featherpad.desktop
application/javascript=firefox.desktop

# Programs that don't support:
[Removed Associations]

# Programs that will be used to open by default:
[Default Applications]
# /usr/lib/firefox/firefox: URLs / `.html` / `.pdf` / `.json`
x-scheme-handler/http=firefox.desktop
x-scheme-handler/https=firefox.desktop
text/html=firefox.desktop
application/pdf=firefox.desktop
application/json=firefox.desktop
# /usr/bin/featherpad: Text / Empty file / `.patch`/`.diff` / `.sh` / `.c` /
# JavaScript source
text/plain=featherpad.desktop
inode/x-empty=featherpad.desktop
text/x-diff=featherpad.desktop
text/x-shellscript=featherpad.desktop
text/x-c=featherpad.desktop
application/javascript=featherpad.desktop
MIMEAPPS_LIST

    __file_write;

    FILE_PATH_TARGET \
<<MIMEAPPS_LIST
$home/.local/share/applications/mimeapps.list
MIMEAPPS_LIST

    __loc_target_link_overwrite;

    FILE_PATH \
<<INDEX_THEME
$home/.icons/default/index.theme
INDEX_THEME

    FILE \
<<'INDEX_THEME'
[icon theme]
Inherits=Breeze
INDEX_THEME

    __file_write;
}

#! .desc:
# Assert the passed arguments match BRE: [0-9A-Za-z_-]
#! .params:
# <"$1"+> - argument
#! .gives:
# (0) <"$_arg"> - the last argument
# (1) <"$_arg"> - the bad argument
#! .rc:
# (0) yes
# (1) no
# (255) bad input
#.
main_assert_args() {
    assert -min "$#" 1 || return 255

    for _arg in "$@"; do
        [ "$_arg" ] || return 255

        case "$_arg" in
            *[!0-9A-Za-z_-]*) return 1 ;;
        esac
    done
}

#! .desc:
# Assert the passed arguments are valid operations
#! .params:
# <"$1"+> - operation
#! .uses:
# <ops> $ - the list of operations
#! .gives:
# (0) <"$_opd"> - the last operation
# (1) <"$_opd"> - the bad operation
#! .rc:
# (0) yes
# (1) no
# (255) bad input
#.
main_assert_ops() {
    assert -min "$#" 1 || return 255

    for _opd in "$@"; do
        [ "$_opd" ] || return 255

        case "$ops" in
            "$_opd "* | *" $_opd" | *" $_opd "*) : ;;
            *) return 1 ;;
        esac
    done
}

err_handler() {
    IFS=' 	''
'

    trap - INT TERM EXIT

    # env cleanup
    if [ -e "$tmpd" ] || [ -e "$tmpf" ] || [ -e "$logf" ]; then
        chattr -R -ia "$tmpd" "$tmpf" "$logf" > /dev/null 2>&1 || :
        rm -rf "$tmpd" "$tmpf" "$logf"
    fi

    if [ "$1" = 0 ]; then
        exit 0
    elif [ "$2" = INT ]; then
        err -red - "${0##*/}: Received INT signal. ($1)"; kill -2 "$$"
    else
        err -red - "${0##*/}: Received $2 signal. ($1)"; exit "$1"
    fi
}

main() {
    LC_ALL=C; export LC_ALL
    set -e
    trap "err_handler \$? INT" INT
    trap "err_handler \$? TERM" TERM
    trap "err_handler \$? EXIT" EXIT

    # Control switches
    # Always write files, even if the remote/fs content matches ours.
    always_write=0
    # Automatically continue/confirm any CRC32 mismatch prompts.
    confirm_crc=0
    # Force file writes by remote/fs object overwrite/removal:
    force_write=0
    # Interactive mode; prompt for input on dual actions.
    interactive=0
    # Disable command output:
    silent_cmd=0
    # Disable content output of file writes:
    silent_write=0

    # Device switches
    # ASUS VivoBook S15 X521IA-M533IA (AMD):
    m533ia=1

    # OS switches
    # Arch Linux system:
    arch_linux=1

    # Software switches
    # Configure highest audio resampling quality possible when resampling:
    audio_hq_resamp=0
    # Bluetooth support (D-Bus dependent)
    bluetooth=1
    # Configure and prefer IPv6 over IPv4:
    ipv6=0
    # XDG portals support (D-Bus dependent protocols)
    portal=1

    # Location switches
    # Bulgaria:
    bg=0
    # Germany:
    de=1

    # Software
    # Audio player daemon; currently supported: moc, none
    audio_playerd='moc'
    # Audio server; currently supported: pipewire, none
    audio_server='pipewire'
    # Web browser; currently supported: firefox, none
    browser='firefox'
    # Display server; currently supported: wayland, none
    display_server='wayland'
    # DNS; currently supported: localhost, none
    dns='localhost'
    # Dedicated DNS (stub) resolver (localhost); currently supported: dnsmasq,
    # none
    dns0='dnsmasq'
    # Init system; currently supported: systemd, none
    init='systemd'
    # Pipewire manager; currently supported: pipewire, none
    pipewire_manager='pipewire'
    # QT theme engine; currently supported: kvantum, none
    qt_theme='kvantum'
    # WLAN daemon; currently supported: iwd, none
    wland='iwd'
    # Window manager / desktop environment; currently supported: sway, none
    wm='sway'

    # Data
    gid='1000'
    group='mscalindt'
    hostname='syscfg'
    uid='1000'
    user='mscalindt'

    # Locations
    home='/home/mscalindt'
    efi_mnt='/efi'
    arch_mirlist='/etc/pacman.d/mirrorlist'

    # Operations
    ops=
    ops="$ops alsa-conf"
    ops="$ops autostart"
    ops="$ops bash-conf"
    ops="$ops bluez-conf"
    ops="$ops clk-sync"
    ops="$ops conf-1"
    ops="$ops conf-2"
    ops="$ops conf-3"
    ops="$ops conf-4"
    ops="$ops dhcpcd-conf"
    ops="$ops dnsmasq-conf"
    ops="$ops doas-conf"
    ops="$ops env"
    ops="$ops face-bin"
    ops="$ops featherpad-conf"
    ops="$ops firefox-conf"
    ops="$ops fontconfig-conf"
    ops="$ops fuse-conf"
    ops="$ops gai-conf"
    ops="$ops git-conf"
    ops="$ops gov-performance"
    ops="$ops gov-schedutil"
    ops="$ops grub grub-conf"
    ops="$ops gtk-conf"
    ops="$ops hostname"
    ops="$ops hosts"
    ops="$ops imv-conf"
    ops="$ops initramfs-conf"
    ops="$ops iwd-conf"
    ops="$ops kitty-conf"
    ops="$ops kvantum-conf"
    ops="$ops locale"
    ops="$ops makepkg-conf"
    ops="$ops moc-conf"
    ops="$ops modprobe-conf"
    ops="$ops mpv-conf"
    ops="$ops mutt-conf"
    ops="$ops nano-conf"
    ops="$ops nvram-clr"
    ops="$ops openal-conf"
    ops="$ops pacman-conf"
    ops="$ops pam-conf"
    ops="$ops pipewire-conf"
    ops="$ops pipewire-media-session-conf"
    ops="$ops ranger-conf"
    ops="$ops reflector"
    ops="$ops resolv-conf"
    ops="$ops sh"
    ops="$ops sudo-conf"
    ops="$ops sway-conf"
    ops="$ops sway-conf-gaming"
    ops="$ops swaylock-conf"
    ops="$ops sysctl-conf"
    ops="$ops tz"
    ops="$ops xdg-conf"
    ops="${ops# }"

    # Utility internal locations
    # Temporary per-function dir (cleared on func exit):
    tmpd="${TMPDIR:-/tmp}/syscfg_tmpd"
    # Temporary per-function file (cleared on func exit):
    tmpf="${TMPDIR:-/tmp}/syscfg_tmpf"
    # Temporary per-function log file (cleared on func exit):
    logf="${TMPDIR:-/tmp}/syscfg_logf"

    # Enable always_write from cmdline:    ^AW as $1
    # Enable audio_hq_resamp from cmdline: ^AQ as $1
    # Enable confirm_crc from cmdline:     ^CC as $1
    # Enable force_write from cmdline:     ^FW as $1
    # Enable interactive from cmdline:     ^IE as $1
    # Enable ipv6 from cmdline:            ^I6 as $1
    # Enable silent_cmd from cmdline:      ^SC as $1
    # Enable silent_write from cmdline:    ^SW as $1
    while :; do case "$1" in
        '^AW') always_write=1; shift && continue ;;
        '^AQ') audio_hq_resamp=1; shift && continue ;;
        '^CC') confirm_crc=1; shift && continue ;;
        '^FW') force_write=1; shift && continue ;;
        '^IE') interactive=1; shift && continue ;;
        '^I6') ipv6=1; shift && continue ;;
        '^SC') silent_cmd=1; shift && continue ;;
        '^SW') silent_write=1; shift && continue ;;
        *) break ;;
    esac done

    # `^AW` implies `^AW ^FW`.
    if [ "$always_write" = 1 ] && [ "$force_write" = 0 ]; then
        info -white -- "${0##*/}: "
        info -yellow - 'Assuming `^AW ^FW`.'

        force_write=1

        if [ "$interactive" = 1 ]; then
            confirm_cont -y || {
                info -white -- "${0##*/}: "
                info -white - 'Interactive correction: `^AW`.'

                force_write=0
            }
        fi
    fi

    readonly tmpd tmpf logf always_write force_write m533ia \
             arch_linux audio_hq_resamp bluetooth browser dns dns0 init \
             ipv6 qt_theme display_server wm bg de user home efi_mnt \
             arch_mirlist ops audio_server hostname wland audio_playerd portal \
             silent_cmd silent_write gid group uid pipewire_manager \
             confirm_crc interactive

    { assert -min "$#" 1 && main_assert_ops "$@"; } || {
        if [ "$#" -eq 0 ]; then
            err -red - 'No operation has been specified.'
        else
            err -red - "Unrecognized operation: '$_opd'"
        fi

        ifs_map "$ops" info -white -
        info -white - 'SWITCH: always_write ^AW'
        info -white - 'SWITCH: audio_hq_resamp ^AQ'
        info -white - 'SWITCH: confirm_crc ^CC'
        info -white - 'SWITCH: force_write ^FW'
        info -white - 'SWITCH: interactive ^IE'
        info -white - 'SWITCH: ipv6 ^I6'
        info -white - 'SWITCH: silent_cmd ^SC'
        info -white - 'SWITCH: silent_write ^SW'

        exit 2
    }

    main_assert_args "$@" || {
        err -red - "Bad argument: '$_arg'."

        info -white - "Allowed characters: 0-9A-Za-z_-"

        exit 2
    }

    # end arg parsing; main()

    [ "$(id -u)" = 0 ] || {
        err -red - 'Missing root rights.'; exit 1
    }

    # past env cleanup from SIGKILL or something else
    if [ -e "$tmpd" ] || [ -e "$tmpf" ] || [ -e "$logf" ]; then
        chattr -R -ia "$tmpd" "$tmpf" "$logf" > /dev/null 2>&1 || :
        rm -rf "$tmpd" "$tmpf" "$logf"
    fi

    while [ "$1" ]; do
        replchar_posix '-' '_' "$1" && set -- "_$_str" "$@"

        # env setup
        ( umask 077; mkdir "$tmpd"; : > "$tmpf" > "$logf"; )

        ( opd="$1"; readonly opd; "$opd"; )

        # env reset
        if [ -e "$tmpd" ] || [ -e "$tmpf" ] || [ -e "$logf" ]; then
            chattr -R -ia "$tmpd" "$tmpf" "$logf" > /dev/null 2>&1 || :
            rm -rf "$tmpd" "$tmpf" "$logf"
        fi

        info -green - "${0##*/}:" "$2:" 'Done!'

        shift 2
    done

    return 0
}

assertive_functions;
helper_functions;
utility_functions;
utility_functions_err;
utility_functions_out;
main "$@"
