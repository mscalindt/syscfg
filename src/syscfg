#!/bin/sh
# Copyright (C) 2021-2025 Dimitar Yurukov <mscalindt@protonmail.com>
#
# syscfg - declarative OS configuration
#
# Table of syscfg-defined error codes:
# ---
# (1): EERROR: "General operation error".
# ---
# STANDARD:
# (1): EPERM: "Operation not permitted".
# (2): ENOENT: "No such file or directory".
# (17): EEXIST: "Already exists".
# (20): ENOTDIR: "Not a directory".
# (21): EISDIR: "Is a directory".
# (22): EINVAL: "Invalid argument".
# ---
# SPECIAL CUSTOM:
# (255): Bad function input/usage error.
#
# Use to_octal() or to_octal_offset() to obtain the POSIX shell-compatible
# octal escape sequence(s) of octal byte streams produced by `od -b -An` or
# `od -b`, respectively.

# Maintainer note for any functions in assertive_functions():
#
# Assertive functions shall not return `255` on empty input, and instead,
# simply return true/false appropriately. `255` is only returned when input is
# unspecified. If a function cannot adhere to the aforementioned, it does not
# belong in assertive_functions().
assertive_functions() { # START assertive_functions
    :
} # END assertive_functions

helper_functions() { # START helper_functions
    :
} # END helper_functions

# Maintainer note for any functions in utility_functions():
#
# Utility functions shall always begin with two underscore characters.
utility_functions() { # START utility_functions
    :
} # END utility_functions

# Maintainer note for any functions in utility_functions_err():
#
# Utility error functions shall always begin with an underscore character.
utility_functions_err() { # START utility_functions_err
    :
} # END utility_functions_err

# Maintainer note for any functions in utility_functions_out():
#
# Utility output functions shall always begin with an underscore character.
utility_functions_out() { # START utility_functions_out
#! .desc:
# Print formatted text to stderr (syscfg client string)
#! .params:
# <"$@"> - err()
#! .desc.ext:
# For more information, refer to the documentation of err().
#.
_err() {
    _clr="$1"
    _fmt="$2"

    shift 2 && set -- "$_clr" "$_fmt" "[E $$ $opd]" "$@"

    err "$@"
}

#! .desc:
# Print formatted text to stdout (syscfg client string)
#! .params:
# <"$@"> - info()
#! .desc.ext:
# For more information, refer to the documentation of info().
#.
_info() {
    _clr="$1"
    _fmt="$2"

    shift 2 && set -- "$_clr" "$_fmt" "[I $$ $opd]" "$@"

    info "$@"
}
} # END utility_functions_out

# START boilerplate_functions

#! .desc:
# Check if a command exists
#! .params:
# <"$1"> - command
#! .rc:
# (0) yes
# (*) no
# (255) bad input
#.
cmd() {
    assert -eq "$#" 1 || return 255

    command -v "$1" > /dev/null 2>&1
}

#! .desc:
# Check if a given path is a directory
#! .params:
# <"$1"> - path
#! .rc:
# (0) yes
# (1) no
# (255) bad input
#.
dir() {
    assert -eq "$#" 1 || return 255

    [ -d "$1" ]
}

#! .desc:
# Check if a given path exists
#! .params:
# <"$1"> - path
#! .rc:
# (0) yes
# (1) no
# (255) bad input
#.
exist() {
    assert -eq "$#" 1 || return 255

    [ -e "$1" ]
}

#! .desc:
# Check if a given path is a regular file
#! .params:
# <"$1"> - path
#! .rc:
# (0) yes
# (1) no
# (255) bad input
#.
file() {
    assert -eq "$#" 1 || return 255

    [ -f "$1" ]
}

#! .desc:
# Assert a given string is strict POSIX shell-compatible octal escape
# sequence(s)
#! .params:
# <["$1"]> - string
#! .uses.fn:
# <assert> ('-eq' '$#' '1');
#          Assert a string
#! .uses.util:
# <awk> ("program" '$1');
#       pattern scanning and processing language
#! .rc.fn:
# (assert) (255) bad input
#! .rc.util:
# (awk) (0) true
# (awk) (1) false / error
# (awk) (*) error
#.
is_octal() {
    assert -eq "$#" 1 || return 255

    awk '
function is_valid_chunk(chunk) {
	return chunk ~ /^\\0[0-7]{3}$/ ? 0 : 1
}

BEGIN {
	string=ARGV[1]
	delete ARGV

	if (length(string) % 5 != 0)
		exit 1

	for (i = 1; i <= length(string); i += 5) {
		chunk = substr(string, i, 5)

		if (is_valid_chunk(chunk) == 1)
			exit 1
	}

	exit 0
}
    ' "$1"
}

#! .desc:
# Check if the system is booted in UEFI mode
#! .rc:
# (0) yes
# (1) no
#.
is_uefi() {
    dir '/sys/firmware/efi/efivars'
}

#! .desc:
# Check if a given path is readable
#! .params:
# <"$1"> - path
#! .rc:
# (0) yes
# (1) no
# (255) bad input
#.
readable() {
    assert -eq "$#" 1 || return 255

    [ -r "$1" ]
}

#! .desc:
# Check if text appears anywhere in a given string
#! .params:
# <"$1"> - text
# <"$2"> - string
#! .rc:
# (0) yes
# (1) no
# (255) bad input
#.
str() {
    assert -eq "$#" 2 || return 255

    case "$2" in
        *"$1"*) return 0 ;;
    esac

    return 1
}

#! .desc:
# Check if text appears at the left side of a given string
#! .params:
# <"$1"> - text
# <"$2"> - string
#! .rc:
# (0) yes
# (1) no
# (255) bad input
#.
str_pfix() {
    assert -eq "$#" 2 || return 255

    case "$2" in
        "$1"*) return 0 ;;
    esac

    return 1
}

#! .desc:
# Check if text appears at the right side of a given string
#! .params:
# <"$1"> - text
# <"$2"> - string
#! .rc:
# (0) yes
# (1) no
# (255) bad input
#.
str_sfix() {
    assert -eq "$#" 2 || return 255

    case "$2" in
        *"$1") return 0 ;;
    esac

    return 1
}

#! .desc:
# Check if a given path is writable
#! .params:
# <"$1"> - path
#! .rc:
# (0) yes
# (1) no
# (255) bad input
#.
writable() {
    assert -eq "$#" 1 || return 255

    [ -w "$1" ]
}

# END boilerplate_functions
# START output_functions

# END output_functions
# START utility_functions

#! .desc:
# Print bytes in human-readable fmt: "N" "X"iB / "N" "X"B
#! .params:
# <$1> - bytes
#! .rc:
# (0) success
# (*) error
# (255) bad input
#.
bytes_size() {
    assert -eq "$#" 1 || return 255

    awk -v 'bytes'="$1" '
	function hsize(x, base) {
		basesuf = (base == "1024") ? "iB" : "B"

		s = "BKMGTEPYZ"
		while (x >= base && length(s) > 1)
			{x /= base; s = substr(s, 2)}
		s = substr(s, 1, 1)

		xf = (s == "B") ? "%d" : "%.2f"

		if (s != "B")
			s = s basesuf

		printf((xf " %s"), x, s)
	}

	BEGIN {
		printf hsize(bytes, 1024)
		printf " / "
		print hsize(bytes, 1000)
	}
    ' 2> /dev/null
}

#! .desc:
# Remove the filesystem flag protection of a physical file
#! .params:
# <"$1"> - absolute path
#! .rc:
# (0) success
# (*) error
# (255) bad input
#.
chattr_remove() {
    assert -eq "$#" 1 || return 255

    cmd 'chattr' || return 0

    { [ -f "$1" ] && [ ! -h "$1" ]; } || return 0

    chattr -ia "$1" 2> /dev/null || :
}

#! .desc:
# Create the parents of a file/directory
#! .params:
# <"$1"> - absolute path
#! .rc:
# (0) success
# (*) error
# (255) bad input
#.
mkdir_parents() {
    assert -eq "$#" 1 || return 255

    if str_sfix '/' "$1"; then
        set -- "${1%?}"
    fi

    if dir "${1%/*}"; then
        return 0
    fi

    # Shall consider implementing 'mkdir -p' within the shell by path
    # traversing the function argument and passing separate consequental
    # arguments to mkdir. Important to note that in such situation, error
    # handling would be on us, including the handling of race conditions.
    mkdir -p "${1%/*}" 2> /dev/null
}

#! .desc:
# Print the return code of a command
#! .params:
# <"$1"> - command
# ["$2"+] - arguments
#! .rc:
# (0) success
# (127) command does not exist
# (255) bad input
#.
rc() {
    assert -min "$#" 1 || return 255

    if cmd "$1"; then
        "$@" > /dev/null 2>&1
        printf "%d" "$?"
    else
        return 127
    fi

    return 0
}

#! .desc:
# Print POSIX shell-compatible octal escape sequence(s) of `od -b -An` string
#! .params:
# <["$1"]> - string
#! .uses.fn:
# <assert> ('-eq' '$#' '1');
#          Assert a string
#! .rc:
# (0) success
# (*) error
#! .rc.fn:
# (assert) (255) bad input
#.
to_octal() {
    assert -eq "$#" 1 || return 255

    for _octal in $1; do
        printf "%s" "\\0$_octal"
    done
}

#! .desc:
# Print POSIX shell-compatible octal escape sequence(s) of `od -b` string
#! .params:
# <["$1"]> - string
#! .uses:
# <()>
#! .uses.fn:
# <assert> ('-eq' '$#' '1');
#          Assert a string
# <sline_map> ('$1' 'to_octal_offset_');
#             Process each populated string line with a function
# <to_octal> ("string");
#            Print POSIX shell-compatible octal escape sequence(s) of
#            `od -b -An` string
#! .sets:
# <to_octal_offset_> ();
#! .rc.fn:
# (assert) (255) bad input
# (sline_map) (*) error
# (to_octal) (0) success
# (to_octal) (*) error
#.
to_octal_offset() {
    to_octal_offset_() { printf "%s" "${1#"${1%%[!0123456789]*}"}"; }

    assert -eq "$#" 1 || return 255

    to_octal "$(sline_map "$1" to_octal_offset_)"
}

#! .desc:
# Execute 'umount' on a directory
#! .params:
# <"$1"> - directory
#! .rc:
# (0) success
# (255) bad input
#.
unmount() {
    assert -eq "$#" 1 || return 255

    cmd 'umount' && exist "$1" && dir "$1" || return 0

    umount -Rf "$1" > /dev/null 2>&1 || :
}

# END utility_functions
# START std_err_functions

#! .desc:
# EPERM: "Operation not permitted"
#! .rc:
# 1
#.
EPERM() { _err -red -- 'EPERM:'; }

#! .desc:
# ENOENT: "No such file or directory"
#! .rc:
# 2
#.
ENOENT() { _err -red - 'ENOENT:'; }

#! .desc:
# EERROR: "General operation error"
#! .params:
# <"$1"+> - error
#! .rc:
# (1)
# (255) bad input
#.
EERROR() {
    assert -eq "$#" 1 || return 255

    _err -red - "EERROR: $1"; exit 1
}

#! .desc:
# EEXIST: "Already exists"
#! .params:
# <"$1"+> - absolute path
#! .rc:
# (17)
# (255) bad input
#.
EEXIST() {
    assert -min "$#" 1 || return 255

    _err -red - 'EEXIST:'

    while [ "$1" ]; do
        ftype "$1" -err || :
        err - - " $1"

        shift
    done

    exit 17
}

#! .desc:
# ENOTDIR: "Not a directory"
#! .params:
# <"$1"+> - absolute path
#! .rc:
# (20)
# (255) bad input
#.
ENOTDIR() {
    assert -min "$#" 1 || return 255

    _err -red - 'ENOTDIR:'

    while [ "$1" ]; do
        ftype "$1" -err || :
        err - - " $1"

        shift
    done

    exit 20
}

#! .desc:
# EISDIR: "Is a directory"
#! .params:
# <"$1"+> - absolute path
#! .rc:
# (21)
# (255) bad input
#.
EISDIR() {
    assert -min "$#" 1 || return 255

    _err -red - 'EISDIR:'

    while [ "$1" ]; do
        ftype "$1" -err || :
        err - - " $1"

        shift
    done

    exit 21
}

#! .desc:
# EINVAL: "Invalid argument"
#! .rc:
# 22
#.
EINVAL() { _err -red - 'EINVAL:'; }

# END std_err_functions

#! .desc:
# Read STDIN into $FILE
#! .gives:
# (0) <"$FILE"> - the content of STDIN
#! .rc:
# (0) success
# (*) error
#.
FILE() {
    { while IFS= read -r _line; do
        FILE="$FILE$_line
"
    done; FILE="$FILE$_line"; } 2> /dev/null
}

#! .desc:
# Read octal STDIN into $FILE
#! .gives:
# (0) <"$FILE"> - the content of STDIN
#! .rc:
# (0) success
# (*) error
#.
FILE_octal() {
    { while IFS= read -r _line; do
        FILE="$FILE$_line
"
    done; } 2> /dev/null

    case "$FILE" in
        *'
')
            FILE="${FILE%%'
'*}"
        ;;
    esac
}

#! .desc:
# Read a file into $FILE
#! .params:
# <"$1"> - absolute path
#! .gives:
# (0) <"$FILE"> - the content of the file
#! .rc:
# (0) success
# (*) error
# (255) bad input
#.
FILE_preload() {
    assert -eq "$#" 1 || return 255

    file "$1" || return 255
    readable "$1" || return 255

    FILE=$(
        while IFS= read -r _line; do
            printf "%s\n" "$_line"
        done < "$1"; printf "%s" "$_line"

        printf "%s" ' '
    ) 2> /dev/null; FILE="${FILE%?}"
}

#! .desc:
# Read STDIN into $FILE_PATH
#! .gives:
# (0) <"$FILE_PATH"> - the content of STDIN
#! .rc:
# (0) success
# (*) error
#.
FILE_PATH() {
    FILE=; FILE_PATH=; FILE_PATH_TARGET=

    { while IFS= read -r _line; do
        FILE_PATH="$FILE_PATH$_line
"
    done; FILE_PATH="${FILE_PATH%?}$_line"; } 2> /dev/null
}

#! .desc:
# Read STDIN into $FILE_PATH_TARGET
#! .gives:
# (0) <"$FILE_PATH_TARGET"> - the content of STDIN
#! .rc:
# (0) success
# (*) error
#.
FILE_PATH_TARGET() {
    FILE_PATH_TARGET=

    { while IFS= read -r _line; do
        FILE_PATH_TARGET="$FILE_PATH_TARGET$_line
"
    done; FILE_PATH_TARGET="${FILE_PATH_TARGET%?}$_line"; } 2> /dev/null
}

#! .desc:
# Assert a file matches a given string of POSIX shell-compatible octal escape
# sequence(s)
#! .params:
# <"$1"> - file path
# <["$2"]> - string
#! .uses:
# <()>
#! .uses.fn:
# <assert> ('-eq' '$#' '2');
#          Assert a string
# <file> ('$1');
#        Assert a given path is a regular file
# <readable> ('$1');
#            Assert a given path is readable
#! .uses.util:
# <awk> ("program" '$(od -b -An -- "$1")' '$2');
#       pattern scanning and processing language
# <od>;
# dump files in various formats
#! .rc.fn:
# (assert) (255) bad input
# (file) (255) bad usage
# (readable) (255) bad usage
#! .rc.util:
# (awk) (0) true
# (awk) (1) false / error
# (awk) (*) error
# (od) (*) error
#! .desc.ext:
# Broken symbolic links are not valid files and error code `255` (bad usage)
# will be returned.
#.
bin_equiv() {
    assert -eq "$#" 2 || return 255
    { file "$1" && readable "$1"; } || return 255

    awk '
function mod_string(input) {
	result = ""

	gsub(/[ \n]+/, "", input)
	for (i = 1; i <= length(input); i += 3) {
		octal = substr(input, i, 3)
		result = result "\\0" octal
	}

	return result
}

BEGIN {
	file_string=ARGV[1]
	string=ARGV[2]
	delete ARGV

	exit (mod_string(file_string) == string) ? 0 : 1;
}
    ' "$(od -b -An -- "$1")" "$2"
}

#! .desc:
# Copy a given directory at a path
#! .params:
# <"$1"> - absolute path of the directory
# <"$2"> - absolute path to copy the directory at
#! .rc:
# (0) success
# (*) error
# (255) bad input
#.
dir_write() {
    assert -eq "$#" 2 || return 255

    dir "$1" || return 255

    if exist "$2"; then
        chattr_remove "$2"
        unmount "$2"

        rm -rf "$2" 2> /dev/null
    fi

    mkdir_parents "$2"

    cp -R "$1" "$2" 2> /dev/null
}

#! .desc:
# Copy a given file at a path
#! .params:
# <"$1"> - absolute path of the file
# <"$2"> - absolute path to copy the file at
#! .rc:
# (0) success
# (*) error
# (255) bad input
#.
file_copy() {
    assert -eq "$#" 2 || return 255

    file "$1" || return 255

    if exist "$2"; then
        chattr_remove "$2"
        unmount "$2"

        rm -rf "$2" 2> /dev/null
    fi

    mkdir_parents "$2"

    cp "$1" "$2" 2> /dev/null
}

#! .desc:
# Check if a file matches a given string
#! .params:
# <"$1"> - absolute path
# <"$2"> - string
#! .rc:
# (0) yes
# (1) no
# (*) error
# (255) bad input
#.
file_equiv() {
    assert -eq "$#" 2 || return 255

    file "$1" || return 255

    {
        _file= && while IFS= read -r _line; do
            _file="$_file$_line
"
        done < "$1"; _file="$_file$_line"
    } 2> /dev/null

    [ "$_file" = "$2" ]
}

#! .desc:
# Write a given string at a path
#! .params:
# <"$1"> - absolute path
# <"$2"> - string
#! .rc:
# (0) success
# (*) error
# (255) bad input
#.
file_write() {
    assert -eq "$#" 2 || return 255

    if exist "$1"; then
        chattr_remove "$1"
        unmount "$1"

        rm -rf "$1" 2> /dev/null
    fi

    mkdir_parents "$1"

    { printf "%s" "$2" > "$1"; } 2> /dev/null
}

#! .desc:
# Forcefully write a given string at a path
#! .params:
# <"$1"> - absolute path
# <"$2"> - string
#! .rc:
# (0) success
# (*) error
# (255) bad input
#.
file_writeF() {
    assert -eq "$#" 2 || return 255

    if exist "$1"; then
        chattr_remove "$1" 2> /dev/null || :
        unmount "$1" 2> /dev/null || :

        rm -rf "$1" 2> /dev/null || :
    fi

    mkdir_parents "$1"

    { printf "%s" "$2" > "$1"; } 2> /dev/null
}

#! .desc:
# Write a given octal sequence at a path
#! .params:
# <"$1"> - absolute path
# <"$2"> - octal sequence
#! .rc:
# (0) success
# (*) error
# (255) bad input
#.
file_write_octal() {
    assert -eq "$#" 2 || return 255

    if exist "$1"; then
        chattr_remove "$1"
        unmount "$1"

        rm -rf "$1" 2> /dev/null
    fi

    mkdir_parents "$1"
    { printf "%b" "$2" > "$1"; } || { rm -f "$1"; return 1; }
}

#! .desc:
# Check if a file matches a given file
#! .params:
# <"$1"> - absolute path
# <"$2"> - absolute path
#! .rc:
# (0) yes
# (1) no
# (*) error
# (255) bad input
#.
files_equiv() {
    assert -eq "$#" 2 || return 255

    file "$1" || return 255
    file "$2" || return 255
    readable "$1" || return 255
    readable "$2" || return 255

    cmp -s "$1" "$2" 2> /dev/null
}

#! .desc:
# Permanently delete a file/directory
#! .params:
# <"$1"> - absolute path
#! .rc:
# (0) success
# (*) error
# (255) bad $1
#.
loc_delete() {
    assert -eq "$#" 1 || return 255

    exist "$1" || return 0

    chattr_remove "$1"
    unmount "$1"

    rm -rf "$1" 2> /dev/null
}

#! .desc:
# Create a symbolic link of an object
#! .params:
# <"$1"> - absolute path of the object
# <"$2"> - absolute path to create the link at
#! .rc:
# (0) success
# (*) error
# (255) bad input
#.
loc_link() {
    assert -eq "$#" 2 || return 255

    { [ -e "$1" ] || [ -h "$1" ]; } || return 255

    if exist "$2"; then
        chattr_remove "$2"
        unmount "$2"
    fi

    mkdir_parents "$2"

    ln -sf "$1" "$2" 2> /dev/null
}

#! .desc:
# Create a hard link of a file
#! .params:
# <"$1"> - absolute path of the file
# <"$2"> - absolute path to create the link at
#! .rc:
# (0) success
# (*) error
# (255) bad input
#.
loc_link_ptr() {
    assert -eq "$#" 2 || return 255

    if file "$1"; then
        :
    else
        return 255
    fi

    if exist "$2"; then
        chattr_remove "$2"
        unmount "$2"
    fi

    mkdir_parents "$2"

    ln -f "$1" "$2" 2> /dev/null
}

#! .desc:
# Set $user as owner of an object and its parents in $home
#! .params:
# <"$1"> - absolute path
#! .uses:
# [gid] $ - the numerical user primary group ID
# [home] $ - the user directory
# [uid] $ - the numerical user ID
#! .rc:
# (0) success
# (*) error
# (255) bad input
#.
loc_own_user() {
    assert -eq "$#" 1 || return 255

    set -- "${1%"${1##*[!/]}"}"

    exist "$1" && str_pfix "$home"/ "$1" || return 0

    chattr_remove "$1"

    if dir "$1"; then
        chown -RP -- "$uid":"$gid" "$1"
    else
        chown -P -- "$uid":"$gid" "$1"
    fi

    set -- "${1%/*}"
    set -- "${1%"${1##*[!/]}"}"
    until [ "$1" = "$home" ]; do
        chown -P -- "$uid":"$gid" "$1"

        set -- "${1%/*}"
        set -- "${1%"${1##*[!/]}"}"
    done
}

#! .desc:
# Write a binary file at the specified path
#! .uses:
# <FILE> $ - the octal sequence of the file
# <FILE_PATH> $ - the path to write the file at
#! .rc:
# (0) success
# (*) error
# (255) bad usage
#.
__bin_write() {
    if [ ! "$FILE_PATH" ]; then
        _err -red - 'Missing FILE_PATH.'
        return 255
    fi

    if [ ! "$FILE" ]; then
        _info -white - 'Empty FILE. File write cancelled:'
        ftype "$FILE_PATH" -info || :
        info - - " $FILE_PATH"
        return 0
    fi

    if ! is_octal "$FILE"; then
        _err -red - 'Bad FILE; expected octal.'
        return 255
    fi

    while :; do
        if [ "$always_write" = 0 ]; then
            if bin_equiv "$FILE_PATH" "$FILE"; then
                _info -white - 'File write avoided:'
                ftype "$FILE_PATH" -info || :
                info - - " $FILE_PATH"
                break
            fi
        fi

        if [ "$force_write" = 1 ]; then
            loc_delete "$FILE_PATH"
        fi

        if exist "$FILE_PATH"; then
            EEXIST "$FILE_PATH"
        fi

        _info -white - 'Will write a file:'
        ftype "$FILE_PATH" -info || :
        info - - " $FILE_PATH"

        (
            IFS='\''
'
            CC=0; for _octal in $FILE; do CC=$((CC + 1)); done
            info -white -- 'CC: '; info - - "$CC"
            info -white -- 'SIZE: '; bytes_size "$CC"
        )

        if ! file_write_octal "$FILE_PATH" "$FILE"; then
            _err -red - 'File write error:'
            ftype "$FILE_PATH" -err || :
            err - - " $FILE_PATH"
            exit 1
        fi
    break; done

    if ! loc_own_user "$FILE_PATH"; then
        EERROR 'Failed to set user permissions.'
    fi
}

#! .desc:
# Write a binary file at the specified path (overwrite path)
#.
__bin_write_overwrite() {
    __loc_delete && __bin_write;
}

#! .desc:
# Run a command
#! .params:
# <"$1"> - command
# <"$2">+ -  arguments
#! .rc:
# (0) success
# (*) error
# (255) bad usage
#.
__cmd() {
    cmd "$1" || {
        _err -red - 'Missing command:'

        err -white -- '`'
        err - -- "$1"
        err -white - '`'

        exit 127
    }

    _info -white - 'Running command:'

    info -white -- '`'
    info - -- "$@"
    info -white - '`'

    if [ "$silent_cmd" = 1 ]; then
        command "$@" > /dev/null || return "$?"
    else
        command "$@" || return "$?"
    fi
}

#! .desc:
# Run a command and store output in $FILE
#! .params:
# <[$1]> - option_block(
#     'e' - missing output is an error condition
#     'n' - preserve final <newline> characters as given
#     's' - (only with `n`) always strip one final <newline> character
#     .
# )
# <"$2"> - command
# <"$3">+ -  arguments
#! .rc:
# (0) success
# (*) error
# (255) bad usage
#.
__FILE_cmd() {
    assert -min "$#" 2 || return 255

    cmd "$2" || {
        _err -red - 'Missing command:'

        err -white -- '`'
        err - -- "$2"
        err -white - '`'

        exit 127
    }

    _info -white - 'Running command:'

    info -white -- '`'
    info - -- "$2"; offset 2 "$#" "$@" info - ---
    info -white - '`'

    case "$1" in
        *n*s*)
            FILE=$(shift && command "$@" && printf "%s" x) && \
            FILE="${FILE%?}" && \
            FILE="${FILE%?}"
        ;;
        *n*)
            FILE=$(shift && command "$@" && printf "%s" x) && \
            FILE="${FILE%?}"
        ;;
        *)
            FILE=$(shift && command "$@")
        ;;
    esac

    case "$1" in
        *e*)
            [ "$FILE" ] || {
                _err -red - 'No output has been received.'

                exit 1
            }
        ;;
    esac
}

#! .desc:
# Copy a directory at the specified path
#! .uses:
# <FILE_PATH> $ - the directory
# <FILE_PATH_TARGET> $ - the path to write the directory at
#! .rc:
# (0) success
# (*) error
# (255) bad usage
#.
__dir_target_write() {
    if [ ! "$FILE_PATH" ]; then
        _err -red - 'Missing FILE_PATH.'
        return 255
    fi

    if [ ! "$FILE_PATH_TARGET" ]; then
        _err -red - 'Missing FILE_PATH_TARGET.'
        return 255
    fi

    if ! exist "$FILE_PATH"; then
        ENOENT;
        ftype "$FILE_PATH" -err || :
        err - - " $FILE_PATH"
        exit 2
    fi

    dir "$FILE_PATH" && readable "$FILE_PATH" || {
        EINVAL;
        ftype "$FILE_PATH" -err || :
        err - - " $FILE_PATH"
        exit 22
    }

    while :; do
        if [ "$force_write" = 1 ]; then
            loc_delete "$FILE_PATH_TARGET"
        fi

        if exist "$FILE_PATH_TARGET"; then
            EEXIST "$FILE_PATH_TARGET"
        fi

        _info -white - 'Will copy from/to:'
        ftype "$FILE_PATH" -info || :
        info - - " $FILE_PATH"
        ftype "$FILE_PATH_TARGET" -info || :
        info - - " $FILE_PATH_TARGET"

        info -white -- '> '
        find "$FILE_PATH"//. ! -name . | grep -c // 2> /dev/null | \
            while IFS= read -r _line0; do
                printf "%s, " "$_line0"

                info -white -- 'D '
                find "$FILE_PATH"//. ! -name . -type d | \
                    grep -c // 2> /dev/null | \
                        while IFS= read -r _line1; do
                            printf "%s, " "$_line1"

                            info -white -- 'F '
                            info - - "$((_line0 - _line1))"
                        done
            done

        if ! dir_write "$FILE_PATH" "$FILE_PATH_TARGET"; then
            _err -red - 'Directory write error:'
            ftype "$FILE_PATH_TARGET" -err || :
            err - - " $FILE_PATH_TARGET"
            exit 1
        fi
    break; done

    if ! loc_own_user "$FILE_PATH_TARGET"; then
        EERROR 'Failed to set user permissions.'
    fi
}

#! .desc:
# Copy a directory at the specified path (overwrite path)
#.
__dir_target_write_overwrite() {
    __loc_delete && __dir_target_write;
}

#! .desc:
# Preload FILE_PATH into FILE
#! .uses:
# <FILE> $
# <FILE_PATH> $ - the file to preload
#! .rc:
# (0) success
# (*) error
# (255) bad usage
#.
__FILE_PATH_preload() {
    if [ ! "$FILE_PATH" ]; then
        _err -red - 'Missing FILE_PATH.'
        return 255
    fi

    if ! exist "$FILE_PATH"; then
        ENOENT;
        ftype "$FILE_PATH" -err || :
        err - - " $FILE_PATH"
        exit 2
    fi

    FILE_preload "$FILE_PATH" || {
        _err -red - 'Error reading file:'
        ftype "$FILE_PATH" -err || :
        err - - " $FILE_PATH"
        exit 1
    }
}

#! .desc:
# Modify file data in-place according to format (see fed())
#! .params:
# <[$1]> - crc32 string to verify produced format against
# <["$2"]> - log file path
# <$3>+ - operation(
#     '-' - EOF add $4
#     '-m' - apply modifier for `-a`/`-r`/`-s`; see extended description
#     '-a' - add $4
#     '-r' - remove $4
#     '-s' - substitute $4 with $5
#     .
# )
# ["$4"] - string
# ["$5"] - string
#.
__fed() {
    assert -min "$#" 3 || return 255

    [ "$FILE" ] || __FILE_PATH_preload || exit "$?"

    set -- "$FILE" "$@"

    _fmt=$(
        _a="$1"; shift 3

        fed "$_a" "$@" || {
            set -- "$?"; case "$1" in
                1) [ ! "$_fmt" ] || return "$1" ;;
                *) return "$1" ;;
            esac
        }

        printf "%s" "$_fmt"
    ) || exit "$?"

    [ "$_fmt" ] || return 0

    set -- "$_fmt" "$@"

    _cksum=$(printf "%s" "$1" | cksum) && \
    _cksum="${_cksum%%' '*}" || exit "$?"

    if [ "$3" ] && [ "$3" != "$_cksum" ]; then
        _info -yellow - "CRC32 mismatch. (exp. $3; got $_cksum)"
        _info -white - 'Format:'
        info - - "$1"

        if [ "$confirm_crc" = 1 ]; then
            _info -white - 'Auto accepted the mismatch.'
        elif [ "$interactive" = 1 ]; then
            confirm_cont || return 0
        else
            return 0
        fi
    fi

    FILE=$(
        _a="$2"; _b="$4"; eval set -- "$1"

        libfile "$_b" "$_a" "$@" || return "$?"

        printf "%s" "${_file}x"
    ) && FILE="${FILE%?}" || exit "$?"
}

#! .desc:
# Set the executable bits on a file
#! .uses:
# <FILE_PATH> $ - the file
#! .rc:
# (0) success
# (*) error
# (255) bad usage
#.
__file_executable() {
    if [ ! "$FILE_PATH" ]; then
        _err -red - 'Missing FILE_PATH.'
        return 255
    fi

    if ! exist "$FILE_PATH"; then
        ENOENT;
        ftype "$FILE_PATH" -err || :
        err - - " $FILE_PATH"
        exit 2
    fi

    file "$FILE_PATH" || {
        EINVAL;
        ftype "$FILE_PATH" -err || :
        err - - " $FILE_PATH"
        exit 22
    }

    __cmd chmod +x "$FILE_PATH"
}

#! .desc:
# Write a file at the specified path
#! .uses:
# <FILE> $ - the file
# <FILE_PATH> $ - the path to write the file at
#! .rc:
# (0) success
# (*) error
# (255) bad usage
#.
__file_write() {
    if [ ! "$FILE_PATH" ]; then
        _err -red - 'Missing FILE_PATH.'
        return 255
    fi

    if [ ! "$FILE" ]; then
        _info -white - 'Empty FILE. File write cancelled:'
        ftype "$FILE_PATH" -info || :
        info - - " $FILE_PATH"
        return 0
    fi

    while :; do
        if [ "$always_write" = 0 ]; then
            if file_equiv "$FILE_PATH" "$FILE"; then
                _info -white - 'File write avoided:'
                ftype "$FILE_PATH" -info || :
                info - - " $FILE_PATH"
                break
            fi
        fi

        if [ "$force_write" = 1 ]; then
            loc_delete "$FILE_PATH"
        fi

        if exist "$FILE_PATH"; then
            EEXIST "$FILE_PATH"
        fi

        if [ -s "$logf" ]; then  # log written
            _info -white - 'Will write original file; diff:'
            ftype "$FILE_PATH" -info || :
            info - - " $FILE_PATH"
            while IFS=" " read -r _n _line; do
                case "$_n" in
                    *'+') printf "%b%s%b " '\033[1;32m' "$_n" '\033[0m' ;;
                    *'-') printf "%b%s%b " '\033[1;31m' "$_n" '\033[0m' ;;
                esac; printf "%s\n" "$_line"
            done < "$logf"
        else
            _info -white - 'Will write a file:'
            ftype "$FILE_PATH" -info || :
            info - - " $FILE_PATH"
            if [ "$silent_write" = 0 ]; then
                info -white - '0:'; info - - "${FILE%'
'}"
            fi
        fi

        if ! file_write "$FILE_PATH" "$FILE"; then
            _err -red - 'File write error:'
            ftype "$FILE_PATH" -err || :
            err - - " $FILE_PATH"
            exit 1
        fi
    break; done

    if ! loc_own_user "$FILE_PATH"; then
        EERROR 'Failed to set user permissions.'
    fi

    if ! { : > "$logf"; }; then
        _err -r - 'Log clear error.'
        exit 1
    fi
}

#! .desc:
# Write a file at the specified path (overwrite path)
#.
__file_write_overwrite() {
    __loc_delete && __file_write;
}

#! .desc:
# Overwrite a file at the specified path
#! .uses:
# <FILE> $ - the file
# <FILE_PATH> $ - the path to write the file at
#! .rc:
# (0) success
# (*) error
# (255) bad usage
#.
__file_write_overwrite_soft() {
    if [ ! "$FILE_PATH" ]; then
        _err -red - 'Missing FILE_PATH.'
        return 255
    fi

    if [ ! "$FILE" ]; then
        _info -white - 'Empty FILE. File write cancelled:'
        ftype "$FILE_PATH" -info || :
        info - - " $FILE_PATH"
        return 0
    fi

    while :; do
        if [ "$always_write" = 0 ]; then
            if file_equiv "$FILE_PATH" "$FILE"; then
                _info -white - 'File write avoided:'
                ftype "$FILE_PATH" -info || :
                info - - " $FILE_PATH"
                break
            fi
        fi

        if [ -s "$logf" ]; then  # log written
            _info -white - 'Will write original file; diff:'
            ftype "$FILE_PATH" -info || :
            info - - " $FILE_PATH"
            while IFS=" " read -r _n _line; do
                case "$_n" in
                    *'+') printf "%b%s%b " '\033[1;32m' "$_n" '\033[0m' ;;
                    *'-') printf "%b%s%b " '\033[1;31m' "$_n" '\033[0m' ;;
                esac; printf "%s\n" "$_line"
            done < "$logf"
        else
            _info -white - 'Will overwrite a file:'
            ftype "$FILE_PATH" -info || :
            info - - " $FILE_PATH"
            if [ "$silent_write" = 0 ]; then
                info -white - '0:'; info - - "${FILE%'
'}"
            fi
        fi

        if ! file_writeF "$FILE_PATH" "$FILE"; then
            _err -red - 'File overwrite error:'
            ftype "$FILE_PATH" -err || :
            err - - " $FILE_PATH"
            exit 1
        fi
    break; done

    if ! loc_own_user "$FILE_PATH"; then
        EERROR 'Failed to set user permissions.'
    fi

    if ! { : > "$logf"; }; then
        _err -r - 'Log clear error.'
        exit 1
    fi
}

#! .desc:
# Copy a file at the specified path
#! .uses:
# <FILE_PATH> $ - the file
# <FILE_PATH_TARGET> $ - the path to write the file at
#! .rc:
# (0) success
# (*) error
# (255) bad usage
#.
__file_target_write() {
    if [ ! "$FILE_PATH" ]; then
        _err -red - 'Missing FILE_PATH.'
        return 255
    fi

    if [ ! "$FILE_PATH_TARGET" ]; then
        _err -red - 'Missing FILE_PATH_TARGET.'
        return 255
    fi

    if ! exist "$FILE_PATH"; then
        ENOENT;
        ftype "$FILE_PATH" -err || :
        err - - " $FILE_PATH"
        exit 2
    fi

    file "$FILE_PATH" && readable "$FILE_PATH" || {
        EINVAL;
        ftype "$FILE_PATH" -err || :
        err - - " $FILE_PATH"
        exit 22
    }

    while :; do
        if [ "$always_write" = 0 ]; then
            if files_equiv "$FILE_PATH" "$FILE_PATH_TARGET"; then
                _info -white - 'File write avoided:'
                ftype "$FILE_PATH_TARGET" -info || :
                info - - " $FILE_PATH_TARGET"
                break
            fi
        fi

        if [ "$force_write" = 1 ]; then
            loc_delete "$FILE_PATH_TARGET"
        fi

        if exist "$FILE_PATH_TARGET"; then
            EEXIST "$FILE_PATH_TARGET"
        fi

        _info -white - 'Will copy from/to:'
        ftype "$FILE_PATH" -info || :
        info - - " $FILE_PATH"
        ftype "$FILE_PATH_TARGET" -info || :
        info - - " $FILE_PATH_TARGET"

        if ! file_copy "$FILE_PATH" "$FILE_PATH_TARGET"; then
            _err -red - 'File write error:'
            ftype "$FILE_PATH_TARGET" -err || :
            err - - " $FILE_PATH_TARGET"
            exit 1
        fi
    break; done

    if ! loc_own_user "$FILE_PATH_TARGET"; then
        EERROR 'Failed to set user permissions.'
    fi
}

#! .desc:
# Copy a file at the specified path (overwrite path)
#.
__file_target_write_overwrite() {
    __loc_delete && __file_target_write;
}

#! .desc:
# Set filesystem flags on a file/directory
#! .params:
# <$1> - flag(s) to set
#! .uses:
# <FILE_PATH> $ - the file/directory
#! .rc:
# (0) success
# (*) error
# (255) bad input/usage
#.
__loc_chattr() {
    assert -eq "$#" 1 || return 255

    cmd 'chattr' || return 0

    if [ ! "$FILE_PATH" ]; then
        _err -red - 'Missing FILE_PATH.'
        return 255
    fi

    if ! exist "$FILE_PATH"; then
        ENOENT;
        ftype "$FILE_PATH" -err || :
        err - - " $FILE_PATH"
        exit 2
    fi

    if dir "$FILE_PATH"; then
        :
    elif file "$FILE_PATH"; then
        :
    else
        EINVAL;
        ftype "$FILE_PATH" -err || :
        err - - " $FILE_PATH"
        exit 22
    fi

    __cmd chattr +"$1" "$FILE_PATH"
}

#! .desc:
# Set permissions on a file/directory
#! .params:
# <$1> - octal mode
#! .uses:
# <FILE_PATH> $ - the file/directory
#! .rc:
# (0) success
# (*) error
# (255) bad input/usage
#.
__loc_chmod() {
    assert -eq "$#" 1 || return 255

    if [ ! "$FILE_PATH" ]; then
        _err -red - 'Missing FILE_PATH.'
        return 255
    fi

    if ! exist "$FILE_PATH"; then
        ENOENT;
        ftype "$FILE_PATH" -err || :
        err - - " $FILE_PATH"
        exit 2
    fi

    if dir "$FILE_PATH"; then
        :
    elif file "$FILE_PATH"; then
        :
    else
        EINVAL;
        ftype "$FILE_PATH" -err || :
        err - - " $FILE_PATH"
        exit 22
    fi

    chattr_remove "$FILE_PATH"

    __cmd chmod "$1" "$FILE_PATH"
}

#! .desc:
# Set owner of a file/directory
#! .params:
# <$1> - owner
#! .uses:
# <FILE_PATH> $ - the file/directory
#! .rc:
# (0) success
# (*) error
# (255) bad input/usage
#.
__loc_chown() {
    assert -eq "$#" 1 || return 255

    if [ ! "$FILE_PATH" ]; then
        _err -red - 'Missing FILE_PATH.'
        return 255
    fi

    if ! exist "$FILE_PATH"; then
        ENOENT;
        ftype "$FILE_PATH" -err || :
        err - - " $FILE_PATH"
        exit 2
    fi

    if dir "$FILE_PATH"; then
        :
    elif file "$FILE_PATH"; then
        :
    else
        EINVAL;
        ftype "$FILE_PATH" -err || :
        err - - " $FILE_PATH"
        exit 22
    fi

    chattr_remove "$FILE_PATH"

    __cmd chown -R "$uid":"$gid" "$FILE_PATH"
}

#! .desc:
# Delete a file/directory from the specified path
#! .uses:
# <FILE_PATH> $ - the file/directory
#! .rc:
# (0) success
# (*) error
# (255) bad usage
#.
__loc_delete() {
    if [ ! "$FILE_PATH" ]; then
        _err -red - 'Missing FILE_PATH.'
        return 255
    fi

    if ! exist "$FILE_PATH"; then
        _info -white - 'Already deleted:'
        ftype "$FILE_PATH" -info || :
        info - - " $FILE_PATH"
        return 0
    fi

    _info -white - 'Will delete:'
    ftype "$FILE_PATH" -info || :
    info - - " $FILE_PATH"

    if ! loc_delete "$FILE_PATH"; then
        _err -red - 'Removal error:'
        ftype "$FILE_PATH" -err || :
        err - - " $FILE_PATH"
        exit 1
    fi
}

#! .desc:
# Truncate/empty a file/directory on the specified path
#! .uses:
# <FILE_PATH> $ - the file/directory
#! .rc:
# (0) success
# (*) error
# (255) bad usage
#.
__loc_empty() {
    if [ ! "$FILE_PATH" ]; then
        _err -red - 'Missing FILE_PATH.'
        return 255
    fi

    if dir "$FILE_PATH"; then
        :
    elif file "$FILE_PATH"; then
        :
    elif exist "$FILE_PATH"; then
        EINVAL;
        ftype "$FILE_PATH" -err || :
        err - - " $FILE_PATH"
        exit 22
    fi

    if dir "$FILE_PATH"; then
        _info -white - 'Will empty:'
        ftype "$FILE_PATH" -info || :
        info - - " $FILE_PATH"

        __cmd rm -rf "$FILE_PATH"/*
    else
        if exist "$FILE_PATH"; then
            _info -white - 'Will truncate:'
        else
            _info -white - 'Will create a file:'
        fi
        ftype "$FILE_PATH" -info || :
        info - - " $FILE_PATH"

        if ! { : > "$FILE_PATH"; }; then
            if exist "$FILE_PATH"; then
                _err -red - 'Truncation error:'
            else
                _err -red - 'File creation error:'
            fi
            ftype "$FILE_PATH" -err || :
            err - - " $FILE_PATH"
            exit 1
        fi
    fi
}

#! .desc:
# Create a symbolic link of an object at the specified path (overwrite)
#! .uses:
# <FILE_PATH> $ - the object
# <FILE_PATH_TARGET> $ - the path to write the symbolic link at
#! .rc:
# (0) success
# (*) error
# (255) bad usage
#.
__loc_target_link_overwrite() {
    if [ ! "$FILE_PATH" ]; then
        _err -red - 'Missing FILE_PATH.'
        return 255
    fi

    if [ ! "$FILE_PATH_TARGET" ]; then
        _err -red - 'Missing FILE_PATH_TARGET.'
        return 255
    fi

    if ! { exist "$FILE_PATH" || [ -h "$FILE_PATH" ]; }; then
        ENOENT;
        ftype "$FILE_PATH" -err || :
        err - - " $FILE_PATH"
        exit 2
    fi

    while :; do
        _info -white - 'Will symbolic link source/target:'
        ftype "$FILE_PATH" -info || :
        info - - " $FILE_PATH"
        ftype "$FILE_PATH_TARGET" -info || :
        info - - " $FILE_PATH_TARGET"

        if ! loc_link "$FILE_PATH" "$FILE_PATH_TARGET"; then
            _err -red - 'Symbolic linking error:'
            ftype "$FILE_PATH_TARGET" -err || :
            err - - " $FILE_PATH_TARGET"
            exit 1
        fi
    break; done

    if ! loc_own_user "$FILE_PATH_TARGET"; then
        EERROR 'Failed to set user permissions.'
    fi
}

#! .desc:
# Copy/clone a git repository to $tmpd
#! .params:
# <["$1"]> - directory path
# ["$2"]+ - URL
#! .rc:
# (0) success
# (*) error
# (255) bad input
#.
__git_get() {
    assert -min "$#" 1 || return 255

    while [ "$1" ]; do
        dir "$1" && exist "$1"/.git || break

        dir_write "$1" "$tmpd/." || return "$?"

        return 0
    done

    shift

    set -- "$@" '--depth' '1'

    if str '/' "$1"; then
        set -- "$@" "$tmpd/${1#"${1%/*}"?}"
    else
        set -- "$@" "$tmpd/$1"
    fi

    __cmd git clone "$@"
}

err_handler() {
    IFS=' 	''
'

    trap - INT TERM

    # env cleanup
    if [ -e "$tmpd" ] || [ -e "$tmpf" ] || [ -e "$logf" ]; then
        chattr -R -ia "$tmpd" "$tmpf" "$logf" > /dev/null 2>&1 || :
        rm -rf "$tmpd" "$tmpf" "$logf"
    fi

    if [ "$1" = 0 ]; then
        exit 0
    elif [ "$2" = INT ]; then
        err -red - "${0##*/}: Received INT signal. ($1)"; kill -2 "$$"
    else
        err -red - "${0##*/}: Received $2 signal. ($1)"; exit "$1"
    fi
}

main() {
    LC_ALL=C; export LC_ALL
    set -e
    trap "err_handler \$? INT" INT
    trap "err_handler \$? TERM" TERM

    case "$1" in
        '-0')
            _lib_sg="$2"; shift 2
        ;;
        *)
            case "$0" in
                /*) _a="$0" ;;
                *) _a="${PWD%"${PWD##*[!/]}"}"/"$0" ;;
            esac

            if [ -h "$_a" ]; then
                _a="$(realpath -- "$_a" && printf "%s" x)"
                _a="${_a%??}"
            fi

            _a="${_a%"${_a##*[!/]}"}"
            _a="${_a%/*}"
            _a="${_a%"${_a##*[!/]}"}"
            _a="${_a%/*}"
            _a="${_a%"${_a##*[!/]}"}"

            _lib_sg="$_a"/lib/shell-glossary/src
        ;;
    esac

    for _func in "$_lib_sg"/*; do
        if [ -f "$_func" ]; then
            . "$_func"
        fi
    done

    # Control switches
    # Always write files, even if the remote/fs content matches ours.
    always_write=0
    # Automatically continue/confirm any CRC32 mismatch prompts.
    confirm_crc=0
    # Force file writes by remote/fs object overwrite/removal:
    force_write=0
    # Interactive mode; prompt for input on dual actions.
    interactive=0
    # Disable command output:
    silent_cmd=0
    # Disable content output of file writes:
    silent_write=0

    # Utility internal locations
    # Temporary per-function dir (cleared on func exit):
    tmpd="${TMPDIR:-/tmp}/syscfg_tmpd"
    # Temporary per-function file (cleared on func exit):
    tmpf="${TMPDIR:-/tmp}/syscfg_tmpf"
    # Temporary per-function log file (cleared on func exit):
    logf="${TMPDIR:-/tmp}/syscfg_logf"

    # Enable always_write from cmdline:    ^AW as $1
    # Enable audio_hq_resamp from cmdline: ^AQ as $1
    # Enable confirm_crc from cmdline:     ^CC as $1
    # Enable force_write from cmdline:     ^FW as $1
    # Enable interactive from cmdline:     ^IE as $1
    # Enable ipv6 from cmdline:            ^I6 as $1
    # Enable silent_cmd from cmdline:      ^SC as $1
    # Enable silent_write from cmdline:    ^SW as $1
    while :; do case "$1" in
        '^AW') always_write=1; shift && continue ;;
        '^AQ') audio_hq_resamp=1; shift && continue ;;
        '^CC') confirm_crc=1; shift && continue ;;
        '^FW') force_write=1; shift && continue ;;
        '^IE') interactive=1; shift && continue ;;
        '^I6') ipv6=1; shift && continue ;;
        '^SC') silent_cmd=1; shift && continue ;;
        '^SW') silent_write=1; shift && continue ;;
        *) break ;;
    esac done

    # `^AW` implies `^AW ^FW`.
    if [ "$always_write" = 1 ] && [ "$force_write" = 0 ]; then
        info -white -- "${0##*/}: "
        info -yellow - 'Assuming `^AW ^FW`.'

        force_write=1

        if [ "$interactive" = 1 ]; then
            confirm_cont -y || {
                info -white -- "${0##*/}: "
                info -white - 'Interactive correction: `^AW`.'

                force_write=0
            }
        fi
    fi

    readonly always_write confirm_crc force_write interactive logf silent_cmd \
             silent_write tmpd tmpf

    assert -min "$#" 1 || {
        err -red - 'No client has been specified.'
        err - -

        info -white - 'SWITCH: always_write ^AW'
        info -white - 'SWITCH: audio_hq_resamp ^AQ'
        info -white - 'SWITCH: confirm_crc ^CC'
        info -white - 'SWITCH: force_write ^FW'
        info -white - 'SWITCH: interactive ^IE'
        info -white - 'SWITCH: ipv6 ^I6'
        info -white - 'SWITCH: silent_cmd ^SC'
        info -white - 'SWITCH: silent_write ^SW'

        exit 2
    }

    # end arg parsing; main()

    [ "$(id -u)" = 0 ] || {
        err -red - 'Missing root rights.'; exit 1
    }

    # past env cleanup from SIGKILL or something else
    if [ -e "$tmpd" ] || [ -e "$tmpf" ] || [ -e "$logf" ]; then
        chattr -R -ia "$tmpd" "$tmpf" "$logf" > /dev/null 2>&1 || :
        rm -rf "$tmpd" "$tmpf" "$logf"
    fi

    while [ "$1" ]; do
        # env setup
        ( umask 077; mkdir "$tmpd"; : > "$tmpf" > "$logf"; ) || return "$?"

        # In the future, clients will be launched as an external command,
        # lexed and parsed by syscfg.
        ( . "$1" "$1"; ) || return "$?"

        # env reset
        if [ -e "$tmpd" ] || [ -e "$tmpf" ] || [ -e "$logf" ]; then
            chattr -R -ia "$tmpd" "$tmpf" "$logf" > /dev/null 2>&1 || :
            rm -rf "$tmpd" "$tmpf" "$logf"
        fi

        info -green - "$1:" 'Done!'

        shift
    done

    return 0
}

assertive_functions;
helper_functions;
utility_functions;
utility_functions_err;
utility_functions_out;
main "$@" || { err_handler "$?" 'ERR'; }
