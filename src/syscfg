#!/bin/sh
# Copyright (C) 2021-2025 Dimitar Yurukov <mscalindt@protonmail.com>
#
# syscfg - declarative OS configuration
#
# Use to_octal() or to_octal_offset() to obtain the POSIX shell-compatible
# octal escape sequence(s) of octal byte streams produced by `od -b -An` or
# `od -b`, respectively.

# Maintainer note for any functions in assertive_functions():
#
# Assertive functions shall not return `255` on empty input, and instead,
# simply return true/false appropriately. `255` is only returned when input is
# unspecified. If a function cannot adhere to the aforementioned, it does not
# belong in assertive_functions().
assertive_functions() { # START assertive_functions
    :
} # END assertive_functions

helper_functions() { # START helper_functions
#! .desc:
# Assert the content and state of a write is equal on the filesystem
#! .params:
# <$@> - __write()
#! .rc:
# (0) true
# (1) false
#! .desc.ext:
# We do not yet have write avoidance support for types `-c` and `-l`.
#
# For more information, refer to the documentation of __write().
#.
fs_equiv() {
    case "$1" in
        '-c' | '-l') return 1 ;;
    esac

    { ! hint 4 -no-avoid "$@"; } || return 1

    # Assert the state, i.e. the inode type and attributes.
    fs_equiv_type "$@" || return 1
    fs_equiv_type_attr "$@" || return 1
    fs_equiv_owner "$@" || return 1
    fs_equiv_group "$@" || return 1
    fs_equiv_perm "$@" || return 1

    # Assert the content.
    case "$1" in
        '-o')
            awk '
function mod_string(input) {
	res = ""

	gsub(/[ \n]+/, "", input)
	for (i = 1; i <= length(input); i += 3) {
		octal = substr(input, i, 3)
		res = res "\\0" octal
	}

	return res
}

BEGIN {
	str=ARGV[1]
	file_str=ARGV[2]
	delete ARGV

	exit (mod_string(file_str) == str) ? 0 : 1;
}
            ' "$2" "$(od -b -An -- "$3")" || return 1
        ;;
        '-w')
            file_preload -cat "$3"

            [ "$_file" = "$2" ] || return 1
        ;;
    esac

    return 0
}

#! .desc:
# Assert the GID is equal on the filesystem
#! .params:
# <$@> - __write()
#! .rc:
# (0) true
# (1) false
#! .desc.ext:
# For more information, refer to the documentation of __write().
#.
fs_equiv_group() {
    case "$1" in
        '-o' | '-w')
            # Get the fourth field (group) of `ls -ld` of $3 into $_a.
            _a="$(ls -ld -- "$3")"
            _a="${_a%%'
'*}"
            _a="${_a#*' '}"
            _a="${_a#*' '}"
            _a="${_a#*' '}"
            _a="${_a%%' '*}"

            set -- "$_a" "$@"

            if hint 5 -group "$@"; then
                [ ! "$1" = "$_hint" ] || return 0
            else
                [ ! "$1" = "$(id -ng)" ] || return 0
            fi

            if hint 5 -gid "$@"; then
                [ ! "$1" = "$_hint" ] || return 0
            else
                [ ! "$1" = "$(id -g)" ] || return 0
            fi
        ;;
    esac

    return 1
}

#! .desc:
# Assert the UID is equal on the filesystem
#! .params:
# <$@> - __write()
#! .rc:
# (0) true
# (1) false
#! .desc.ext:
# For more information, refer to the documentation of __write().
#.
fs_equiv_owner() {
    case "$1" in
        '-o' | '-w')
            # Get the third field (owner) of `ls -ld` of $3 into $_a.
            _a="$(ls -ld -- "$3")"
            _a="${_a%%'
'*}"
            _a="${_a#*' '}"
            _a="${_a#*' '}"
            _a="${_a%%' '*}"

            set -- "$_a" "$@"

            if hint 5 -user "$@"; then
                [ ! "$1" = "$_hint" ] || return 0
            else
                [ ! "$1" = "$(id -nu)" ] || return 0
            fi

            if hint 5 -uid "$@"; then
                [ ! "$1" = "$_hint" ] || return 0
            else
                [ ! "$1" = "$(id -u)" ] || return 0
            fi
        ;;
    esac

    return 1
}

#! .desc:
# Assert the file mode is equal on the filesystem
#! .params:
# <$@> - __write()
#! .rc:
# (0) true
# (1) false / error
# (*) error
#! .desc.ext:
# For more information, refer to the documentation of __write().
#.
fs_equiv_perm() {
    case "$1" in
        '-o' | '-w')
            # Get the first field (file mode; "%c%s%s%s%c") of `ls -ld` of $3
            # into $_a.
            _a="$(ls -ld -- "$3")"
            _a="${_a%%' '*}"

            # Strip the last "%c" if present.
            [ "${#_a}" -eq 10 ] || _a="${_a%?}"

            set -- "$_a" "$@"

            if hint 5 -mode "$@"; then
                fmode_octal "$_hint" || return "$?"

                # `-` = "regular file"
                [ ! "$1" = "-$_mode" ] || return 0
            else
                # `-`, `rw-r--r--` = "regular file", 0644"
                [ ! "$1" = '-rw-r--r--' ] || return 0
            fi
        ;;
    esac

    return 0
}

#! .desc:
# Assert the object type is equal on the filesystem
#! .params:
# <$@> - __write()
#! .rc:
# (0) true
# (1) false
#! .desc.ext:
# For more information, refer to the documentation of __write().
#.
fs_equiv_type() {
    case "$1" in
        '-o' | '-w')
            ftype "$3" && [ "$_type" = 'F' ] || return 1
        ;;
    esac

    return 0
}

#! .desc:
# Assert the attributes of the object type are equal on the filesystem
#! .params:
# <$@> - __write()
#! .rc:
# (0) true
#! .desc.ext:
# For more information, refer to the documentation of __write().
#.
fs_equiv_type_attr() {
    return 0
}

#! .desc:
# Query the presence of an independent hint among arguments
#! .params:
# <$1> - N
# <$2> - hint(
#     '-clear-log' - log file path to clear after use (argument)
#     '-del' - delete action/operation
#     '-gid' - group ID (argument)
#     '-group' - group name (argument)
#     '-log' - log file path to use for write statistics (argument)
#     '-log-fed' - log file path to use for colored write statistics (argument)
#     '-mode' - object octal mode (argument)
#     '-no-avoid' - disable write avoidance
#     '-no-sanit' - disable environment sanitization
#     '-trunc' - truncate action/operation
#     '-uid' - user ID (argument)
#     '-user' - user name (argument)
#     .
# )
# [$3] - $@
#! .gives.var:
# (0) <_hint> - [string];
#               [hint argument]
#! .rc:
# (0) true
# (1) false
#! .ec:
# (255) input error
#! .desc.ext:
# $1 is a whole number that specifies the number of arguments to offset, to
# skip any wrapper/external arguments accordingly.
#.
hint() {
    assert -min "$#" 2 || exit 255
    assert -whole-n "$1" || exit 255

    _hint="$2"; shift "$((2 + $1))"

    while [ "$#" -ge 1 ]; do
        [ "$1" = "$_hint" ] || { shift && continue; }

        case "$_hint" in
            '-del' | '-no-avoid' | '-no-sanit' | '-trunc')
                _hint= && return 0
            ;;
            '-mode')
                [ "$#" -ge 2 ] || {
                    err -red - 'hint(): Missing argument specification:' \
                        "$_hint"
                    err -red - 'hint(): Use empty quotes to define no value.'

                    exit 255
                }

                _hint="$2" && return 0
            ;;
            '-clear-log' | '-gid' | '-group' | '-log' | '-log-fed' | '-uid' | \
            '-user')
                [ "$2" ] || {
                    err -red - 'hint(): Missing argument specification:' \
                        "$_hint"

                    exit 255
                }

                _hint="$2" && return 0
            ;;
            *)
                err -red - 'hint(): Invalid hint:' "$_hint"

                exit 255
            ;;
        esac
    done

    return 1
}

#! .desc:
# Validate a write is necessary
#! .params:
# <$@> - __write()
#! .rc:
# (0) true
# (1) false
# (2) ENOENT
# (17) EEXIST
#! .ec:
# (255) input error
#! .desc.ext:
# For more information, refer to the documentation of fs_equiv() and __write().
#.
validate_write() {
    [ "$2" ] || {
        err -red - 'Missing OBJ.'; exit 255
    }

    [ "$3" ] || {
        err -red - 'Missing OBJ_PATH.'; exit 255
    }

    case "$1" in
        '-c' | '-l')
            ftype "$2" || return 2
        ;;
        '-o')
            awk '
function is_valid_chunk(chunk) {
	return chunk ~ /^\\0[0-7]{3}$/ ? 0 : 1
}

BEGIN {
	string=ARGV[1]
	delete ARGV

	if (length(string) % 5 != 0)
		exit 1

	for (i = 1; i <= length(string); i += 5) {
		chunk = substr(string, i, 5)

		if (is_valid_chunk(chunk) == 1)
			exit 1
	}

	exit 0
}
    ' "$2" || {
                err -red - 'Bad OBJ; expected octal string.'; exit 255
            }
        ;;
    esac

    case "$4" in
        '-f')
            return 0
        ;;
        '-o')
            :
        ;;
        *)
            { ! ftype "$3"; } || {
                fs_equiv "$@" && return 1 || return 17
            }
        ;;
    esac

    fs_equiv "$@" || return 0

    return 1
}

#! .desc:
# Perform a write
#! .params:
# <$@> - __write()
#! .rc:
# (0) success
# (*) error
#! .desc.ext:
# We do not yet have an in-place overwrite mechanism for types `-c` and `-l`.
# We do not yet have atomic overwrites.
#
# For more information, refer to the documentation of __write().
#.
write() {
    # If write() is executed but the target exists, we here only care whether
    # a soft (in-place) overwrite is specified and provide the subsequent
    # in-place overwrite mechanism + atomicity.
    { ! ftype "$3"; } || {
        chattr_remove "$3" || return "$?"
        unmount "$3" || return "$?"

        case "$4" in
            '-o')
                case "$1" in
                    '-c' | '-l') rm -rf -- "$3" || return "$?" ;;
                esac
            ;;
            *)
                rm -rf -- "$3" || return "$?"
            ;;
        esac
    }

    mkdir_parents "$3" || return "$?"

    case "$1" in
        '-c')
            cp -R -- "$2" "$3" || return "$?"
        ;;
        '-l')
            ln -sf -- "$2" "$3" || return "$?"
        ;;
        '-o')
            printf "%b" "$2" > "$3" || return "$?"
        ;;
        '-w')
            printf "%s" "$2" > "$3" || return "$?"
        ;;
    esac

    if hint 4 -uid "$@" || hint 4 -user "$@"; then
        set -- "$_hint" "$@"

        if hint 5 -gid "$@" || hint 5 -group "$@"; then
            chown -h "$1"":$_hint" -- "$4" || return "$?"
        else
            chown -h "$1" -- "$4" || return "$?"
        fi

        shift
    elif hint 4 -gid "$@" || hint 4 -group "$@"; then
        chgrp -h "$_hint" -- "$3" || return "$?"
    fi

    if hint 4 -mode "$@"; then
        chmod "$_hint" -- "$3" || return "$?"
    fi
}

#! .desc:
# Output write information
#! .params:
# <$@> - __write()
#! .rc:
# (0) success
# (*) error
#! .ec:
# (2) ENOENT
#! .desc.ext:
# For more information, refer to the documentation of __write().
#.
write_info() {
    case "$1$4" in
        '-c-f') __info -white - 'Will write (copy) from/to (OW_HARD):' ;;
        '-c-o') __info -white - 'Will write (copy) from/to (OW_SOFT):' ;;
        '-c') __info -white - 'Will write (copy) from/to:' ;;
        '-l-f') __info -white - 'Will symbolic link source/target (OW_HARD):' ;;
        '-l-o') __info -white - 'Will symbolic link source/target (OW_SOFT):' ;;
        '-l') __info -white - 'Will symbolic link source/target:' ;;
        '-o-f') __info -white - 'Will write a binary file (OW_HARD):' ;;
        '-o-o') __info -white - 'Will write a binary file (OW_SOFT):' ;;
        '-o') __info -white - 'Will write a binary file:' ;;
    esac

    if hint 4 -log-fed "$@"; then
        case "$1$4" in
            '-w-f') __info -white - 'Will update a file (OW_HARD):' ;;
            '-w-o') __info -white - 'Will update a file (OW_SOFT):' ;;
            '-w') __info -white - 'Will update a file:' ;;
        esac
    else
        case "$1$4" in
            '-w-f') __info -white - 'Will write a file (OW_HARD):' ;;
            '-w-o') __info -white - 'Will write a file (OW_SOFT):' ;;
            '-w') __info -white - 'Will write a file:' ;;
        esac
    fi

    case "$1" in
        '-c' | '-l')
            # Do not assume the path still exists.
            ftype "$2" -info && {
                info - - " $2"
            } || {
                err -red - 'ENOENT:'

                err -red -- '>'
                err - - " $2"

                exit 2
            }

            info -white -- '>'
            info - - " $3"
        ;;
        '-o' | '-w')
            info -white -- F
            info - - " $3"
        ;;
    esac
}

#! .desc:
# Output write avoidance information
#! .params:
# <$@> - __write()
#! .rc:
# (0) success
# (*) error
#! .ec:
# (2) ENOENT
#! .desc.ext:
# For more information, refer to the documentation of __write().
#.
write_info_avoidance() {
    case "$1$4" in
        '-c-o') __info -white - 'Copy avoided (OW_SOFT):' ;;
        '-c') __info -white - 'Copy avoided:' ;;
        '-l-o') __info -white - 'Symbolic link avoided (OW_SOFT):' ;;
        '-l') __info -white - 'Symbolic link avoided:' ;;
        '-o-o') __info -white - 'Binary write avoided (OW_SOFT):' ;;
        '-o') __info -white - 'Binary write avoided:' ;;
        '-w-o') __info -white - 'File write avoided (OW_SOFT):' ;;
        '-w') __info -white - 'File write avoided:' ;;
    esac

    # Do not assume the path still exists.
    ftype "$3" -info && {
        info - - " $3"
    } || {
        err -red - 'ENOENT:'

        err -red -- '>'
        err - - " $3"

        exit 2
    }
}

#! .desc:
# Output write statistics
#! .params:
# <$@> - __write()
#! .rc:
# (0) success
#! .desc.ext:
# For more information, refer to the documentation of __write().
#.
write_info_stat() {
    if hint 4 -log "$@"; then
        while IFS= read -r _line || [ "$_line" ]; do
            info - - "$1"
        done < "$_hint"
    elif hint 4 -log-fed "$@"; then
        while IFS=" " read -r _n _line || [ "$_line" ]; do
            set -- "$_line"

            case "$_n" in
                *'+') info -green -- "$_n " && info - - "$1" ;;
                *'-') info -red -- "$_n " && info - - "$1" ;;
            esac
        done < "$_hint"
    else
        case "$1" in
            '-o')
                info -white -- 'SIZE: '
                ccount \\ "$2" && bytes_size "$_count"
            ;;
            '-w')
                case "$2" in
                    *'
')
                        info -white - '0:'

                        info - -- "$2"
                    ;;
                    *)
                        info -white - '0 (no final newline):'

                        info - - "$2"
                    ;;
                esac
            ;;
        esac
    fi

    return 0
}
} # END helper_functions

# Maintainer note for any functions in client_lib():
#
# Utility functions shall always begin with two underscore characters.
client_lib() { # START client_lib
#! .desc:
# Execute an action on an object on the filesystem
#! .params:
# [$1]+ - hint
# [$2] - hint argument
#! .uses.var:
# [OBJ] - [string]
# <OBJ_PATH> - string;
#              path
#! .rc:
# (0) success
# (*) error
#! .ec:
# (2) ENOENT
# (255) input error
#! .desc.ext:
# When $OBJ is defined and `-no-sanit` hint is given, $OBJ will be preserved
# along with $OBJ_PATH.
#
# For more information, refer to the documentation of hint().
#.
__action() {
    set -- "$OBJ" "$OBJ_PATH" "$@"

    [ "$2" ] || {
        err -red - 'Missing OBJ_PATH.'; exit 255
    }

    ftype "$2" || {
        err -red - 'ENOENT:'

        err -red -- '>'
        err - - " $2"

        exit 2
    }

    if hint 2 -trunc "$@"; then
        if ftype "$2"/; then
            rm -rf -- "$2"/* || return "$?"
        else
            { : > "$2"; } || return "$?"
        fi
    fi

    if hint 2 -del "$@"; then
        chattr_remove "$2" || return "$?"
        unmount "$2" || return "$?"
        rm -rf -- "$2" || return "$?"
    fi

    if hint 2 -no-sanit "$@"; then
        OBJ="$1"; OBJ_PATH="$2"
    fi

    return 0
}

#! .desc:
# Write a binary (octal) file
#! .params:
# [$1]+ - hint
# [$2] - hint argument
#! .uses.var:
# <OBJ> - string;
#         POSIX shell-compatible octal escape sequence(s) of the file
# <OBJ_PATH> - string;
#              path to write the file at
#! .desc.ext:
# For more information, refer to the documentation of hint() and __write().
#.
__bin_write() {
    __write -o "$OBJ" "$OBJ_PATH" '' "$@"
}

#! .desc:
# Write a binary (octal) file (overwrite by deletion)
#! .params:
# [$1]+ - hint
# [$2] - hint argument
#! .uses.var:
# <OBJ> - string;
#         POSIX shell-compatible octal escape sequence(s) of the file
# <OBJ_PATH> - string;
#              path to write the file at
#! .desc.ext:
# For more information, refer to the documentation of hint() and __write().
#.
__bin_write_ow_hard() {
    __write -o "$OBJ" "$OBJ_PATH" -f "$@"
}

#! .desc:
# Write a binary (octal) file (in-place + atomic overwrite)
#! .params:
# [$1]+ - hint
# [$2] - hint argument
#! .uses.var:
# <OBJ> - string;
#         POSIX shell-compatible octal escape sequence(s) of the file
# <OBJ_PATH> - string;
#              path to write the file at
#! .desc.ext:
# For more information, refer to the documentation of hint() and __write().
#.
__bin_write_ow_soft() {
    __write -o "$OBJ" "$OBJ_PATH" -o "$@"
}

#! .desc:
# Print formatted text to stderr
#! .params:
# <"$@"> - err()
#! .desc.ext:
# For more information, refer to the documentation of err().
#.
__err() {
    _clr="$1"
    _fmt="$2"

    shift 2 && set -- "$_clr" "$_fmt" "[E $$ $opd]" "$@"

    err "$@"
}

#! .desc:
# Write a file
#! .params:
# [$1]+ - hint
# [$2] - hint argument
#! .uses.var:
# <OBJ> - string;
#         file
# <OBJ_PATH> - string;
#              path to write the file at
#! .desc.ext:
# For more information, refer to the documentation of hint() and __write().
#.
__file_write() {
    __write -w "$OBJ" "$OBJ_PATH" '' "$@"
}

#! .desc:
# Write a file (overwrite by deletion)
#! .params:
# [$1]+ - hint
# [$2] - hint argument
#! .uses.var:
# <OBJ> - string;
#         file
# <OBJ_PATH> - string;
#              path to write the file at
#! .desc.ext:
# For more information, refer to the documentation of hint() and __write().
#.
__file_write_ow_hard() {
    __write -w "$OBJ" "$OBJ_PATH" -f "$@"
}

#! .desc:
# Write a file (in-place + atomic overwrite)
#! .params:
# [$1]+ - hint
# [$2] - hint argument
#! .uses.var:
# <OBJ> - string;
#         file
# <OBJ_PATH> - string;
#              path to write the file at
#! .desc.ext:
# For more information, refer to the documentation of hint() and __write().
#.
__file_write_ow_soft() {
    __write -w "$OBJ" "$OBJ_PATH" -o "$@"
}

#! .desc:
# Print formatted text
#! .params:
# <"$@"> - info()
#! .desc.ext:
# For more information, refer to the documentation of info().
#.
__info() {
    _clr="$1"
    _fmt="$2"

    shift 2 && set -- "$_clr" "$_fmt" "[I $$ $opd]" "$@"

    info "$@"
}

#! .desc:
# Symbolic link an object on the filesystem
#! .params:
# [$1]+ - hint
# [$2] - hint argument
#! .uses.var:
# <OBJ> - string;
#         path
# <OBJ_PATH> - string;
#              path to link the object at
#! .desc.ext:
# For more information, refer to the documentation of hint() and __write().
#.
__obj_link() {
    __obj_link_ow_hard "$@"
}

#! .desc:
# Symbolic link an object on the filesystem (overwrite by deletion)
#! .params:
# [$1]+ - hint
# [$2] - hint argument
#! .uses.var:
# <OBJ> - string;
#         path
# <OBJ_PATH> - string;
#              path to link the object at
#! .desc.ext:
# For more information, refer to the documentation of hint() and __write().
#.
__obj_link_ow_hard() {
    __write -l "$OBJ" "$OBJ_PATH" -f "$@"
}

#! .desc:
# Symbolic link an object on the filesystem (in-place + atomic overwrite)
#! .params:
# [$1]+ - hint
# [$2] - hint argument
#! .uses.var:
# <OBJ> - string;
#         path
# <OBJ_PATH> - string;
#              path to link the object at
#! .desc.ext:
# For more information, refer to the documentation of hint() and __write().
#.
__obj_link_ow_soft() {
    __obj_link_ow_hard "$@"
}

#! .desc:
# Write (copy) an object on the filesystem
#! .params:
# [$1]+ - hint
# [$2] - hint argument
#! .uses.var:
# <OBJ> - string;
#         path
# <OBJ_PATH> - string;
#              path to copy the object at
#! .desc.ext:
# For more information, refer to the documentation of hint() and __write().
#.
__obj_write() {
    __obj_write_ow_hard "$@"
}

#! .desc:
# Write (copy) an object on the filesystem (overwrite by deletion)
#! .params:
# [$1]+ - hint
# [$2] - hint argument
#! .uses.var:
# <OBJ> - string;
#         path
# <OBJ_PATH> - string;
#              path to copy the object at
#! .desc.ext:
# For more information, refer to the documentation of hint() and __write().
#.
__obj_write_ow_hard() {
    __write -c "$OBJ" "$OBJ_PATH" -f "$@"
}

#! .desc:
# Write (copy) an object on the filesystem (in-place + atomic overwrite)
#! .params:
# [$1]+ - hint
# [$2] - hint argument
#! .uses.var:
# <OBJ> - string;
#         path
# <OBJ_PATH> - string;
#              path to copy the object at
#! .desc.ext:
# For more information, refer to the documentation of hint() and __write().
#.
__obj_write_ow_soft() {
    __obj_write_ow_hard "$@"
}

#! .desc:
# Validate and perform a write
#! .params:
# <$1> - type(
#     '-c' - filesystem copy
#     '-l' - symbolic link
#     '-o' - octal write
#     '-w' - file write
#     .
# )
# <$2> - string/object
# <$3> - path to write/copy/link the object at
# <[$4]> - state(
#     '-f' - hard overwrite ($3 is to be deleted)
#     '-o' - soft overwrite (in-place + atomic)
#     .
# )
# [$5]+ - hint
# [$6] - hint argument
#! .rc:
# (0) success
# (1) error
#! .ec:
# (1) error
# (2) ENOENT
# (17) EEXIST
# (255) input error
#! .desc.ext:
# For more information, refer to the documentation of hint(), validate_write(),
# and write().
#.
__write() {
    assert -min "$#" 4 || exit 255
    case "$1" in '-c'|'-l'|'-o'|'-w') : ;; *) exit 255 ;; esac
    case "$4" in '-f'|'-o') : ;; *) [ ! "$4" ] || exit 255 ;; esac

    validate_write "$@" && _rc=0 || _rc="$?"

    case "$_rc" in
        0)
            write_info "$@"
            write_info_stat "$@"

            write "$@" || {
                case "$1" in
                    '-c') __err -red - "Copy error ($?):" ;;
                    '-l') __err -red - "Symbolic link error ($?):" ;;
                    '-o') __err -red - "Binary write error ($?):" ;;
                    '-w') __err -red - "File write error ($?):" ;;
                esac

                ftype "$3" -err && {
                    err - - " $3"
                } || {
                    err -red -- '>'
                    err - - " $3"
                }

                exit 1
            }
        ;;
        1)
            write_info_avoidance "$@"
        ;;
        2)
            case "$1" in
                '-c') __err -red - 'Copy error: ENOENT.' ;;
                '-l') __err -red - 'Symbolic link error: ENOENT.' ;;
                '-o') __err -red - 'Binary write error: ENOENT.' ;;
                '-w') __err -red - 'File write error: ENOENT.' ;;
            esac

            err -red -- '>'
            err - - " $2"

            exit 2
        ;;
        17)
            case "$1" in
                '-c') __err -red - 'Copy error: EEXIST.' ;;
                '-l') __err -red - 'Symbolic link error: EEXIST.' ;;
                '-o') __err -red - 'Binary write error: EEXIST.' ;;
                '-w') __err -red - 'File write error: EEXIST.' ;;
            esac

            # Do not assume the path still exists.
            ftype "$3" -err && {
                err - - " $3"
            } || {
                err -red - 'ENOENT:'

                err -red -- '>'
                err - - " $3"
            }

            exit 17
        ;;
        *)
            case "$1" in
                '-c') err -red - "Copy unhandled error: $_rc" ;;
                '-l') err -red - "Symbolic link unhandled error: $_rc" ;;
                '-o') err -red - "Binary write unhandled error: $_rc" ;;
                '-w') err -red - "File write unhandled error: $_rc" ;;
            esac

            exit 1
        ;;
    esac

    if hint 4 -clear-log "$@"; then
        { : > "$_hint"; } || {
            err -white - 'Failed to clear the log file.'

            return 1
        }
    fi

    if hint 4 -no-sanit "$@"; then
        OBJ="$2"; OBJ_PATH="$3"
    fi

    return 0
}
} # END client_lib

# START utility_functions

#! .desc:
# Print bytes in human-readable fmt: "N" "X"iB / "N" "X"B
#! .params:
# <$1> - bytes
#! .rc:
# (0) success
# (*) error
# (255) bad input
#.
bytes_size() {
    assert -eq "$#" 1 || return 255

    awk -v 'bytes'="$1" '
	function hsize(x, base) {
		basesuf = (base == "1024") ? "iB" : "B"

		s = "BKMGTEPYZ"
		while (x >= base && length(s) > 1)
			{x /= base; s = substr(s, 2)}
		s = substr(s, 1, 1)

		xf = (s == "B") ? "%d" : "%.2f"

		if (s != "B")
			s = s basesuf

		printf((xf " %s"), x, s)
	}

	BEGIN {
		printf hsize(bytes, 1024)
		printf " / "
		print hsize(bytes, 1000)
	}
    '
}

#! .desc:
# Remove the filesystem flag protection of a physical file
#! .params:
# <"$1"> - absolute path
#! .rc:
# (0) success
# (*) error
# (255) bad input
#.
chattr_remove() {
    assert -eq "$#" 1 || return 255

    command -v chattr > /dev/null 2>&1 || return 0

    { [ -f "$1" ] && [ ! -h "$1" ]; } || return 0

    chattr -ia -- "$1" > /dev/null 2>&1 || :
}

#! .desc:
# Create the parents of a file/directory
#! .params:
# <"$1"> - absolute path
#! .rc:
# (0) success
# (*) error
# (255) bad input
#.
mkdir_parents() {
    assert -eq "$#" 1 || return 255

    set -- "${1%"${1##*[!/]}"}"

    if [ -d "${1%/*}/" ]; then
        return 0
    fi

    # Shall consider implementing 'mkdir -p' within the shell by path
    # traversing the function argument and passing separate consequental
    # arguments to mkdir. Important to note that in such situation, error
    # handling would be on us, including the handling of race conditions.
    mkdir -p -- "${1%/*}"
}

#! .desc:
# Print POSIX shell-compatible octal escape sequence(s) of `od -b -An` string
#! .params:
# <["$1"]> - string
#! .uses.fn:
# <assert> ('-eq' '$#' '1');
#          Assert a string
#! .rc:
# (0) success
# (*) error
#! .rc.fn:
# (assert) (255) bad input
#.
to_octal() {
    assert -eq "$#" 1 || return 255

    for _octal in $1; do
        printf "%s" "\\0$_octal"
    done
}

#! .desc:
# Print POSIX shell-compatible octal escape sequence(s) of `od -b` string
#! .params:
# <["$1"]> - string
#! .uses:
# <()>
#! .uses.fn:
# <assert> ('-eq' '$#' '1');
#          Assert a string
# <sline_map> ('$1' 'to_octal_offset_');
#             Process each populated string line with a function
# <to_octal> ("string");
#            Print POSIX shell-compatible octal escape sequence(s) of
#            `od -b -An` string
#! .sets:
# <to_octal_offset_> ();
#! .rc.fn:
# (assert) (255) bad input
# (sline_map) (*) error
# (to_octal) (0) success
# (to_octal) (*) error
#.
to_octal_offset() {
    to_octal_offset_() { printf "%s" "${1#"${1%%[!0123456789]*}"}"; }

    assert -eq "$#" 1 || return 255

    to_octal "$(sline_map "$1" to_octal_offset_)"
}

#! .desc:
# Execute 'umount' on a directory
#! .params:
# <"$1"> - directory
#! .rc:
# (0) success
# (255) bad input
#.
unmount() {
    assert -eq "$#" 1 || return 255

    # exist() does not match dangling symlinks, and does not need to; they
    # cannot be in a state of being mounted.
    command -v umount > /dev/null 2>&1 && [ -e "$1" ] && [ -d "$1" ] || return 0

    umount -Rf -- "$1" > /dev/null 2>&1 || :
}

# END utility_functions

#! .desc:
# Run a command
#! .params:
# <"$1"> - command
# <"$2">+ -  arguments
#! .rc:
# (0) success
# (*) error
# (255) bad usage
#.
__cmd() {
    command -v "$1" > /dev/null 2>&1 || {
        __err -red - 'Missing command:'

        err -white -- '`'
        err - -- "$1"
        err -white - '`'

        exit 127
    }

    __info -white - 'Running command:'

    info -white -- '`'
    info - -- "$@"
    info -white - '`'

    if [ "$silent_cmd" = 1 ]; then
        command "$@" > /dev/null || return "$?"
    else
        command "$@" || return "$?"
    fi
}

#! .desc:
# Run a command and store output in $OBJ
#! .params:
# <[$1]> - option_block(
#     'e' - missing output is an error condition
#     'n' - preserve final <newline> characters as given
#     's' - (only with `n`) always strip one final <newline> character
#     .
# )
# <"$2"> - command
# <"$3">+ -  arguments
#! .rc:
# (0) success
# (*) error
# (255) bad usage
#.
__cmd_OBJ() {
    assert -min "$#" 2 || return 255

    command -v "$2" > /dev/null 2>&1 || {
        __err -red - 'Missing command:'

        err -white -- '`'
        err - -- "$2"
        err -white - '`'

        exit 127
    }

    __info -white - 'Running command:'

    info -white -- '`'
    info - -- "$2"; offset 2 "$#" "$@" info - ---
    info -white - '`'

    case "$1" in
        *n*s*)
            OBJ=$(shift && command "$@" && printf "%s" x) && \
            OBJ="${OBJ%?}" && \
            OBJ="${OBJ%?}"
        ;;
        *n*)
            OBJ=$(shift && command "$@" && printf "%s" x) && \
            OBJ="${OBJ%?}"
        ;;
        *)
            OBJ=$(shift && command "$@")
        ;;
    esac

    case "$1" in
        *e*)
            [ "$OBJ" ] || {
                __err -red - 'No output has been received.'

                exit 1
            }
        ;;
    esac
}

#! .desc:
# Modify file data in-place according to format (see fed())
#! .params:
# <[$1]> - crc32 string to verify produced format against
# <["$2"]> - log file path
# <$3>+ - operation(
#     '-' - EOF add $4
#     '-m' - apply modifier for `-a`/`-r`/`-s`; see extended description
#     '-a' - add $4
#     '-r' - remove $4
#     '-s' - substitute $4 with $5
#     .
# )
# ["$4"] - string
# ["$5"] - string
#.
__fed() {
    assert -min "$#" 3 || return 255

    [ "$OBJ" ] || {
        file_preload -cat "$OBJ_PATH" || exit "$?"

        OBJ="$_file"
    }

    set -- "$OBJ" "$@"

    _fmt=$(
        _a="$1"; shift 3

        fed "$_a" "$@" || {
            set -- "$?"; case "$1" in
                1) [ ! "$_fmt" ] || return "$1" ;;
                *) return "$1" ;;
            esac
        }

        printf "%s" "$_fmt"
    ) || exit "$?"

    [ "$_fmt" ] || return 0

    set -- "$_fmt" "$@"

    _cksum=$(printf "%s" "$1" | cksum) && \
    _cksum="${_cksum%%' '*}" || exit "$?"

    if [ "$3" ] && [ "$3" != "$_cksum" ]; then
        __info -yellow - "CRC32 mismatch. (exp. $3; got $_cksum)"
        __info -white - 'Format:'
        info - - "$1"

        if [ "$confirm_crc" = 1 ]; then
            __info -white - 'Auto accepted the mismatch.'
        elif [ "$interactive" = 1 ]; then
            confirm_cont || return 0
        else
            return 0
        fi
    fi

    OBJ=$(
        _a="$2"; _b="$4"; eval set -- "$1"

        libfile "$_b" "$_a" "$@" || return "$?"

        printf "%s" "${_file}x"
    ) && OBJ="${OBJ%?}" || exit "$?"
}

err_handler() {
    IFS=' 	''
'

    trap - INT TERM

    # env cleanup
    if [ -e "$tmpd" ] || [ -e "$tmpf" ] || [ -e "$logf" ] || \
        [ -h "$tmpd" ] || [ -h "$tmpf" ] || [ -h "$logf" ]; then
        chattr -R -ia "$tmpd" "$tmpf" "$logf" > /dev/null 2>&1 || :
        rm -rf "$tmpd" "$tmpf" "$logf"
    fi

    if [ "$1" = 0 ]; then
        exit 0
    elif [ "$2" = INT ]; then
        err -red - "${0##*/}: Received INT signal. ($1)"; kill -2 "$$"
    else
        err -red - "${0##*/}: Received $2 signal. ($1)"; exit "$1"
    fi
}

main() {
    LC_ALL=C; export LC_ALL
    set -e
    trap "err_handler \$? INT" INT
    trap "err_handler \$? TERM" TERM

    case "$1" in
        '-0')
            _lib_sg="$2"; shift 2
        ;;
        *)
            case "$0" in
                /*) _a="$0" ;;
                *) _a="${PWD%"${PWD##*[!/]}"}"/"$0" ;;
            esac

            if [ -h "$_a" ]; then
                _a="$(realpath -- "$_a" && printf "%s" x)"
                _a="${_a%??}"
            fi

            _a="${_a%"${_a##*[!/]}"}"
            _a="${_a%/*}"
            _a="${_a%"${_a##*[!/]}"}"
            _a="${_a%/*}"
            _a="${_a%"${_a##*[!/]}"}"

            _lib_sg="$_a"/lib/shell-glossary/src
        ;;
    esac

    for _func in "$_lib_sg"/*; do
        if [ -f "$_func" ]; then
            . "$_func"
        fi
    done

    # Control switches
    # Automatically continue/confirm any CRC32 mismatch prompts.
    confirm_crc=0
    # Disable write avoidance:
    disable_write_avoid=
    # Disable write avoidance assert on group ownership:
    disable_write_avoid_group=
    # Disable write avoidance assert on object mode:
    disable_write_avoid_perm=
    # Disable write avoidance assert on object type:
    disable_write_avoid_type=
    # Disable write avoidance assert on object type attributes:
    disable_write_avoid_type_attr=
    # Disable write avoidance assert on user ownership:
    disable_write_avoid_user=
    # Interactive mode; prompt for input on dual actions.
    interactive=0
    # Disable command output:
    silent_cmd=0
    # Disable write information output:
    silent_write=
    # Disable write avoidance output:
    silent_write_avoid=
    # Disable write statistics output:
    silent_write_stat=
    # Specify default state "hard overwrite" for all overwrites:
    write_always=
    # Specify default state "soft overwrite" for all writes:
    write_forced=

    # Utility internal locations
    # Temporary per-function dir (cleared on func exit):
    tmpd="${TMPDIR:-/tmp}/syscfg_tmpd"
    # Temporary per-function file (cleared on func exit):
    tmpf="${TMPDIR:-/tmp}/syscfg_tmpf"
    # Temporary per-function log file (cleared on func exit):
    logf="${TMPDIR:-/tmp}/syscfg_logf"

    while :; do case "$1" in
        '^CC') confirm_crc=1; shift && continue ;;
        '^DWA') disable_write_avoid=1; shift && continue ;;
        '^DWAG') disable_write_avoid_group=1; shift && continue ;;
        '^DWAP') disable_write_avoid_perm=1; shift && continue ;;
        '^DWAT') disable_write_avoid_type=1; shift && continue ;;
        '^DWATA') disable_write_avoid_type_attr=1; shift && continue ;;
        '^DWAU') disable_write_avoid_user=1; shift && continue ;;
        '^I') interactive=1; shift && continue ;;
        '^SC') silent_cmd=1; shift && continue ;;
        '^SW') silent_write=1; shift && continue ;;
        '^SWA') silent_write_avoid=1; shift && continue ;;
        '^SWS') silent_write_stat=1; shift && continue ;;
        '^WA') write_always=1; shift && continue ;;
        '^WF') write_forced=1; shift && continue ;;
        *) break ;;
    esac done

    [ ! "$disable_write_avoid" ] || {
        fs_equiv() { return 0; }
    }

    [ ! "$disable_write_avoid_group" ] || {
        fs_equiv_group() { return 0; }
    }

    [ ! "$disable_write_avoid_perm" ] || {
        fs_equiv_perm() { return 0; }
    }

    [ ! "$disable_write_avoid_type" ] || {
        fs_equiv_type() { return 0; }
    }

    [ ! "$disable_write_avoid_type_attr" ] || {
        fs_equiv_type_attr() { return 0; }
    }

    [ ! "$disable_write_avoid_user" ] || {
        fs_equiv_owner() { return 0; }
    }

    [ ! "$write_always" ] || {
        __bin_write_ow_soft() { __bin_write_ow_hard "$@"; }
        __file_write_ow_soft() { __file_write_ow_hard "$@"; }
        __obj_link_ow_soft() { __obj_link_ow_hard "$@"; }
        __obj_write_ow_soft() { __obj_write_ow_hard "$@"; }
    }

    [ ! "$write_forced" ] || {
        __bin_write() { __bin_write_ow_soft "$@"; }
        __file_write() { __file_write_ow_soft "$@"; }
        __obj_link() { __obj_link_ow_soft "$@"; }
        __obj_write() { __obj_write_ow_soft "$@"; }
    }

    [ ! "$silent_write" ] || {
        write_info() { return 0; }
    }

    [ ! "$silent_write_avoid" ] || {
        write_info_avoidance() { return 0; }
    }

    [ ! "$silent_write_stat" ] || {
        write_info_stat() { return 0; }
    }

    readonly \
        confirm_crc interactive logf silent_cmd tmpd tmpf

    assert -min "$#" 1 || {
        err -red - 'No client has been specified.'
        err - -

        exit 2
    }

    # end arg parsing; main()

    [ "$(id -u)" = 0 ] || {
        err -red - 'Missing root rights.'; exit 1
    }

    # past env cleanup from SIGKILL or something else
    if [ -e "$tmpd" ] || [ -e "$tmpf" ] || [ -e "$logf" ] || \
        [ -h "$tmpd" ] || [ -h "$tmpf" ] || [ -h "$logf" ]; then
        chattr -R -ia "$tmpd" "$tmpf" "$logf" > /dev/null 2>&1 || :
        rm -rf "$tmpd" "$tmpf" "$logf"
    fi

    while [ "$1" ]; do
        # env setup
        ( umask 077; mkdir "$tmpd"; : > "$tmpf" > "$logf"; ) || return "$?"

        # In the future, clients will be launched as an external command,
        # lexed and parsed by syscfg.
        ( . "$1" "$1"; ) || return "$?"

        # env reset
        if [ -e "$tmpd" ] || [ -e "$tmpf" ] || [ -e "$logf" ] || \
            [ -h "$tmpd" ] || [ -h "$tmpf" ] || [ -h "$logf" ]; then
            chattr -R -ia "$tmpd" "$tmpf" "$logf" > /dev/null 2>&1 || :
            rm -rf "$tmpd" "$tmpf" "$logf"
        fi

        info -green - "$1:" 'Done!'

        shift
    done

    return 0
}

assertive_functions;
helper_functions;
client_lib;
main "$@" || { err_handler "$?" 'ERR'; }
