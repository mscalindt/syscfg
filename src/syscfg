#!/bin/sh
# SPDX-License-Identifier: BSD-2-Clause
# Copyright (C) 2022-2025 Dimitar Yurukov <mscalindt@protonmail.com>
# syscfg - declarative OS configuration

# START boilerplate_functions

#! .desc:
# Restore the old state of IFS
#! .rc:
# (0) success
# (*) error
#.
IFS_restore() {
    IFS="$_old_IFS" 2> /dev/null
    ${_old_IFS+':'} unset IFS 2> /dev/null
}

#! .desc:
# Save the current state of IFS
#! .rc:
# (0) success
# (*) error
#.
IFS_save() {
    _old_IFS="$IFS" 2> /dev/null
    ${IFS+':'} unset _old_IFS 2> /dev/null
}

#! .desc:
# Check argument count in $#
#! .params:
# <$1> - N
# <"$2"> - $#
#! .rc:
# (0) valid
# (1) invalid
# (255) bad input
#.
args_eq() {
    # Check if $1 is a whole number
    case :"$1${1#*[!0123456789]}" in
        :) return 255 ;;
        :00) : ;;
        :0*) return 255 ;;
        :"$1$1") : ;;
        *) return 255 ;;
    esac

    # Check if $2 is a whole number
    case :"$2${2#*[!0123456789]}" in
        :) return 255 ;;
        :00) : ;;
        :0*) return 255 ;;
        :"$2$2") : ;;
        *) return 255 ;;
    esac

    [ "$1" -eq "$2" ]
}

#! .desc:
# Check for maximum argument count in $#
#! .params:
# <$1> - N
# <"$2"> - $#
#! .rc:
# (0) valid
# (1) invalid
# (255) bad input
#.
args_max() {
    # Check if $1 is a natural number
    case :"$1${1#*[!0123456789]}" in
        : | :0*) return 255 ;;
        :"$1$1") : ;;
        *) return 255 ;;
    esac

    # Check if $2 is a whole number
    case :"$2${2#*[!0123456789]}" in
        :) return 255 ;;
        :00) : ;;
        :0*) return 255 ;;
        :"$2$2") : ;;
        *) return 255 ;;
    esac

    [ "$2" -le "$1" ]
}

#! .desc:
# Check for minimum argument count in $#
#! .params:
# <$1> - N
# <"$2"> - $#
#! .rc:
# (0) valid
# (1) invalid
# (255) bad input
#.
args_min() {
    # Check if $1 is a natural number
    case :"$1${1#*[!0123456789]}" in
        : | :0*) return 255 ;;
        :"$1$1") : ;;
        *) return 255 ;;
    esac

    # Check if $2 is a whole number
    case :"$2${2#*[!0123456789]}" in
        :) return 255 ;;
        :00) : ;;
        :0*) return 255 ;;
        :"$2$2") : ;;
        *) return 255 ;;
    esac

    [ "$2" -ge "$1" ]
}

#! .desc:
# Check if a command exists
#! .params:
# <"$1"> - command
#! .rc:
# (0) yes
# (*) no
# (255) bad input
#.
cmd() {
    args_eq 1 "$#" || return 255

    command -v "$1" > /dev/null 2>&1
}

#! .desc:
# Check if a given path is a directory
#! .params:
# <"$1"> - path
#! .rc:
# (0) yes
# (1) no
# (255) bad input
#.
dir() {
    args_eq 1 "$#" || return 255

    [ -d "$1" ]
}

#! .desc:
# Check if a given path exists
#! .params:
# <"$1"> - path
#! .rc:
# (0) yes
# (1) no
# (255) bad input
#.
exist() {
    args_eq 1 "$#" || return 255

    [ -e "$1" ]
}

#! .desc:
# Check if a given path is a regular file
#! .params:
# <"$1"> - path
#! .rc:
# (0) yes
# (1) no
# (255) bad input
#.
file() {
    args_eq 1 "$#" || return 255

    [ -f "$1" ]
}

#! .desc:
# Check if a given string is entirely octal
#! .params:
# <"$1"> - string
#! .rc:
# (0) yes
# (1) no
# (*) error
# (255) bad input
#.
is_octal() {
    args_eq 1 "$#" || return 255

    IFS_save;

    IFS="$LF"' '; for _octal in $1; do
        case "$_octal" in
            *[!0123456789]*) IFS_restore; return 1 ;;
        esac
    done

    IFS_restore;
}

#! .desc:
# Check if the system is booted in UEFI mode
#! .rc:
# (0) yes
# (1) no
#.
is_uefi() {
    dir '/sys/firmware/efi/efivars'
}

#! .desc:
# Check if a given path is readable
#! .params:
# <"$1"> - path
#! .rc:
# (0) yes
# (1) no
# (255) bad input
#.
readable() {
    args_eq 1 "$#" || return 255

    [ -r "$1" ]
}

#! .desc:
# Check if text appears anywhere in a given string
#! .params:
# <"$1"> - text
# <"$2"> - string
#! .rc:
# (0) yes
# (1) no
# (255) bad input
#.
str() {
    args_eq 2 "$#" || return 255

    case "$2" in
        *"$1"*) return 0 ;;
    esac

    return 1
}

#! .desc:
# Check if text appears at the left side of a given string
#! .params:
# <"$1"> - text
# <"$2"> - string
#! .rc:
# (0) yes
# (1) no
# (255) bad input
#.
str_pfix() {
    args_eq 2 "$#" || return 255

    case "$2" in
        "$1"*) return 0 ;;
    esac

    return 1
}

#! .desc:
# Check if text appears at the right side of a given string
#! .params:
# <"$1"> - text
# <"$2"> - string
#! .rc:
# (0) yes
# (1) no
# (255) bad input
#.
str_sfix() {
    args_eq 2 "$#" || return 255

    case "$2" in
        *"$1") return 0 ;;
    esac

    return 1
}

#! .desc:
# Check if a given path is writable
#! .params:
# <"$1"> - path
#! .rc:
# (0) yes
# (1) no
# (255) bad input
#.
writable() {
    args_eq 1 "$#" || return 255

    [ -w "$1" ]
}

# END boilerplate_functions
# START output_functions

#! .desc:
# Print formatted text to stderr
#! .params:
# <$1> - color(
#     '-'  - none
#     '-bk' - black
#     '-r' - red
#     '-g' - green
#     '-y' - yellow
#     '-be' - blue
#     '-m' - magenta
#     '-c' - cyan
#     '-w' - white
#     .
# )
# <$2> - type(
#     '-' - raw
#     '--' - raw, no newline
#     '-1' - %H%M%S date fmt
#     '-2' - %H%M%S date fmt, no newline
#     .
# )
# <"$3"+> - text
#! .uses:
# [NO_COLOR] $ - this environment variable disables colored output
#! .rc:
# (0) success
# (255) bad input
#.
err() {
    args_min 3 "$#" || return 255

    case $1 in
        '-') _color= ;;
        '-bk') _color='\033[1;30m' ;;
        '-r') _color='\033[1;31m' ;;
        '-g') _color='\033[1;32m' ;;
        '-y') _color='\033[1;33m' ;;
        '-be') _color='\033[1;34m' ;;
        '-m') _color='\033[1;35m' ;;
        '-c') _color='\033[1;36m' ;;
        '-w') _color='\033[1;37m' ;;
        *) return 255 ;;
    esac

    if [ "$NO_COLOR" ]; then
        case $2 in
            '-')
                shift 2
                printf "%s\n" "$*" >&2
            ;;
            '--')
                shift 2
                printf "%s" "$*" >&2
            ;;
            '-1')
                shift 2
                printf "[%s] =>>: %s\n" "$(date "+%H:%M:%S")" "$*" >&2
            ;;
            '-2')
                shift 2
                printf "[%s] =>>: %s" "$(date "+%H:%M:%S")" "$*" >&2
            ;;
            *)
                return 255
            ;;
        esac
    else
        case $2 in
            '-')
                shift 2
                printf "%b%s%b\n" "$_color" "$*" '\033[0m' >&2
            ;;
            '--')
                shift 2
                printf "%b%s%b" "$_color" "$*" '\033[0m' >&2
            ;;
            '-1')
                shift 2
                printf "%b[%s] =>>: %b%s%b\n" "$_color" "$(date "+%H:%M:%S")" \
                                              '\033[1;37m' "$*" '\033[0m' >&2
            ;;
            '-2')
                shift 2
                printf "%b[%s] =>>: %b%s%b" "$_color" "$(date "+%H:%M:%S")" \
                                            '\033[1;37m' "$*" '\033[0m' >&2
            ;;
            *)
                return 255
            ;;
        esac
    fi
}

#! .desc:
# Print red-colored formatted text to stderr and exit
#! .params:
# <$1> - exit code
# <$2> - type(
#     '-' - raw
#     '--' - raw, no newline
#     '-1' - %H%M%S date fmt
#     '-2' - %H%M%S date fmt, no newline
#     .
# )
# <"$3"+> - text
#! .uses:
# [NO_COLOR] $ - this environment variable disables colored output
#! .rc:
# (*) success
# (255) bad input
#.
errF() {
    args_min 3 "$#" || return 255

    # Check if $1 is a whole number
    case :"$1${1#*[!0123456789]}" in
        :) return 255 ;;
        :00) : ;;
        :0*) return 255 ;;
        :"$1$1") : ;;
        *) return 255 ;;
    esac

    [ "$1" -le 255 ] || return 255

    _exit_code="$1"

    if [ "$NO_COLOR" ]; then
        case $2 in
            '-')
                shift 2
                printf "%s\n" "$*" >&2
            ;;
            '--')
                shift 2
                printf "%s" "$*" >&2
            ;;
            '-1')
                shift 2
                printf "[%s] =>>: %s\n" "$(date "+%H:%M:%S")" "$*" >&2
            ;;
            '-2')
                shift 2
                printf "[%s] =>>: %s" "$(date "+%H:%M:%S")" "$*" >&2
            ;;
            *)
                return 255
            ;;
        esac
    else
        case $2 in
            '-')
                shift 2
                printf "%b%s%b\n" '\033[1;31m' "$*" '\033[0m' >&2
            ;;
            '--')
                shift 2
                printf "%b%s%b" '\033[1;31m' "$*" '\033[0m' >&2
            ;;
            '-1')
                shift 2
                printf "%b[%s] =>>: %b%s%b\n" '\033[1;31m' \
                                              "$(date "+%H:%M:%S")" \
                                              '\033[1;37m' "$*" '\033[0m' >&2
            ;;
            '-2')
                shift 2
                printf "%b[%s] =>>: %b%s%b" '\033[1;31m' \
                                            "$(date "+%H:%M:%S")" \
                                            '\033[1;37m' "$*" '\033[0m' >&2
            ;;
            *)
                return 255
            ;;
        esac
    fi

    exit "$_exit_code"
}

#! .desc:
# Print formatted text to stdout
#! .params:
# <$1> - color(
#     '-'  - none
#     '-bk' - black
#     '-r' - red
#     '-g' - green
#     '-y' - yellow
#     '-be' - blue
#     '-m' - magenta
#     '-c' - cyan
#     '-w' - white
#     .
# )
# <$2> - type(
#     '-' - raw
#     '--' - raw, no newline
#     '-1' - %H%M%S date fmt
#     '-2' - %H%M%S date fmt, no newline
#     .
# )
# <"$3"+> - text
#! .uses:
# [NO_COLOR] $ - this environment variable disables colored output
#! .rc:
# (0) success
# (255) bad input
#.
info() {
    args_min 3 "$#" || return 255

    case $1 in
        '-') _color= ;;
        '-bk') _color='\033[1;30m' ;;
        '-r') _color='\033[1;31m' ;;
        '-g') _color='\033[1;32m' ;;
        '-y') _color='\033[1;33m' ;;
        '-be') _color='\033[1;34m' ;;
        '-m') _color='\033[1;35m' ;;
        '-c') _color='\033[1;36m' ;;
        '-w') _color='\033[1;37m' ;;
        *) return 255 ;;
    esac

    if [ "$NO_COLOR" ]; then
        case $2 in
            '-')
                shift 2
                printf "%s\n" "$*"
            ;;
            '--')
                shift 2
                printf "%s" "$*"
            ;;
            '-1')
                shift 2
                printf "[%s] =>>: %s\n" "$(date "+%H:%M:%S")" "$*"
            ;;
            '-2')
                shift 2
                printf "[%s] =>>: %s" "$(date "+%H:%M:%S")" "$*"
            ;;
            *)
                return 255
            ;;
        esac
    else
        case $2 in
            '-')
                shift 2
                printf "%b%s%b\n" "$_color" "$*" '\033[0m'
            ;;
            '--')
                shift 2
                printf "%b%s%b" "$_color" "$*" '\033[0m'
            ;;
            '-1')
                shift 2
                printf "%b[%s] =>>: %b%s%b\n" "$_color" "$(date "+%H:%M:%S")" \
                                              '\033[1;37m' "$*" '\033[0m'
            ;;
            '-2')
                shift 2
                printf "%b[%s] =>>: %b%s%b" "$_color" "$(date "+%H:%M:%S")" \
                                            '\033[1;37m' "$*" '\033[0m'
            ;;
            *)
                return 255
            ;;
        esac
    fi
}

# END output_functions
# START utility_functions

#! .desc:
# Print bytes in human-readable fmt: "N" "X"iB / "N" "X"B
#! .params:
# <$1> - bytes
#! .rc:
# (0) success
# (*) error
# (255) bad input
#.
bytes_size() {
    args_eq 1 "$#" || return 255

    awk -v 'bytes'="$1" '
	function hsize(x, base) {
		basesuf = (base == "1024") ? "iB" : "B"

		s = "BKMGTEPYZ"
		while (x >= base && length(s) > 1)
			{x /= base; s = substr(s, 2)}
		s = substr(s, 1, 1)

		xf = (s == "B") ? "%d" : "%.2f"

		if (s != "B")
			s = s basesuf

		printf((xf " %s"), x, s)
	}

	BEGIN {
		printf hsize(bytes, 1024)
		printf " / "
		print hsize(bytes, 1000)
	}
    ' 2> /dev/null
}

#! .desc:
# Remove the filesystem flag protection of a physical file
#! .params:
# <"$1"> - absolute path
#! .rc:
# (0) success
# (*) error
# (255) bad input
#.
chattr_remove() {
    args_eq 1 "$#" || return 255

    cmd 'chattr' || return 0

    { [ -f "$1" ] && [ ! -h "$1" ]; } || return 0

    chattr -ia "$1" 2> /dev/null || :
}

#! .desc:
# Process each populated IFS field split with a function
#! .params:
# <"$1"> - string
# <$2> - function name
# ["$3"]+ - function argument
#! .uses.var:
# <IFS> $ - environment variable;
#           list of characters that is used for field splitting
#! .sets:
# <set +f>;
#! .rc:
# (0) success
# (*) error
#! .rc.fn:
# ($2) (*) error
#! .desc.ext:
# > "POSIX.1-2024, Volume: Shell & Utilities, Section: Shell Command Language,
#   Subsection: Field Splitting".
# > "POSIX.1-2024, Volume: Shell & Utilities, Section: Shell Command Language,
#   Subsection: set".
# > "POSIX.1-2024, Volume: Shell & Utilities, Section: Shell Command Language,
#   Subsection: Shell Variables".
#.
ifs_map() {
    set -f && _str="$1" && shift && for _field in $_str; do
        [ "$_field" ] || continue

        "$@" "$_field" || { set -- "$?"; set +f; return "$?"; }
    done && set +f
}

#! .desc:
# Create the parents of a file/directory
#! .params:
# <"$1"> - absolute path
#! .rc:
# (0) success
# (*) error
# (255) bad input
#.
mkdir_parents() {
    args_eq 1 "$#" || return 255

    if str_sfix '/' "$1"; then
        set -- "${1%?}"
    fi

    if dir "${1%/*}"; then
        return 0
    fi

    # Shall consider implementing 'mkdir -p' within the shell by path
    # traversing the function argument and passing separate consequental
    # arguments to mkdir. Important to note that in such situation, error
    # handling would be on us, including the handling of race conditions.
    mkdir -p "${1%/*}" 2> /dev/null
}

#! .desc:
# Convert an octal sequence into ASCII characters
#! .params:
# <"$1"> - octal sequence
#! .rc:
# (0) success
# (*) error
# (255) bad input
#.
octal_decode() {
    args_eq 1 "$#" || return 255

    IFS_save;

    IFS="$LF"' '; for _octal in $1; do
        printf "%b" "\\$_octal"
    done

    IFS_restore;
}

#! .desc:
# Print the return code of a command
#! .params:
# <"$1"> - command
# ["$2"+] - arguments
#! .rc:
# (0) success
# (127) command does not exist
# (255) bad input
#.
rc() {
    args_min 1 "$#" || return 255

    if cmd "$1"; then
        "$@" > /dev/null 2>&1
        printf "%d" "$?"
    else
        return 127
    fi

    return 0
}

#! .desc:
# Replace specific character(s) with character(s) in a given string
#! .params:
# <"$1"> - specific character(s)
# <"$2"> - character(s)
# <"$3"> - string
#! .gives:
# (0) <"$_str"> - the modified string
#! .rc:
# (0) success
# (*) error
# (255) bad input
#.
replchars() {
    args_eq 3 "$#" || return 255

    replchar() {
        IFS="$1"; _chars="$2"

        set -f; set -- $3 "$3"; set +f

        _str=; while [ "$#" -ge 3 ]; do
            _str="$_str$1$_chars"; shift
        done

        if str "${2#"${2%?}"}" "$IFS"; then
            _str="$_str$1$_chars"
        else
            _str="$_str$1"
        fi
    }

    IFS_save;
    replchar "$1" "$2" "$3"
    IFS_restore;
}

#! .desc:
# Execute 'umount' on a directory
#! .params:
# <"$1"> - directory
#! .rc:
# (0) success
# (255) bad input
#.
unmount() {
    args_eq 1 "$#" || return 255

    cmd 'umount' && exist "$1" && dir "$1" || return 0

    umount -Rf "$1" > /dev/null 2>&1 || :
}

# END utility_functions
# START std_err_functions; 201-222

#! .desc:
# EPERM: "Operation not permitted"
#! .rc:
# 201
#.
EPERM() { err -r -2 'EPERM:'; }

#! .desc:
# ENOENT: "No such file or directory"
#! .rc:
# 202
#.
ENOENT() { err -r -1 'ENOENT:'; }

#! .desc:
# EEXIST: "Already exists"
#! .params:
# <"$1"+> - absolute path
#! .rc:
# (217)
# (255) bad input
#.
EEXIST() {
    args_min 1 "$#" || return 255

    err -r -1 'EEXIST:'

    while [ "$1" ]; do
        if [ -b "$1" ]; then
            err -r -- 'B ' # block file
        elif [ -c "$1" ]; then
            err -r -- 'C ' # character file
        elif [ -d "$1" ]; then
            err -r -- 'D ' # directory
        elif [ -f "$1" ]; then
            err -r -- 'F ' # regular file
        elif [ -h "$1" ]; then
            err -r -- 'L ' # symbolic link
        elif [ -p "$1" ]; then
            err -r -- 'P ' # named pipe
        elif [ -S "$1" ]; then
            err -r -- 'S ' # socket
        elif [ -t "$1" 2> /dev/null ]; then
            err -r -- 'FD ' # open file descriptor
        elif [ -e "$1" ]; then
            err -r -- '> '
        fi
        err - - "$1"

        shift
    done

    exit 217
}

#! .desc:
# ENOTDIR: "Not a directory"
#! .params:
# <"$1"+> - absolute path
#! .rc:
# (220)
# (255) bad input
#.
ENOTDIR() {
    args_min 1 "$#" || return 255

    err -r -1 'ENOTDIR:'

    while [ "$1" ]; do
        if [ -b "$1" ]; then
            err -r -- 'B ' # block file
        elif [ -c "$1" ]; then
            err -r -- 'C ' # character file
        elif [ -f "$1" ]; then
            err -r -- 'F ' # regular file
        elif [ -h "$1" ]; then
            err -r -- 'L ' # symbolic link
        elif [ -p "$1" ]; then
            err -r -- 'P ' # named pipe
        elif [ -S "$1" ]; then
            err -r -- 'S ' # socket
        elif [ -t "$1" 2> /dev/null ]; then
            err -r -- 'FD ' # open file descriptor
        elif [ -e "$1" ]; then
            err -r -- '> '
        fi
        err - - "$1"

        shift
    done

    exit 220
}

#! .desc:
# EISDIR: "Is a directory"
#! .params:
# <"$1"+> - absolute path
#! .rc:
# (221)
# (255) bad input
#.
EISDIR() {
    args_min 1 "$#" || return 255

    err -r -1 'EISDIR:'

    while [ "$1" ]; do
        if dir "$1"; then
            err -r -- 'D ';
        elif exist "$1"; then
            err -r -- '> '
        fi
        err - - "$1"

        shift
    done

    exit 221
}

#! .desc:
# EINVAL: "Invalid argument"
#! .rc:
# 222
#.
EINVAL() { err -r -1 'EINVAL:'; }

# END std_err_functions; 201-222
# START custom_err_functions; 230-235

#! .desc:
# ENOCMD: "No such command"
#! .params:
# <"$1"> - command
#! .rc:
# (230)
# (255) bad input
#.
ENOCMD() {
    args_eq 1 "$#" || return 255

    err -r -1 "ENOCMD: $1"

    exit 230
}

#! .desc:
# EREAD: "Error reading file or directory"
#! .params:
# <"$1"+> - absolute path
#! .rc:
# (231)
# (255) bad input
#.
EREAD() {
    args_min 1 "$#" || return 255

    err -r -1 'EREAD:'

    while [ "$1" ]; do
        if [ -b "$1" ]; then
            err -r -- 'B ' # block file
        elif [ -c "$1" ]; then
            err -r -- 'C ' # character file
        elif [ -d "$1" ]; then
            err -r -- 'D ' # directory
        elif [ -f "$1" ]; then
            err -r -- 'F ' # regular file
        elif [ -h "$1" ]; then
            err -r -- 'L ' # symbolic link
        elif [ -p "$1" ]; then
            err -r -- 'P ' # named pipe
        elif [ -S "$1" ]; then
            err -r -- 'S ' # socket
        elif [ -t "$1" 2> /dev/null ]; then
            err -r -- 'FD ' # open file descriptor
        elif [ -e "$1" ]; then
            err -r -- '> '
        fi
        err - - "$1"

        shift
    done

    exit 231
}

#! .desc:
# ENOTFILE: "Not a file"
#! .params:
# <"$1"+> - absolute path
#! .rc:
# (232)
# (255) bad input
#.
ENOTFILE() {
    args_min 1 "$#" || return 255

    err -r -1 'ENOTFILE:'

    while [ "$1" ]; do
        if [ -b "$1" ]; then
            err -r -- 'B ' # block file
        elif [ -c "$1" ]; then
            err -r -- 'C ' # character file
        elif [ -d "$1" ]; then
            err -r -- 'D ' # directory
        elif [ -h "$1" ]; then
            err -r -- 'L ' # symbolic link
        elif [ -p "$1" ]; then
            err -r -- 'P ' # named pipe
        elif [ -S "$1" ]; then
            err -r -- 'S ' # socket
        elif [ -t "$1" 2> /dev/null ]; then
            err -r -- 'FD ' # open file descriptor
        elif [ -e "$1" ]; then
            err -r -- '> '
        fi
        err - - "$1"

        shift
    done

    exit 232
}

#! .desc:
# EFSFLAG: "Error setting filesystem flag(s)"
#! .params:
# <"$1"+> - absolute path
#! .rc:
# (233)
# (255) bad input
#.
EFSFLAG() {
    args_min 1 "$#" || return 255

    err -r -1 'EFSFLAG:'

    while [ "$1" ]; do
        if [ -b "$1" ]; then
            err -r -- 'B ' # block file
        elif [ -c "$1" ]; then
            err -r -- 'C ' # character file
        elif [ -d "$1" ]; then
            err -r -- 'D ' # directory
        elif [ -f "$1" ]; then
            err -r -- 'F ' # regular file
        elif [ -h "$1" ]; then
            err -r -- 'L ' # symbolic link
        elif [ -p "$1" ]; then
            err -r -- 'P ' # named pipe
        elif [ -S "$1" ]; then
            err -r -- 'S ' # socket
        elif [ -t "$1" 2> /dev/null ]; then
            err -r -- 'FD ' # open file descriptor
        elif [ -e "$1" ]; then
            err -r -- '> '
        fi
        err - - "$1"

        shift
    done

    exit 233
}

#! .desc:
# EPERMS: "Error setting permissions"
#! .params:
# <"$1"+> - absolute path
#! .rc:
# (234)
# (255) bad input
#.
EPERMS() {
    args_min 1 "$#" || return 255

    err -r -1 'EPERMS:'

    while [ "$1" ]; do
        if [ -b "$1" ]; then
            err -r -- 'B ' # block file
        elif [ -c "$1" ]; then
            err -r -- 'C ' # character file
        elif [ -d "$1" ]; then
            err -r -- 'D ' # directory
        elif [ -f "$1" ]; then
            err -r -- 'F ' # regular file
        elif [ -h "$1" ]; then
            err -r -- 'L ' # symbolic link
        elif [ -p "$1" ]; then
            err -r -- 'P ' # named pipe
        elif [ -S "$1" ]; then
            err -r -- 'S ' # socket
        elif [ -t "$1" 2> /dev/null ]; then
            err -r -- 'FD ' # open file descriptor
        elif [ -e "$1" ]; then
            err -r -- '> '
        fi
        err - - "$1"

        shift
    done

    exit 234
}

#! .desc:
# EERROR: "General operation error"
#! .params:
# <"$1"+> - error
#! .rc:
# (235)
# (255) bad input
#.
EERROR() {
    args_eq 1 "$#" || return 255

    errF 235 -1 "EERROR: $1"
}

# END custom_err_functions; 230-235

#! .desc:
# Modify a file in-place according to format
# A - anywhere; E - exact; P - prefix; S - suffix
# + - add; - - remove; ~ - replace
#! .params (<2+>):
# <$1> - type(
#     '+' - {+} pre-line
#     '+0' - {E} pre-line & {+} post-line
#     '+1' - {P} pre-line & {+} post-line
#     '+2' - {S} pre-line & {+} post-line
#     '+3' - {A} pre-line & {+} post-line
#     '-0' - {E} pre-line & {-}
#     '-1' - {P} pre-line & {-}
#     '-2' - {S} pre-line & {-}
#     '-3' - {A} pre-line & {-}
#     '~0' - {E} pre-line {~} post-line
#     '~1' - {P} pre-line {~} post-line
#     '~2' - {S} pre-line {~} post-line
#     '~3' - {A} pre-line {~} post-line
#     '~~1' - {P} pre-line {~} post-line | {+} post-line
#     '~~2' - {S} pre-line {~} post-line | {+} post-line
#     '~~3' - {A} pre-line {~} post-line | {+} post-line
#     '~~~1' - {P} pre-line & match {~} post-line
#         {
#             <"$1"> - match
#         }
#     '~~~2' - {S} pre-line & match {~} post-line
#         {
#             <"$1"> - match
#         }
#     '~~~3' - {A} pre-line & match {~} post-line
#         {
#             <"$1"> - match
#         }
#     .
# )
# {["$1"] - pre-line
# ["$2"]}+ - post-line
#! .uses (<1+>):
# [FILE] $ - an already parsed file
# [FILE_PATH] $ - absolute path
#! .rc:
# (0) success
# (*) error
# (255) bad input/usage
#.
libfile() {
    args_min 2 "$#" || return 255

    if [ ! "$FILE" ]; then
        if ! __FILE_PATH_preload; then
            return 0
        fi
    fi

    line_add() {
        while IFS= read -r line; do
            i=$((i + 1))

            # In a later stage, log writing can be made an internal
            # setting, effectively increasing the number of conditional
            # checks to a total of two. This way, specific line additions
            # can be abbreviated (or not) as desired in the log file,
            # without disabling the logging of other line additions.
            if [ "$logging" = 1 ]; then
                LOG_write 1 "$i" "$line"
            fi

            printf "%s\n" "$line"
        done <<EOF
$1
EOF
    }

    line_replace() {
        # Here, $l is used to determine the current iteration of line.
        l=0; while IFS= read -r line; do
            l=$((l + 1))

            # If $l is 1, it means we are in the first iteration. For the
            # first iteration we do not increment the file line counter
            # because we are simply replacing the line. For the following
            # iterations we increment the file line counter because we are
            # adding lines.
            if [ "$l" -ne 1 ]; then
                i=$((i + 1))
            fi

            # If $l is 1, it means we are in the first iteration. For the
            # first iteration we log line replace, for the following
            # iterations we log line addition.
            if [ "$logging" = 1 ]; then
                if [ "$l" -eq 1 ]; then
                    if [ "$LINE" != "$line" ]; then
                        LOG_write 3 "$i" "$LINE" "$line"
                    fi
                else
                    LOG_write 1 "$i" "$line"
                fi
            fi

            printf "%s\n" "$line"
        done <<EOF
$1
EOF
    }

    parse_args() {
        j=0; m=0; while [ "$#" -ge 2 ]; do case "$1" in
            # + - {+} pre-line; $2
            '+')
                # The following variable helps to later compare and
                # determine which lines requsted to be added should
                # actually be added. It does this by noting the current
                # iteration of lines requsted to be added.
                j=$((j + 1))

                case "$LINE" in
                    "$2")
                        # The line requested to be added already exists.
                        # Note it in the following variable to later
                        # compare and add any missing requested lines, if
                        # any. The comma character is used as a delimiter
                        # between the numbers for easy and fail-safe number
                        # grep.
                        k="${k},${j},"

                        printf "%s\n" "$LINE"

                        return;
                    ;;
                    *)
                        shift 2
                    ;;
                esac
            ;;
            # +0 - {E} pre-line & {+} post-line; $2 & $3 respectively
            # +1 - {P} pre-line & {+} post-line; $2 & $3 respectively
            # +2 - {S} pre-line & {+} post-line; $2 & $3 respectively
            # +3 - {A} pre-line & {+} post-line; $2 & $3 respectively
            '+0'|'+1'|'+2'|'+3')
                args_min 3 "$#" || exit 255

                case "$2" in
                    *"$LF"*) exit 255 ;;
                esac

                case "$1$LINE" in
                    "+0$2" | \
                    "+1$2"* | \
                    '+2'*"$2" | \
                    '+3'*"$2"*)
                        printf "%s\n" "$LINE"

                        # Properly print $3 and increment the file line
                        # counter if $3 contains newlines, i.e. if $3 is
                        # multiple lines in one string. This function
                        # automatically writes the relevant details to the
                        # log file.
                        line_add "$3"

                        return;
                    ;;
                    *)
                        shift 3
                    ;;
                esac
            ;;
            # -0 - {E} pre-line & {-}; $2 & $LINE respectively
            # -1 - {P} pre-line & {-}; $2 & $LINE respectively
            # -2 - {S} pre-line & {-}; $2 & $LINE respectively
            # -3 - {A} pre-line & {-}; $2 & $LINE respectively
            '-0'|'-1'|'-2'|'-3')
                case "$2" in
                    *"$LF"*) exit 255 ;;
                esac

                case "$1$LINE" in
                    "-0$2" | \
                    "-1$2"* | \
                    '-2'*"$2" | \
                    '-3'*"$2"*)
                        if [ "$logging" = 1 ]; then
                            LOG_write 2 "$i" "$LINE"
                        fi

                        i=$((i - 1))

                        return;
                    ;;
                    *)
                        shift 2
                    ;;
                esac
            ;;
            # ~0 - {E} pre-line {~} post-line; $2 & $3 respectively
            # ~1 - {P} pre-line {~} post-line; $2 & $3 respectively
            # ~2 - {S} pre-line {~} post-line; $2 & $3 respectively
            # ~3 - {A} pre-line {~} post-line; $2 & $3 respectively
            '~0'|'~1'|'~2'|'~3')
                args_min 3 "$#" || exit 255

                case "$2" in
                    *"$LF"*) exit 255 ;;
                esac

                case "$1$LINE" in
                    "~0$2" | \
                    "~1$2"* | \
                    '~2'*"$2" | \
                    '~3'*"$2"*)
                        # Properly replace the line with $3 and increment
                        # the file line counter if $3 contains newlines,
                        # i.e. if $3 is multiple lines in one string. This
                        # function automatically writes the relevant
                        # details to the log file.
                        line_replace "$3"

                        return;
                    ;;
                    *)
                        shift 3
                    ;;
                esac
            ;;
            # ~~1 - {P} pre-line {~} post-line | {+} post-line; $2 & $3
            # ~~2 - {S} pre-line {~} post-line | {+} post-line; $2 & $3
            # ~~3 - {A} pre-line {~} post-line | {+} post-line; $2 & $3
            '~~1'|'~~2'|'~~3')
                args_min 3 "$#" || exit 255

                case "$2" in
                    *"$LF"*) exit 255 ;;
                esac

                m=$((m + 1))

                case "$1$LINE" in
                    "~~1$2"* | \
                    '~~2'*"$2" | \
                    '~~3'*"$2"*)
                        n="${n},${m},"

                        # Properly replace the line with $3 and increment
                        # the file line counter if $3 contains newlines,
                        # i.e. if $3 is multiple lines in one string. This
                        # function automatically writes the relevant
                        # details to the log file.
                        line_replace "$3"

                        return;
                    ;;
                    *)
                        shift 3
                    ;;
                esac
            ;;
            # ~~~1 - {P} pre-line & match {~} post-line; $3 & $2 & $4
            # ~~~2 - {S} pre-line & match {~} post-line; $3 & $2 & $4
            # ~~~3 - {A} pre-line & match {~} post-line; $3 & $2 & $4
            '~~~1'|'~~~2'|'~~~3')
                args_min 4 "$#" || exit 255

                case "$2$3" in
                    *"$LF"*) exit 255 ;;
                esac

                case "$1$LINE" in
                    "~~~1$3"* | \
                    '~~~2'*"$3" | \
                    '~~~3'*"$3"*)
                        case "$LINE" in
                            *"$2"*) : ;;
                            *) shift 4 && continue ;;
                        esac

                        # Properly replace the line with $4 and increment
                        # the file line counter if $4 contains newlines,
                        # i.e. if $4 is multiple lines in one string. This
                        # function automatically writes the relevant
                        # details to the log file.
                        line_replace "$4"

                        return;
                    ;;
                    *)
                        shift 4
                    ;;
                esac
            ;;
            *)
                exit 255
            ;;
        esac; done

        args_eq 0 "$#" || exit 255

        # Print the line as-is since no match was found.
        printf "%s\n" "$LINE"
    }

    parse_args_post() {
        j=0; m=0; while [ "$#" -ge 2 ]; do case "$1" in
            '+')
                j=$((j + 1))

                case "$k" in
                    *",${j},"*)
                        : # line already added
                    ;;
                    *)
                        # Properly print $2 and increment the file line counter
                        # if $2 contains newlines, i.e. if $2 is multiple lines
                        # in one string. This function automatically writes the
                        # relevant details to the log file.
                        line_add "$2"
                    ;;
                esac

                shift 2
            ;;
            '~~1'|'~~2'|'~~3')
                args_min 3 "$#" || exit 255

                case "$2" in
                    *"$LF"*) exit 255 ;;
                esac

                m=$((m + 1))

                case "$n" in
                    *",${m},"*)
                        : # line already replaced
                    ;;
                    *)
                        # Properly print $3 and increment the file line counter
                        # if $3 contains newlines, i.e. if $3 is multiple lines
                        # in one string. This function automatically writes the
                        # relevant details to the log file.
                        line_add "$3"
                    ;;
                esac

                shift 3
            ;;
            '-0'|'-1'|'-2'|'-3')
                shift 2
            ;;
            '+0'|'+1'|'+2'|'+3'|'~0'|'~1'|'~2'|'~3')
                shift 3
            ;;
            '~~~1'|'~~~2'|'~~~3')
                shift 4
            ;;
            *)
                exit 255
            ;;
        esac; done

        args_eq 0 "$#" || exit 255
    }

    FILE=$(
        # It is almost always preferred that any lines added by us are placed
        # distinguishably, i.e. they are separated by our newline. This has the
        # added benefit of standardizing the process of line addition as the
        # count of trailing newlines in the original file, be it zero or more
        # than one, will not matter. This could be made configurable at a later
        # stage.
        case "${FILE#"${FILE%??}"}" in
            "$LF$LF") : ;;
            *"$LF") FILE="$FILE$LF" ;;
            *) FILE="$FILE$LF$LF" ;;
        esac

        i=0; printf "%s" "$FILE" | { while IFS= read -r LINE; do
            i=$((i + 1)); parse_args "$@"
        done

        # Add lines remaining to be added, if any.
        parse_args_post "$@"; }
    )

    # Add a newline, as the command substitution removed all trailing ones.
    FILE="$FILE$LF"
}

#! .desc:
# Clear the log file ($tmpf)
#! .uses:
# <tmpf> $ - the absolute path of the log file
#! .rc:
# (0) success
# (*) error
# (255) bad call
#.
LOG_clear() {
    if [ "$fatal" = 1 ]; then
        file "$tmpf" || return 255
        writable "$tmpf" || return 255
    else
        file "$tmpf" || return 0
        writable "$tmpf" || return 0
    fi

    { : > "$tmpf"; } 2> /dev/null
}

#! .desc:
# Print the log file ($tmpf)
#! .uses:
# <tmpf> $ - the absolute path of the log file
#! .rc:
# (0) success
# (*) error
# (255) bad call
#.
LOG_print() {
    if [ "$fatal" = 1 ]; then
        file "$tmpf" || return 255
        readable "$tmpf" || return 255
    else
        file "$tmpf" || return 0
        readable "$tmpf" || return 0
    fi

    ( . "$tmpf"; ) 2> /dev/null
}

#! .desc:
# Write to the log file ($tmpf)
#! .params:
# <$1> - type(
#     '0' - raw string
#         {
#             <"$1"> - string
#         }
#     '1' - file in-place string addition
#         {
#             <$1> - line number
#             <"$2"> - string
#         }
#     '2' - file in-place string removal
#         {
#             <$1> - line number
#             <"$2"> - string
#         }
#     '3' - file in-place string change
#         {
#             <$1> - line number
#             <"$2"> - string from
#             <"$3"> - string to
#         }
#     .
# )
#! .uses:
# <tmpf> $ - the absolute path of the log file
#! .rc:
# (0) success
# (*) error
# (255) bad call | bad input
#.
LOG_write() {
    args_min 2 "$#" || return 255

    if [ "$1" = 1 ] || [ "$1" = 2 ]; then
        args_eq 3 "$#" || return 255

        # Check if $2 is a natural number
        case "$2:${2#*[!0123456789]}" in
            : | 0*) return 255 ;;
            "$2:$2") : ;;
            *) return 255 ;;
        esac
    elif [ "$1" = 3 ]; then
        args_eq 4 "$#" || return 255

        # Check if $2 is a natural number
        case "$2:${2#*[!0123456789]}" in
            : | 0*) return 255 ;;
            "$2:$2") : ;;
            *) return 255 ;;
        esac
    fi

    if [ "$fatal" = 1 ]; then
        file "$tmpf" || return 255
        writable "$tmpf" || return 255
    else
        file "$tmpf" || return 0
        writable "$tmpf" || return 0
    fi

    case $1 in
        0)
            replchars "'" "'\\''" "$2"; set -- "$_str"

            printf "'printf' %s %s\n" \
                   "'%s\n'" \
                   "'$1'" \
                   >> "$tmpf"
        ;;
        1)
            replchars "'" "'\\''" "$3"; set -- "$2" "$_str"

            printf "'printf' %s %s %s\n" \
                   "'%b%s%b%s\n'" \
                   "'\033[1;32m' '${1}+ ' '\033[0m'" \
                   "'$2'" \
                   >> "$tmpf"
        ;;
        2)
            replchars "'" "'\\''" "$3"; set -- "$2" "$_str"

            printf "'printf' %s %s %s\n" \
                   "'%b%s%b%s\n'" \
                   "'\033[1;31m' '${1}- ' '\033[0m'" \
                   "'$2'" \
                   >> "$tmpf"
        ;;
        3)
            replchars "'" "'\\''" "$3"; set -- "$2" "$_str" "$4"
            replchars "'" "'\\''" "$3"; set -- "$1" "$2" "$_str"

            {
                printf "'printf' %s %s %s\n" \
                       "'%b%s%b%s\n'" \
                       "'\033[1;31m' '${1}- ' '\033[0m'" \
                       "'$2'"
                printf "'printf' %s %s %s\n" \
                       "'%b%s%b%s\n'" \
                       "'\033[1;32m' '${1}+ ' '\033[0m'" \
                       "'$3'"
            } >> "$tmpf"
        ;;
    esac
}

#! .desc:
# Check if the log file ($tmpf) contains stuff
#! .uses:
# <tmpf> $ - the absolute path of the log file
#! .rc:
# (0) yes
# (1) no
#.
LOG_written() {
    [ -s "$tmpf" ]
}

#! .desc:
# Read STDIN into $FILE
#! .gives:
# (0) <"$FILE"> - the content of STDIN
#! .rc:
# (0) success
# (*) error
#.
FILE() {
    { while IFS= read -r _line; do
        FILE="$FILE$_line
"
    done; FILE="$FILE$_line"; } 2> /dev/null
}

#! .desc:
# Read a file into $FILE
#! .params:
# <"$1"> - absolute path
#! .gives:
# (0) <"$FILE"> - the content of the file
#! .rc:
# (0) success
# (*) error
# (255) bad input
#.
FILE_preload() {
    args_eq 1 "$#" || return 255

    file "$1" || return 255
    readable "$1" || return 255

    FILE=$(
        while IFS= read -r _line; do
            printf "%s\n" "$_line"
        done < "$1"; printf "%s" "$_line"

        printf "%s" ' '
    ) 2> /dev/null; FILE="${FILE%?}"
}

#! .desc:
# Read STDIN into $FILE_PATH
#! .gives:
# (0) <"$FILE_PATH"> - the content of STDIN
#! .rc:
# (0) success
# (*) error
#.
FILE_PATH() {
    FILE=; FILE_PATH=; FILE_PATH_TARGET=

    { while IFS= read -r _line; do
        FILE_PATH="$FILE_PATH$_line
"
    done; FILE_PATH="${FILE_PATH%?}$_line"; } 2> /dev/null
}

#! .desc:
# Read STDIN into $FILE_PATH_TARGET
#! .gives:
# (0) <"$FILE_PATH_TARGET"> - the content of STDIN
#! .rc:
# (0) success
# (*) error
#.
FILE_PATH_TARGET() {
    FILE_PATH_TARGET=

    { while IFS= read -r _line; do
        FILE_PATH_TARGET="$FILE_PATH_TARGET$_line
"
    done; FILE_PATH_TARGET="${FILE_PATH_TARGET%?}$_line"; } 2> /dev/null
}

#! .desc:
# Check if a file matches a given octal sequence
#! .params:
# <"$1"> - absolute path
# <"$2"> - octal sequence
#! .rc:
# (0) yes
# (1) no
# (255) bad input
#.
bin_equiv() {
    args_eq 2 "$#" || return 255

    file "$1" || return 255

    {
        set -- "$(od -to1 -An "$1")" "$2" && \
        set -- "${1%"${1##*[0123456789]}"}" "${2%"${2##*[0123456789]}"}" && \
        set -- "${1#"${1%%[0123456789]*}"}" "${2#"${2%%[0123456789]*}"}"
    } 2> /dev/null || return 255

    [ "$1" = "$2" ]
}

#! .desc:
# Copy a given directory at a path
#! .params:
# <"$1"> - absolute path of the directory
# <"$2"> - absolute path to copy the directory at
#! .rc:
# (0) success
# (*) error
# (255) bad input
#.
dir_write() {
    args_eq 2 "$#" || return 255

    dir "$1" || return 255

    if exist "$2"; then
        chattr_remove "$2"
        unmount "$2"

        rm -rf "$2" 2> /dev/null
    fi

    mkdir_parents "$2"

    cp -R "$1" "$2" 2> /dev/null
}

#! .desc:
# Copy a given file at a path
#! .params:
# <"$1"> - absolute path of the file
# <"$2"> - absolute path to copy the file at
#! .rc:
# (0) success
# (*) error
# (255) bad input
#.
file_copy() {
    args_eq 2 "$#" || return 255

    file "$1" || return 255

    if exist "$2"; then
        chattr_remove "$2"
        unmount "$2"

        rm -rf "$2" 2> /dev/null
    fi

    mkdir_parents "$2"

    cp "$1" "$2" 2> /dev/null
}

#! .desc:
# Check if a file matches a given string
#! .params:
# <"$1"> - absolute path
# <"$2"> - string
#! .rc:
# (0) yes
# (1) no
# (*) error
# (255) bad input
#.
file_equiv() {
    args_eq 2 "$#" || return 255

    file "$1" || return 255

    {
        _file= && while IFS= read -r _line; do
            _file="$_file$_line
"
        done < "$1"; _file="$_file$_line"
    } 2> /dev/null

    [ "$_file" = "$2" ]
}

#! .desc:
# Write a given string at a path
#! .params:
# <"$1"> - absolute path
# <"$2"> - string
#! .rc:
# (0) success
# (*) error
# (255) bad input
#.
file_write() {
    args_eq 2 "$#" || return 255

    if exist "$1"; then
        chattr_remove "$1"
        unmount "$1"

        rm -rf "$1" 2> /dev/null
    fi

    mkdir_parents "$1"

    { printf "%s" "$2" > "$1"; } 2> /dev/null
}

#! .desc:
# Write a given octal sequence at a path
#! .params:
# <"$1"> - absolute path
# <"$2"> - octal sequence
#! .rc:
# (0) success
# (*) error
# (255) bad input
#.
file_write_octal() {
    args_eq 2 "$#" || return 255

    if exist "$1"; then
        chattr_remove "$1"
        unmount "$1"

        rm -rf "$1" 2> /dev/null
    fi

    set -- "$1" "${2%"${2##*[0123456789]}"}"
    set -- "$1" "${2#"${2%%[0123456789]*}"}"

    mkdir_parents "$1"
    { octal_decode "$2" > "$1"; } || { rm -f "$1"; return 1; }
}

#! .desc:
# Check if a file matches a given file
#! .params:
# <"$1"> - absolute path
# <"$2"> - absolute path
#! .rc:
# (0) yes
# (1) no
# (*) error
# (255) bad input
#.
files_equiv() {
    args_eq 2 "$#" || return 255

    file "$1" || return 255
    file "$2" || return 255
    readable "$1" || return 255
    readable "$2" || return 255

    cmp -s "$1" "$2" 2> /dev/null
}

#! .desc:
# Create a backup (copy) of a file/directory
#! .params:
# <"$1"> - absolute path
#! .rc:
# (0) success
# (*) error
# (255) bad input
#.
loc_backup() {
    args_eq 1 "$#" || return 255

    exist "$1" || return 0

    if dir "$1"; then
        :
    elif file "$1"; then
        :
    else
        return 0
    fi

    [ ! -h "$1" ] || return 0

    if [ "$force" = 1 ]; then
        # Intentionally ignore errors here; if chattr was used on some of the
        # files, it probably is very intentional. Make it act as a feature to
        # protect backups so that the code logic remains simple.
        rm -rf "$1".bak* 2> /dev/null || :
    fi

    _i=1; _j=00; while [ "$_i" -lt 1000 ]; do
        case $_i in
            10|100) _j="${_j%?}" ;;
        esac

        _i="$_j$_i"
        if exist "$1".bak"$_i"; then
            _i="${_i#"$_j"}"
            _i=$((_i + 1))
            continue
        fi

        if dir "$1"; then
            cp -R "$1" "$1".bak"$_i" 2> /dev/null || break

            if [ "$logging" = 1 ]; then
                info -w - 'loc_backup(): Backup from/to:'
                info -r -- 'D '; info - - "$1"
                info -g -- 'D '; info - - "$1".bak"$_i"
            fi
        else
            cp "$1" "$1".bak"$_i" 2> /dev/null || break

            if [ "$logging" = 1 ]; then
                info -w - 'loc_backup(): Backup from/to:'
                info -r -- 'F '; info - - "$1"
                info -g -- 'F '; info - - "$1".bak"$_i"
            fi
        fi

        return 0
    done

    if [ "$logging" = 1 ]; then
        if [ "$_i" -eq 1000 ]; then
            info -y - 'loc_backup(): Failed; too many .bak files.'
        else
            info -y - 'loc_backup(): Backup failed:'
        fi
        if dir "$1"; then info -w -- 'D '; else info -w -- 'F '; fi
        info - - "$1"
    fi
    return 1
}

#! .desc:
# Permanently delete a file/directory
#! .params:
# <"$1"> - absolute path
#! .rc:
# (0) success
# (*) error
# (255) bad $1
#.
loc_delete() {
    args_eq 1 "$#" || return 255

    exist "$1" || return 0

    chattr_remove "$1"
    unmount "$1"

    rm -rf "$1" 2> /dev/null
}

#! .desc:
# Create a symbolic link of an object
#! .params:
# <"$1"> - absolute path of the object
# <"$2"> - absolute path to create the link at
#! .rc:
# (0) success
# (*) error
# (255) bad input
#.
loc_link() {
    args_eq 2 "$#" || return 255

    { [ -e "$1" ] || [ -h "$1" ]; } || return 255

    if exist "$2"; then
        chattr_remove "$2"
        unmount "$2"
    fi

    mkdir_parents "$2"

    ln -sf "$1" "$2" 2> /dev/null
}

#! .desc:
# Create a hard link of a file
#! .params:
# <"$1"> - absolute path of the file
# <"$2"> - absolute path to create the link at
#! .rc:
# (0) success
# (*) error
# (255) bad input
#.
loc_link_ptr() {
    args_eq 2 "$#" || return 255

    if file "$1"; then
        :
    else
        return 255
    fi

    if exist "$2"; then
        chattr_remove "$2"
        unmount "$2"
    fi

    mkdir_parents "$2"

    ln -f "$1" "$2" 2> /dev/null
}

#! .desc:
# Set $user as owner of an object and its parents in $home
#! .params:
# <"$1"> - absolute path
#! .uses:
# [user] $ - the user name
# [home] $ - the user directory
#! .rc:
# (0) success
# (*) error
# (255) bad input
#.
loc_own_user() {
    args_eq 1 "$#" || return 255

    set -- "${1%"${1##*[!/]}"}"

    exist "$1" && str_pfix "$home"/ "$1" || return 0

    chattr_remove "$1"

    if dir "$1"; then
        chown -RP -- "$user":"$user" "$1"
    else
        chown -P -- "$user":"$user" "$1"
    fi

    set -- "${1%/*}"
    set -- "${1%"${1##*[!/]}"}"
    until [ "$1" = "$home" ]; do
        chown -P -- "$user":"$user" "$1"

        set -- "${1%/*}"
        set -- "${1%"${1##*[!/]}"}"
    done
}

#! .desc:
# Write a binary file at the specified path
#! .uses:
# <FILE> $ - the octal sequence of the file
# <FILE_PATH> $ - the path to write the file at
#! .rc:
# (0) success
# (*) error
# (255) bad usage
#.
__bin_write() {
    if [ ! "$FILE_PATH" ]; then
        err -r -1 'Missing FILE_PATH.'
        return 255
    fi

    if [ ! "$FILE" ]; then
        info -w -1 'Empty FILE. Write cancelled:'
        info -w -- 'F '; info - - "$FILE_PATH"
        return 0
    fi

    if ! is_octal "$FILE"; then
        err -r -1 'Bad FILE; expected octal.'
        return 255
    fi

    while :; do
        if [ "$avoid_write" = 1 ]; then
            if bin_equiv "$FILE_PATH" "$FILE"; then
                info -w -1 'Write avoided:'
                info -g -- 'F '; info - - "$FILE_PATH"
                break
            fi
        fi

        if [ "$force" = 1 ]; then
            if [ "$backup" = 1 ]; then
                loc_backup "$FILE_PATH"
            fi

            loc_delete "$FILE_PATH"
        fi

        if exist "$FILE_PATH"; then
            EEXIST "$FILE_PATH"
        fi

        if [ "$force" = 0 ]; then
            if [ "$backup" = 1 ]; then
                loc_backup "$FILE_PATH"
            fi
        fi

        if [ "$logging" = 1 ]; then
            info -w -1 'Will write:'
            info -w -- 'F '; info - - "$FILE_PATH"

            (
                IFS="$LF"' '
                CC=0; for _octal in $FILE; do CC=$((CC + 1)); done
                info -w -- 'CC: '; info - - "$CC"
                info -w -- 'SIZE: '; bytes_size "$CC"
            )
        fi

        if ! file_write_octal "$FILE_PATH" "$FILE"; then
            err -r -1 'Write error:'
            err -r -- 'F '; err - - "$FILE_PATH"
            exit 201
        fi
    break; done

    if ! loc_own_user "$FILE_PATH"; then
        EPERMS "$FILE_PATH"
    fi
}

#! .desc:
# Write a binary file at the specified path (overwrite path)
#! .uses:
# <FILE> $ - the octal sequence of the file
# <FILE_PATH> $ - the path to write the file at
#! .rc:
# (0) success
# (*) error
# (255) bad usage
#.
__bin_write_overwrite() {
    if [ ! "$FILE_PATH" ]; then
        err -r -1 'Missing FILE_PATH.'
        return 255
    fi

    if [ ! "$FILE" ]; then
        info -w -1 'Empty FILE. Write cancelled:'
        info -w -- 'F '; info - - "$FILE_PATH"
        return 0
    fi

    if ! is_octal "$FILE"; then
        err -r -1 'Bad FILE; expected octal.'
        return 255
    fi

    while :; do
        if [ "$avoid_write" = 1 ]; then
            if bin_equiv "$FILE_PATH" "$FILE"; then
                info -w -1 'Write avoided:'
                info -g -- 'F '; info - - "$FILE_PATH"
                break
            fi
        fi

        if [ "$backup" = 1 ]; then
            loc_backup "$FILE_PATH"
        fi

        if [ "$logging" = 1 ]; then
            info -w -1 'Will write:'
            info -w -- 'F '; info - - "$FILE_PATH"

            (
                IFS="$LF"' '
                CC=0; for _octal in $FILE; do CC=$((CC + 1)); done
                info -w -- 'CC: '; info - - "$CC"
                info -w -- 'SIZE: '; bytes_size "$CC"
            )
        fi

        if ! file_write_octal "$FILE_PATH" "$FILE"; then
            err -r -1 'Write error:'
            err -r -- 'F '; err - - "$FILE_PATH"
            exit 201
        fi
    break; done

    if ! loc_own_user "$FILE_PATH"; then
        EPERMS "$FILE_PATH"
    fi
}

#! .desc:
# Copy a directory at the specified path
#! .uses:
# <FILE_PATH> $ - the directory
# <FILE_PATH_TARGET> $ - the path to write the directory at
#! .rc:
# (0) success
# (*) error
# (255) bad usage
#.
__dir_target_write() {
    if [ ! "$FILE_PATH" ]; then
        err -r -1 'Missing FILE_PATH.'
        return 255
    fi

    if [ ! "$FILE_PATH_TARGET" ]; then
        err -r -1 'Missing FILE_PATH_TARGET.'
        return 255
    fi

    if ! exist "$FILE_PATH"; then
        ENOENT;
        err -r -- 'D '; err - - "$FILE_PATH"
        exit 202
    fi

    dir "$FILE_PATH" || ENOTDIR "$FILE_PATH"

    readable "$FILE_PATH" || EREAD "$FILE_PATH"

    while :; do
        if [ "$force" = 1 ]; then
            if [ "$backup" = 1 ]; then
                loc_backup "$FILE_PATH_TARGET"
            fi

            loc_delete "$FILE_PATH_TARGET"
        fi

        if exist "$FILE_PATH_TARGET"; then
            EEXIST "$FILE_PATH_TARGET"
        fi

        if [ "$force" = 0 ]; then
            if [ "$backup" = 1 ]; then
                loc_backup "$FILE_PATH_TARGET"
            fi
        fi

        if [ "$logging" = 1 ]; then
            info -w -1 'Will copy from/to:'
            info -w -- 'D '; info - - "$FILE_PATH"
            info -w -- 'D '; info - - "$FILE_PATH_TARGET"

            info -w -- '> '
            find "$FILE_PATH"//. ! -name . | grep -c // 2> /dev/null | \
                while IFS= read -r _line0; do
                    printf "%s, " "$_line0"

                    info -w -- 'D '
                    find "$FILE_PATH"//. ! -name . -type d | \
                        grep -c // 2> /dev/null | \
                            while IFS= read -r _line1; do
                                printf "%s, " "$_line1"

                                info -w -- 'F '
                                info - - "$((_line0 - _line1))"
                            done
                done
        fi

        if ! dir_write "$FILE_PATH" "$FILE_PATH_TARGET"; then
            err -r -1 'Write error:'
            err -r -- 'D '; err - - "$FILE_PATH_TARGET"
            exit 201
        fi
    break; done

    if ! loc_own_user "$FILE_PATH_TARGET"; then
        EPERMS "$FILE_PATH_TARGET"
    fi
}

#! .desc:
# Copy a directory at the specified path (overwrite path)
#! .uses:
# <FILE_PATH> $ - the directory
# <FILE_PATH_TARGET> $ - the path to write the directory at
#! .rc:
# (0) success
# (*) error
# (255) bad usage
#.
__dir_target_write_overwrite() {
    if [ ! "$FILE_PATH" ]; then
        err -r -1 'Missing FILE_PATH.'
        return 255
    fi

    if [ ! "$FILE_PATH_TARGET" ]; then
        err -r -1 'Missing FILE_PATH_TARGET.'
        return 255
    fi

    if ! exist "$FILE_PATH"; then
        ENOENT;
        err -r -- 'D '; err - - "$FILE_PATH"
        exit 202
    fi

    dir "$FILE_PATH" || ENOTDIR "$FILE_PATH"

    readable "$FILE_PATH" || EREAD "$FILE_PATH"

    while :; do
        if [ "$backup" = 1 ]; then
            loc_backup "$FILE_PATH_TARGET"
        fi

        if [ "$logging" = 1 ]; then
            info -w -1 'Will copy from/to:'
            info -w -- 'D '; info - - "$FILE_PATH"
            info -w -- 'D '; info - - "$FILE_PATH_TARGET"

            info -w -- '> '
            find "$FILE_PATH"//. ! -name . | grep -c // 2> /dev/null | \
                while IFS= read -r _line0; do
                    printf "%s, " "$_line0"

                    info -w -- 'D '
                    find "$FILE_PATH"//. ! -name . -type d | \
                        grep -c // 2> /dev/null | \
                            while IFS= read -r _line1; do
                                printf "%s, " "$_line1"

                                info -w -- 'F '
                                info - - "$((_line0 - _line1))"
                            done
                done
        fi

        if ! dir_write "$FILE_PATH" "$FILE_PATH_TARGET"; then
            err -r -1 'Write error:'
            err -r -- 'D '; err - - "$FILE_PATH_TARGET"
            exit 201
        fi
    break; done

    if ! loc_own_user "$FILE_PATH_TARGET"; then
        EPERMS "$FILE_PATH_TARGET"
    fi
}

#! .desc:
# Preload FILE_PATH into FILE
#! .uses:
# <FILE> $
# <FILE_PATH> $ - the file to preload
#! .rc:
# (0) success
# (*) error
# (255) bad usage
#.
__FILE_PATH_preload() {
    if [ ! "$FILE_PATH" ]; then
        err -r -1 'Missing FILE_PATH.'
        return 255
    fi

    if ! exist "$FILE_PATH"; then
        ENOENT;
        err -r -- 'F '; err - - "$FILE_PATH"
        exit 202
    fi

    FILE_preload "$FILE_PATH" || EREAD "$FILE_PATH"
}

#! .desc:
# Set the executable bits on a file
#! .uses:
# <FILE_PATH> $ - the file
#! .rc:
# (0) success
# (*) error
# (255) bad usage
#.
__file_executable() {
    if [ ! "$FILE_PATH" ]; then
        err -r -1 'Missing FILE_PATH.'
        return 255
    fi

    if ! exist "$FILE_PATH"; then
        ENOENT;
        err -r -- 'F '; err - - "$FILE_PATH"
        exit 202
    fi

    file "$FILE_PATH" || ENOTFILE "$FILE_PATH"

    if [ "$logging" = 1 ]; then
        if ! chmod +x "$FILE_PATH"; then
            EPERMS "$FILE_PATH"
        fi
    else
        if ! chmod +x "$FILE_PATH" > /dev/null 2>&1; then
            EPERMS "$FILE_PATH"
        fi
    fi
}

#! .desc:
# Write a file at the specified path
#! .uses:
# <FILE> $ - the file
# <FILE_PATH> $ - the path to write the file at
#! .rc:
# (0) success
# (*) error
# (255) bad usage
#.
__file_write() {
    if [ ! "$FILE_PATH" ]; then
        err -r -1 'Missing FILE_PATH.'
        return 255
    fi

    if [ ! "$FILE" ]; then
        info -w -1 'Empty FILE. Write cancelled:'
        info -w -- 'F '; info - - "$FILE_PATH"
        return 0
    fi

    while :; do
        if [ "$avoid_write" = 1 ]; then
            if file_equiv "$FILE_PATH" "$FILE"; then
                info -w -1 'Write avoided:'
                info -g -- 'F '; info - - "$FILE_PATH"
                break
            fi
        fi

        if [ "$force" = 1 ]; then
            if [ "$backup" = 1 ]; then
                loc_backup "$FILE_PATH"
            fi

            loc_delete "$FILE_PATH"
        fi

        if exist "$FILE_PATH"; then
            EEXIST "$FILE_PATH"
        fi

        if [ "$force" = 0 ]; then
            if [ "$backup" = 1 ]; then
                loc_backup "$FILE_PATH"
            fi
        fi

        if [ "$logging" = 1 ]; then
            if LOG_written; then
                info -w -1 'Changes:'
                info -w -- 'F '; info - - "$FILE_PATH"
                LOG_print;
            else
                info -w -1 'Will write:'
                info -w -- 'F '; info - - "$FILE_PATH"
                info -w - '0:'; info - -- "$FILE"
            fi
        fi

        if ! file_write "$FILE_PATH" "$FILE"; then
            err -r -1 'Write error:'
            err -r -- 'F '; err - - "$FILE_PATH"
            exit 201
        fi
    break; done

    if ! loc_own_user "$FILE_PATH"; then
        EPERMS "$FILE_PATH"
    fi

    if ! LOG_clear; then
        err -r -1 'Log clear error.'
        exit 201
    fi
}

#! .desc:
# Write a file at the specified path (overwrite path)
#! .uses:
# <FILE> $ - the file
# <FILE_PATH> $ - the path to write the file at
#! .rc:
# (0) success
# (*) error
# (255) bad usage
#.
__file_write_overwrite() {
    if [ ! "$FILE_PATH" ]; then
        err -r -1 'Missing FILE_PATH.'
        return 255
    fi

    if [ ! "$FILE" ]; then
        info -w -1 'Empty FILE. Write cancelled:'
        info -w -- 'F '; info - - "$FILE_PATH"
        return 0
    fi

    while :; do
        if [ "$avoid_write" = 1 ]; then
            if file_equiv "$FILE_PATH" "$FILE"; then
                info -w -1 'Write avoided:'
                info -g -- 'F '; info - - "$FILE_PATH"
                break
            fi
        fi

        if [ "$backup" = 1 ]; then
            loc_backup "$FILE_PATH"
        fi

        if [ "$logging" = 1 ]; then
            if LOG_written; then
                info -w -1 'Changes:'
                info -w -- 'F '; info - - "$FILE_PATH"
                LOG_print;
            else
                info -w -1 'Will write:'
                info -w -- 'F '; info - - "$FILE_PATH"
                info -w - '0:'; info - -- "$FILE"
            fi
        fi

        if ! file_write "$FILE_PATH" "$FILE"; then
            err -r -1 'Write error:'
            err -r -- 'F '; err - - "$FILE_PATH"
            exit 201
        fi
    break; done

    if ! loc_own_user "$FILE_PATH"; then
        EPERMS "$FILE_PATH"
    fi

    if ! LOG_clear; then
        err -r -1 'Log clear error.'
        exit 201
    fi
}

#! .desc:
# Copy a file at the specified path
#! .uses:
# <FILE_PATH> $ - the directory
# <FILE_PATH_TARGET> $ - the path to write the directory at
#! .rc:
# (0) success
# (*) error
# (255) bad usage
#.
__file_target_write() {
    if [ ! "$FILE_PATH" ]; then
        err -r -1 'Missing FILE_PATH.'
        return 255
    fi

    if [ ! "$FILE_PATH_TARGET" ]; then
        err -r -1 'Missing FILE_PATH_TARGET.'
        return 255
    fi

    if ! exist "$FILE_PATH"; then
        ENOENT;
        err -r -- 'F '; err - - "$FILE_PATH"
        exit 202
    fi

    file "$FILE_PATH" || ENOTFILE "$FILE_PATH"

    readable "$FILE_PATH" || EREAD "$FILE_PATH"

    while :; do
        if [ "$avoid_write" = 1 ]; then
            if files_equiv "$FILE_PATH" "$FILE_PATH_TARGET"; then
                if [ -h "$FILE_PATH_TARGET" ]; then
                    info -w -1 'Write avoided:'
                    info -g -- 'L '; info - - "$FILE_PATH_TARGET"
                    break
                else
                    info -w -1 'Write avoided:'
                    info -g -- 'F '; info - - "$FILE_PATH_TARGET"
                    break
                fi
            fi
        fi

        if [ "$force" = 1 ]; then
            if [ "$backup" = 1 ]; then
                loc_backup "$FILE_PATH_TARGET"
            fi

            loc_delete "$FILE_PATH_TARGET"
        fi

        if exist "$FILE_PATH_TARGET"; then
            EEXIST "$FILE_PATH_TARGET"
        fi

        if [ "$force" = 0 ]; then
            if [ "$backup" = 1 ]; then
                loc_backup "$FILE_PATH_TARGET"
            fi
        fi

        if [ "$logging" = 1 ]; then
            info -w -1 'Will copy from/to:'
            info -w -- 'F '; info - - "$FILE_PATH"
            info -w -- 'F '; info - - "$FILE_PATH_TARGET"
        fi

        if ! file_copy "$FILE_PATH" "$FILE_PATH_TARGET"; then
            err -r -1 'Write error:'
            err -r -- 'F '; err - - "$FILE_PATH_TARGET"
            exit 201
        fi
    break; done

    if ! loc_own_user "$FILE_PATH_TARGET"; then
        EPERMS "$FILE_PATH_TARGET"
    fi
}

#! .desc:
# Copy a file at the specified path (overwrite path)
#! .uses:
# <FILE_PATH> $ - the directory
# <FILE_PATH_TARGET> $ - the path to write the directory at
#! .rc:
# (0) success
# (*) error
# (255) bad usage
#.
__file_target_write_overwrite() {
    if [ ! "$FILE_PATH" ]; then
        err -r -1 'Missing FILE_PATH.'
        return 255
    fi

    if [ ! "$FILE_PATH_TARGET" ]; then
        err -r -1 'Missing FILE_PATH_TARGET.'
        return 255
    fi

    if ! exist "$FILE_PATH"; then
        ENOENT;
        err -r -- 'F '; err - - "$FILE_PATH"
        exit 202
    fi

    file "$FILE_PATH" || ENOTFILE "$FILE_PATH"

    readable "$FILE_PATH" || EREAD "$FILE_PATH"

    while :; do
        if [ "$avoid_write" = 1 ]; then
            if files_equiv "$FILE_PATH" "$FILE_PATH_TARGET"; then
                if [ -h "$FILE_PATH_TARGET" ]; then
                    info -w -1 'Write avoided:'
                    info -g -- 'L '; info - - "$FILE_PATH_TARGET"
                    break
                else
                    info -w -1 'Write avoided:'
                    info -g -- 'F '; info - - "$FILE_PATH_TARGET"
                    break
                fi
            fi
        fi

        if [ "$backup" = 1 ]; then
            loc_backup "$FILE_PATH_TARGET"
        fi

        if [ "$logging" = 1 ]; then
            info -w -1 'Will copy from/to:'
            info -w -- 'F '; info - - "$FILE_PATH"
            info -w -- 'F '; info - - "$FILE_PATH_TARGET"
        fi

        if ! file_copy "$FILE_PATH" "$FILE_PATH_TARGET"; then
            err -r -1 'Write error:'
            err -r -- 'F '; err - - "$FILE_PATH_TARGET"
            exit 201
        fi
    break; done

    if ! loc_own_user "$FILE_PATH_TARGET"; then
        EPERMS "$FILE_PATH_TARGET"
    fi
}

#! .desc:
# Set filesystem flags on a file/directory
#! .params:
# <$1> - flag(s) to set
#! .uses:
# <FILE_PATH> $ - the file/directory
#! .rc:
# (0) success
# (*) error
# (255) bad input/usage
#.
__loc_chattr() {
    args_eq 1 "$#" || return 255

    cmd 'chattr' || return 0

    if [ ! "$FILE_PATH" ]; then
        err -r -1 'Missing FILE_PATH.'
        return 255
    fi

    if ! exist "$FILE_PATH"; then
        ENOENT;
        err -r -- 'F/D '; err - - "$FILE_PATH"
        exit 202
    fi

    if dir "$FILE_PATH"; then
        :
    elif file "$FILE_PATH"; then
        :
    else
        EINVAL;
        if [ -b "$FILE_PATH" ]; then
            err -r -- 'B ' # block file
        elif [ -c "$FILE_PATH" ]; then
            err -r -- 'C ' # character file
        elif [ -h "$FILE_PATH" ]; then
            err -r -- 'L ' # symbolic link
        elif [ -p "$FILE_PATH" ]; then
            err -r -- 'P ' # named pipe
        elif [ -S "$FILE_PATH" ]; then
            err -r -- 'S ' # socket
        elif [ -t "$FILE_PATH" 2> /dev/null ]; then
            err -r -- 'FD ' # open file descriptor
        elif [ -e "$FILE_PATH" ]; then
            err -r -- '> '
        fi
        err - - "$FILE_PATH"
        exit 222
    fi

    if [ "$logging" = 1 ]; then
        if ! chattr +"$1" "$FILE_PATH"; then
            EFSFLAG "$FILE_PATH"
        fi
    else
        if ! chattr +"$1" "$FILE_PATH" > /dev/null 2>&1; then
            EFSFLAG "$FILE_PATH"
        fi
    fi
}

#! .desc:
# Set permissions on a file/directory
#! .params:
# <$1> - octal mode
#! .uses:
# <FILE_PATH> $ - the file/directory
#! .rc:
# (0) success
# (*) error
# (255) bad input/usage
#.
__loc_chmod() {
    args_eq 1 "$#" || return 255

    if [ ! "$FILE_PATH" ]; then
        err -r -1 'Missing FILE_PATH.'
        return 255
    fi

    if ! exist "$FILE_PATH"; then
        ENOENT;
        err -r -- 'F/D '; err - - "$FILE_PATH"
        exit 202
    fi

    if dir "$FILE_PATH"; then
        :
    elif file "$FILE_PATH"; then
        :
    else
        EINVAL;
        if [ -b "$FILE_PATH" ]; then
            err -r -- 'B ' # block file
        elif [ -c "$FILE_PATH" ]; then
            err -r -- 'C ' # character file
        elif [ -h "$FILE_PATH" ]; then
            err -r -- 'L ' # symbolic link
        elif [ -p "$FILE_PATH" ]; then
            err -r -- 'P ' # named pipe
        elif [ -S "$FILE_PATH" ]; then
            err -r -- 'S ' # socket
        elif [ -t "$FILE_PATH" 2> /dev/null ]; then
            err -r -- 'FD ' # open file descriptor
        elif [ -e "$FILE_PATH" ]; then
            err -r -- '> '
        fi
        err - - "$FILE_PATH"
        exit 222
    fi

    chattr_remove "$FILE_PATH"

    if [ "$logging" = 1 ]; then
        if ! chmod "$1" "$FILE_PATH"; then
            EPERMS "$FILE_PATH"
        fi
    else
        if ! chmod "$1" "$FILE_PATH" > /dev/null 2>&1; then
            EPERMS "$FILE_PATH"
        fi
    fi
}

#! .desc:
# Set owner of a file/directory
#! .params:
# <$1> - owner
#! .uses:
# <FILE_PATH> $ - the file/directory
#! .rc:
# (0) success
# (*) error
# (255) bad input/usage
#.
__loc_chown() {
    args_eq 1 "$#" || return 255

    if [ ! "$FILE_PATH" ]; then
        err -r -1 'Missing FILE_PATH.'
        return 255
    fi

    if ! exist "$FILE_PATH"; then
        ENOENT;
        err -r -- 'F/D '; err - - "$FILE_PATH"
        exit 202
    fi

    if dir "$FILE_PATH"; then
        :
    elif file "$FILE_PATH"; then
        :
    else
        EINVAL;
        if [ -b "$FILE_PATH" ]; then
            err -r -- 'B ' # block file
        elif [ -c "$FILE_PATH" ]; then
            err -r -- 'C ' # character file
        elif [ -h "$FILE_PATH" ]; then
            err -r -- 'L ' # symbolic link
        elif [ -p "$FILE_PATH" ]; then
            err -r -- 'P ' # named pipe
        elif [ -S "$FILE_PATH" ]; then
            err -r -- 'S ' # socket
        elif [ -t "$FILE_PATH" 2> /dev/null ]; then
            err -r -- 'FD ' # open file descriptor
        elif [ -e "$FILE_PATH" ]; then
            err -r -- '> '
        fi
        err - - "$FILE_PATH"
        exit 222
    fi

    chattr_remove "$FILE_PATH"

    if [ "$logging" = 1 ]; then
        if [ "$(id -gn "$user")" = "$user" ]; then
            if ! chown -R "$user":"$user" "$FILE_PATH"; then
                EPERMS "$FILE_PATH"
            fi
        else
            if ! chown -R "$user" "$FILE_PATH"; then
                EPERMS "$FILE_PATH"
            fi
        fi
    else
        if [ "$(id -gn "$user")" = "$user" ]; then
            if ! chown -R "$user":"$user" "$FILE_PATH" > /dev/null 2>&1; then
                EPERMS "$FILE_PATH"
            fi
        else
            if ! chown -R "$user" "$FILE_PATH" > /dev/null 2>&1; then
                EPERMS "$FILE_PATH"
            fi
        fi
    fi
}

#! .desc:
# Delete a file/directory from the specified path
#! .uses:
# <FILE_PATH> $ - the file/directory
#! .rc:
# (0) success
# (*) error
# (255) bad usage
#.
__loc_delete() {
    if [ ! "$FILE_PATH" ]; then
        err -r -1 'Missing FILE_PATH.'
        return 255
    fi

    if ! exist "$FILE_PATH"; then
        info -w -1 'Already deleted:'
        info -g -- '> '; info - - "$FILE_PATH"
        return 0
    fi

    if [ "$backup" = 1 ]; then
        if dir "$FILE_PATH" || file "$FILE_PATH"; then
            loc_backup "$FILE_PATH"
        fi
    fi

    if [ "$logging" = 1 ]; then
        info -w -1 'Will delete:'
        if [ -b "$FILE_PATH" ]; then
            info -w -- 'B ' # block file
        elif [ -c "$FILE_PATH" ]; then
            info -w -- 'C ' # character file
        elif [ -d "$FILE_PATH" ]; then
            info -w -- 'D ' # directory
        elif [ -f "$FILE_PATH" ]; then
            info -w -- 'F ' # regular file
        elif [ -h "$FILE_PATH" ]; then
            info -w -- 'L ' # symbolic link
        elif [ -p "$FILE_PATH" ]; then
            info -w -- 'P ' # named pipe
        elif [ -S "$FILE_PATH" ]; then
            info -w -- 'S ' # socket
        elif [ -t "$FILE_PATH" 2> /dev/null ]; then
            info -w -- 'FD ' # open file descriptor
        else
            info -w -- '> '
        fi
        info - - "$FILE_PATH"

        if ! loc_delete "$FILE_PATH"; then
            err -r -1 'Removal error:'
            err -r -- '> '; err - - "$FILE_PATH"
            exit 201
        fi
    else
        loc_delete "$FILE_PATH" > /dev/null 2>&1
    fi
}

#! .desc:
# Truncate/empty a file/directory on the specified path
#! .uses:
# <FILE_PATH> $ - the file/directory
#! .rc:
# (0) success
# (*) error
# (255) bad usage
#.
__loc_empty() {
    if [ ! "$FILE_PATH" ]; then
        err -r -1 'Missing FILE_PATH.'
        return 255
    fi

    if dir "$FILE_PATH"; then
        :
    elif file "$FILE_PATH"; then
        :
    elif exist "$FILE_PATH"; then
        EINVAL;
        if [ -b "$FILE_PATH" ]; then
            err -r -- 'B ' # block file
        elif [ -c "$FILE_PATH" ]; then
            err -r -- 'C ' # character file
        elif [ -h "$FILE_PATH" ]; then
            err -r -- 'L ' # symbolic link
        elif [ -p "$FILE_PATH" ]; then
            err -r -- 'P ' # named pipe
        elif [ -S "$FILE_PATH" ]; then
            err -r -- 'S ' # socket
        elif [ -t "$FILE_PATH" 2> /dev/null ]; then
            err -r -- 'FD ' # open file descriptor
        fi
        err - - "$FILE_PATH"
        exit 222
    fi

    if [ "$backup" = 1 ]; then
        loc_backup "$FILE_PATH"
    fi

    if dir "$FILE_PATH"; then
        if [ "$logging" = 1 ]; then
            info -w -1 'Will empty:'
            info -w -- 'D '; info - - "$FILE_PATH"

            if ! rm -rf "$FILE_PATH"/*; then
                errF 235 - 'rm: Failed.'
            fi
        else
            if ! rm -rf "$FILE_PATH"/* > /dev/null 2>&1; then
                errF 235 - 'rm: Failed.'
            fi
        fi
    else
        if [ "$logging" = 1 ]; then
            if exist "$FILE_PATH"; then
                info -w -1 'Will truncate:'
            else
                info -w -1 'Will create:'
            fi
            info -w -- 'F '; info - - "$FILE_PATH"

            if ! { : > "$FILE_PATH"; }; then
                if exist "$FILE_PATH"; then
                    err -r -1 'Truncation error:'
                else
                    err -r -1 'Creation error:'
                fi
                err -r -- 'F '; err - - "$FILE_PATH"
                exit 201
            fi
        else
            if ! { : > "$FILE_PATH"; } > /dev/null 2>&1; then
                if exist "$FILE_PATH"; then
                    err -r -1 'Truncation error:'
                else
                    err -r -1 'Creation error:'
                fi
                err -r -- 'F '; err - - "$FILE_PATH"
                exit 201
            fi
        fi
    fi
}

#! .desc:
# Create a symbolic link of an object at the specified path (overwrite)
#! .uses:
# <FILE_PATH> $ - the object
# <FILE_PATH_TARGET> $ - the path to write the symbolic link at
#! .rc:
# (0) success
# (*) error
# (255) bad usage
#.
__loc_target_link_overwrite() {
    if [ ! "$FILE_PATH" ]; then
        err -r -1 'Missing FILE_PATH.'
        return 255
    fi

    if [ ! "$FILE_PATH_TARGET" ]; then
        err -r -1 'Missing FILE_PATH_TARGET.'
        return 255
    fi

    if ! { exist "$FILE_PATH" || [ -h "$FILE_PATH" ]; }; then
        ENOENT;
        err -r -- 'F '; err - - "$FILE_PATH"
        exit 202
    fi

    while :; do
        if [ "$backup" = 1 ]; then
            loc_backup "$FILE_PATH_TARGET"
        fi

        if [ "$logging" = 1 ]; then
            info -w -1 'Will symbolic link source/target:'
            info -w -- '? '; info - - "$FILE_PATH"
            info -w -- 'L '; info - - "$FILE_PATH_TARGET"
        fi

        if ! loc_link "$FILE_PATH" "$FILE_PATH_TARGET"; then
            err -r -1 'Write error:'
            err -r -- 'L '; err - - "$FILE_PATH_TARGET"
            exit 201
        fi
    break; done

    if ! loc_own_user "$FILE_PATH_TARGET"; then
        EPERMS "$FILE_PATH_TARGET"
    fi
}

#! .desc:
# Clone a git repository to $tmpd
#! .params:
# <"$1"> - URL
#! .rc:
# (0) success
# (*) error
# (255) bad input
#.
__git_get() {
    args_eq 1 "$#" || return 255

    info -w -1 '__git_get():'
    info -w -- 'U '; info - - "$1"

    set -- "$@" '--depth' '1'

    if str '/' "$1"; then
        set -- "$@" "$tmpd/${1#"${1%/*}"?}"
    else
        set -- "$@" "$tmpd/$1"
    fi

    if ! git clone "$@"; then
        err -r -1 '__git_get(): Clone error:'
        err -r -- 'U '; err - - "$1"
        exit 201
    fi
}

# $m533ia assertion:
#
# Use laptop's sound card ALC256 instead of HDMI by default
# Fixes: no sound in some applications/games.
#
# [m533ia]$ aplay -l:
# card 0: Generic [HD-Audio Generic], device 3: HDMI 0 [HDMI 0]
#   Subdevices: 1/1
#   Subdevice #0: subdevice #0
# card 1: Generic_1 [HD-Audio Generic], device 0: ALC256 Analog [ALC256 Analog]
#   Subdevices: 1/1
#   Subdevice #0: subdevice #0
_alsa_conf() {
    FILE_PATH \
<<'ASOUND_CONF'
/etc/asound.conf
ASOUND_CONF

    if [ "$audio_hq" = 1 ]; then
        FILE \
<<'ASOUND_CONF'
defaults.pcm.rate_converter "speexrate_best"
ASOUND_CONF
    else
        FILE \
<<'ASOUND_CONF'
defaults.pcm.rate_converter "speexrate_medium"
ASOUND_CONF
    fi

    if [ "$m533ia" = 1 ]; then
        FILE \
<<'ASOUND_CONF'
defaults.pcm.card 1
defaults.ctl.card 1
ASOUND_CONF
    fi

    __file_write;
}

# "WantedBy", default.target, ensures systemd will try to start the service on
# boot. Since no other services on the system specifies our, moc.service, we
# essentially tell systemd that default.target "wants us" using WantedBy;
# default.target is equal to runlevel 5 in sysvinit if it is an alias for
# graphical.target, otherwise 3-5 if multi-user.target.
# Symlink is created because the service will not be started if there isn't a
# symlink under a directory with name composed of the WantedBy string +
# '.wants' appended. \_()_/
#
# Sources:
# https://unix.stackexchange.com/a/506374/431300
#
# Hard dependency mark in systemd:
# Requires=<service>
#
# Hard dependency mark + runtime mark in systemd:
# Requires=<service>
# After=<service>
#
# Soft dependency mark in systemd:
# Wants=<service>
#
# Soft dependency mark + runtime mark in systemd:
# Wants=<service>
# After=<service>
#
# In respect to dependencies, `WantedBy=` string will still be respected
# in all cases.
#
# An alternative to systemd shall be considered.
_autostart() {
    if [ "$init" = systemd ]; then
        if [ "$bluetooth" = 1 ]; then
            FILE_PATH \
<<'BLUETOOTH_SERVICE'
/etc/systemd/system/bluetooth.service
BLUETOOTH_SERVICE

            FILE \
<<'BLUETOOTH_SERVICE'
[Unit]
Description=Bluetooth service
Requires=dbus.service
After=dbus.service

[Service]
Type=dbus
BusName=org.bluez
ExecStart=/usr/lib/bluetooth/bluetoothd
TimeoutStopSec=3

[Install]
WantedBy=multi-user.target
BLUETOOTH_SERVICE

            __file_write;

            FILE_PATH \
<<'BLUETOOTH_SERVICE'
/etc/systemd/system/bluetooth.service
BLUETOOTH_SERVICE

            FILE_PATH_TARGET \
<<'BLUETOOTH_SERVICE'
/etc/systemd/system/multi-user.target.wants/bluetooth.service
BLUETOOTH_SERVICE

            __loc_target_link_overwrite;
        fi

        if [ "$dns" = localhost ]; then
            if [ "$dns0" = dnsmasq ]; then
                FILE_PATH \
<<'DNSMASQ_SERVICE'
/etc/systemd/system/dnsmasq.service
DNSMASQ_SERVICE

                FILE \
<<'DNSMASQ_SERVICE'
[Unit]
Description=Caching DNS server
Wants=dbus.service

[Service]
Type=simple
ExecStart=/usr/bin/dnsmasq -k --user=dnsmasq
TimeoutStopSec=3

[Install]
WantedBy=multi-user.target
DNSMASQ_SERVICE

                __file_write;

                FILE_PATH \
<<'DNSMASQ_SERVICE'
/etc/systemd/system/dnsmasq.service
DNSMASQ_SERVICE

                FILE_PATH_TARGET \
<<'DNSMASQ_SERVICE'
/etc/systemd/system/multi-user.target.wants/dnsmasq.service
DNSMASQ_SERVICE

                __loc_target_link_overwrite;
            fi
        fi

        if [ "$m533ia" = 1 ]; then
            FILE_PATH \
<<'EVTEST_GRAB_SERVICE'
/etc/systemd/system/evtest-grab.service
EVTEST_GRAB_SERVICE

            FILE \
<<'EVTEST_GRAB_SERVICE'
[Unit]
Description=Grab m533ia keyboard at startup

[Service]
Type=simple
ExecStart=/bin/bash -c '\
device="$(/usr/bin/awk '\''\
/AT Translated Set 2 keyboard/ { found=1; next } \
found && /Handlers=/ { \
  for (i=1; i<=NF; i++) \
    if ($i ~ /^event[0-9]+$/) { \
      print "/dev/input/" $i; exit \
    } \
}'\'' /proc/bus/input/devices)"; \
exec /usr/bin/evtest --grab "$device"'
User=root
StandardOutput=null

[Install]
WantedBy=multi-user.target
EVTEST_GRAB_SERVICE

            __file_write;

            FILE_PATH \
<<'EVTEST_GRAB_SERVICE'
/etc/systemd/system/evtest-grab.service
EVTEST_GRAB_SERVICE

            FILE_PATH_TARGET \
<<'EVTEST_GRAB_SERVICE'
/etc/systemd/system/multi-user.target.wants/evtest-grab.service
EVTEST_GRAB_SERVICE

            __loc_target_link_overwrite;
        fi

        FILE_PATH \
<<'IWD_SERVICE'
/etc/systemd/system/iwd.service
IWD_SERVICE

        FILE \
<<'IWD_SERVICE'
[Unit]
Description=Wireless service

[Service]
ExecStart=/usr/lib/iwd/iwd

[Install]
WantedBy=multi-user.target
IWD_SERVICE

        __file_write;

        FILE_PATH \
<<'IWD_SERVICE'
/etc/systemd/system/iwd.service
IWD_SERVICE

        FILE_PATH_TARGET \
<<'IWD_SERVICE'
/etc/systemd/system/multi-user.target.wants/iwd.service
IWD_SERVICE

        __loc_target_link_overwrite;

        FILE_PATH \
<<MOC_SERVICE
$home/.config/systemd/user/moc.service
MOC_SERVICE

        FILE \
<<'MOC_SERVICE'
[Unit]
Description=MOC server

[Service]
RemainAfterExit=yes
ExecStart=/usr/bin/mocp -S
ExecStop=/usr/bin/mocp -x
TimeoutStopSec=3

[Install]
WantedBy=default.target
MOC_SERVICE

        __file_write;

        FILE_PATH \
<<MOC_SERVICE
$home/.config/systemd/user/moc.service
MOC_SERVICE

        FILE_PATH_TARGET \
<<MOC_SERVICE
$home/.config/systemd/user/default.target.wants/moc.service
MOC_SERVICE

        __loc_target_link_overwrite;

        if [ "$arch_linux" = 1 ]; then
            FILE_PATH \
<<'NULL'
/dev/null
NULL

            FILE_PATH_TARGET \
<<'RTKIT_DAEMON_SERVICE'
/etc/systemd/system/rtkit-daemon.service
RTKIT_DAEMON_SERVICE

            __loc_target_link_overwrite;

            FILE_PATH \
<<'NULL'
/dev/null
NULL

            FILE_PATH_TARGET \
<<AT_SPI_DBUS_BUS_SERVICE
$home/.config/systemd/user/at-spi-dbus-bus.service
AT_SPI_DBUS_BUS_SERVICE

            __loc_target_link_overwrite;
        fi
    fi
}

_bash_conf() {
    FILE_PATH \
<<_BASH_FUNCTIONS
$home/.bash_functions
_BASH_FUNCTIONS

    FILE \
<<'_BASH_FUNCTIONS'
# System management
sys_pwr_fw() { pwr_fw; }
sys_pwr_off() { pwr_off "$@"; }
sys_pwr_reset() { pwr_reset "$@"; }
sys_pkg_get() { pkg_get "$@"; }
sys_pkg_rm() { pkg_rm "$@"; }
sys_pkg_rmF() { pkg_rmF "$@"; }
sys_pkg_pip_get() { pkg_pip_get "$@"; }
sys_pkg_pip_get_req() { pkg_pip_get_req "$@"; }
sys_pkg_pip_rm() { pkg_pip_rm "$@"; }
sys_up() { up; }
sys_upF() { upF; }
sys_xfce_quit() { xfce_quit; }

# Package management
pkg_get() (
    case ":$1" in
        :)
            printf "%bERROR:%b No package(s) specified.\n" \
                   "\033[1;31m" "\033[0m"
            exit 2
        ;;
    esac

    ARGS='--sync'

    while [ "$1" ]; do
        ARGS="$ARGS"" \"$1\""
        shift
    done

    eval "su -c 'pacman ${ARGS}'"
)
pkg_rm() (
    case ":$1" in
        :)
            printf "%bERROR:%b No package(s) specified.\n" \
                   "\033[1;31m" "\033[0m"
            exit 2
        ;;
    esac

    ARGS='--remove'
    ARGS="$ARGS"' --nosave'
    ARGS="$ARGS"' --recursive'

    while [ "$1" ]; do
        ARGS="$ARGS"" \"$1\""
        shift
    done

    eval "su -c 'pacman ${ARGS}'"
)
pkg_rmF() (
    case ":$1" in
        :)
            printf "%bERROR:%b No package(s) specified.\n" \
                   "\033[1;31m" "\033[0m"
            exit 2
        ;;
    esac

    ARGS='--remove'
    ARGS="$ARGS"' --nosave'
    ARGS="$ARGS"' --recursive'
    ARGS="$ARGS"' -dd'

    while [ "$1" ]; do
        ARGS="$ARGS"" \"$1\""
        shift
    done

    eval "su -c 'pacman ${ARGS}'"
)
pkg_pip_get() (
    case ":$1" in
        :)
            printf "%bERROR:%b No package(s) specified.\n" \
                   "\033[1;31m" "\033[0m"
            exit 2
        ;;
    esac

    ARGS='-m pip'
    ARGS="$ARGS"' install'
    ARGS="$ARGS"' --user'
    ARGS="$ARGS"' --break-system-packages'

    while [ "$1" ]; do
        ARGS="$ARGS"" \"$1\""
        shift
    done

    eval "python ${ARGS}"
)
pkg_pip_get_req() (
    case ":$1" in
        :)
            printf "%bERROR:%b No file(s) specified.\n" \
                   "\033[1;31m" "\033[0m"
            exit 2
        ;;
    esac

    ARGS='-m pip'
    ARGS="$ARGS"' install'
    ARGS="$ARGS"' --user'
    ARGS="$ARGS"' --break-system-packages'

    while [ "$1" ]; do
        ARGS="$ARGS"" --requirement \"$1\""
        shift
    done

    eval "python ${ARGS}"
)
pkg_pip_rm() (
    case ":$1" in
        :)
            printf "%bERROR:%b No package(s) specified.\n" \
                   "\033[1;31m" "\033[0m"
            exit 2
        ;;
    esac

    ARGS='-m pip'
    ARGS="$ARGS"' uninstall'
    ARGS="$ARGS"' --yes'

    while [ "$1" ]; do
        ARGS="$ARGS"" \"$1\""
        shift
    done

    eval "python ${ARGS}"
)

# Power management
pwr_fw() (
    su -c 'systemctl reboot --firmware-setup'
)
pwr_off() (
    case ":$1" in
        :) su -c 'shutdown -P now' ;;
        *) su -c "shutdown -P $1" ;;
    esac
)
pwr_reset() (
    case ":$1" in
        :) su -c 'shutdown -r now' ;;
        *) su -c "shutdown -r $1" ;;
    esac
)

# Update management
up() (
    ARGS='--sync'
    ARGS="$ARGS"' --refresh'
    ARGS="$ARGS"' --sysupgrade'

    eval "su -c 'pacman ${ARGS}'"
)
upF() (
    ARGS='--sync'
    ARGS="$ARGS"' -yyuu'

    eval "su -c 'pacman ${ARGS}'"
)

# Xfce management
xfce_quit() (
    ARGS='--fast'
    ARGS="$ARGS"' --logout'

    eval "xfce4-session-logout ${ARGS}"
)

# Other management
ramfs_c() (
    su -c "
        [ ! -e /mnt/ramdisk ] || {
            echo 'fail: /mnt/ramdisk already exists'; exit 0
        }
        mkdir /mnt/ramdisk 2> /dev/null
        mount -t ramfs ramfs /mnt/ramdisk && \
        chown $USER:$USER /mnt/ramdisk && \
        chmod 700 /mnt/ramdisk
    "
)
ramfs_d() (
    su -c "
        [ -e /mnt/ramdisk ] || {
            echo 'fail: /mnt/ramdisk does not exist'; exit 0
        }
        umount /mnt/ramdisk && \
        rm -rf /mnt/ramdisk
    "
)

# ffmpeg
ffmpeg_a_get_from() (
    { # Variables expected to be present: OUT, FILENAME.
        handle_err() {
            trap - EXIT
            [ -d "$TMP_DIR" ] && rm -rf "$TMP_DIR"
            [ -d "$DIR" ] && cd "$DIR"
            exit $1
        }; handle_exit() {
            case $1 in
                0) : ;;
                *) handle_err $1 ;;
            esac
            case ":$OUT" in
                :) set -- * ;;
                *) set -- "$OUT" ;;
            esac
            case ":$FILENAME" in
                :)
                    mv "$TMP_DIR"/"$1" "$DIR"/"$1"
                    printf "%bFILE:%b %b%s%b\n" \
                           "\033[1;32m" "\033[0m" "\033[1;37m" \
                           "$DIR/$1" "\033[0m"
                ;;
                *)
                    mv "$TMP_DIR"/"$1" "$DIR"/"${FILENAME}${1#"${1%.*}"}"
                    printf "%bFILE:%b %b%s%b\n" \
                           "\033[1;32m" "\033[0m" "\033[1;37m" \
                           "$DIR/${FILENAME}${1#"${1%.*}"}" "\033[0m"
                ;;
            esac
            [ -d "$TMP_DIR" ] && rm -rf "$TMP_DIR"
            [ -d "$DIR" ] && cd "$DIR"
        }; work() {
            DIR="$PWD"; TMP_DIR="$HOME"/.b81y7yt73627iyqguo9v3ryrand0mstr1ng
            [ -d "$TMP_DIR" ] && rm -rf "$TMP_DIR"
            mkdir "$TMP_DIR"; cd "$TMP_DIR"
        }
        trap "handle_err \$?" INT TERM
        trap "handle_exit \$?" EXIT
        set -e
        work;
    } # Provided variables: DIR; TMP_DIR.

    case ":$1" in
        :)
            printf "%bERROR:%b No time specified.\n" \
                   "\033[1;31m" "\033[0m"
            exit 2
        ;;
    esac
    case ":$2" in
        :)
            printf "%bERROR:%b No file specified.\n" \
                   "\033[1;31m" "\033[0m"
            exit 2
        ;;
    esac

    FROM="$1"
    [ -f "$2" ] && IN="$2" || IN="$DIR/$2"

    if [ ! -f "$IN" ]; then
        printf "%bERROR:%b No file found.\n" \
               "\033[1;31m" "\033[0m"
        exit 2
    fi

    OUT=$(
        printf "%s" "${IN##*/}"
    )

    ARGS="-i \"$IN\" -ss $FROM"
    ARGS="$ARGS"' -c:a copy'
    ARGS="$ARGS"" \"$OUT\""

    eval "ffmpeg ${ARGS}"
)
ffmpeg_a_get_to() (
    { # Variables expected to be present: OUT, FILENAME.
        handle_err() {
            trap - EXIT
            [ -d "$TMP_DIR" ] && rm -rf "$TMP_DIR"
            [ -d "$DIR" ] && cd "$DIR"
            exit $1
        }; handle_exit() {
            case $1 in
                0) : ;;
                *) handle_err $1 ;;
            esac
            case ":$OUT" in
                :) set -- * ;;
                *) set -- "$OUT" ;;
            esac
            case ":$FILENAME" in
                :)
                    mv "$TMP_DIR"/"$1" "$DIR"/"$1"
                    printf "%bFILE:%b %b%s%b\n" \
                           "\033[1;32m" "\033[0m" "\033[1;37m" \
                           "$DIR/$1" "\033[0m"
                ;;
                *)
                    mv "$TMP_DIR"/"$1" "$DIR"/"${FILENAME}${1#"${1%.*}"}"
                    printf "%bFILE:%b %b%s%b\n" \
                           "\033[1;32m" "\033[0m" "\033[1;37m" \
                           "$DIR/${FILENAME}${1#"${1%.*}"}" "\033[0m"
                ;;
            esac
            [ -d "$TMP_DIR" ] && rm -rf "$TMP_DIR"
            [ -d "$DIR" ] && cd "$DIR"
        }; work() {
            DIR="$PWD"; TMP_DIR="$HOME"/.b81y7yt73627iyqguo9v3ryrand0mstr1ng
            [ -d "$TMP_DIR" ] && rm -rf "$TMP_DIR"
            mkdir "$TMP_DIR"; cd "$TMP_DIR"
        }
        trap "handle_err \$?" INT TERM
        trap "handle_exit \$?" EXIT
        set -e
        work;
    } # Provided variables: DIR; TMP_DIR.

    case ":$1" in
        :)
            printf "%bERROR:%b No time specified.\n" \
                   "\033[1;31m" "\033[0m"
            exit 2
        ;;
    esac
    case ":$2" in
        :)
            printf "%bERROR:%b No file specified.\n" \
                   "\033[1;31m" "\033[0m"
            exit 2
        ;;
    esac

    TO="$1"
    [ -f "$2" ] && IN="$2" || IN="$DIR/$2"

    if [ ! -f "$IN" ]; then
        printf "%bERROR:%b No file found.\n" \
               "\033[1;31m" "\033[0m"
        exit 2
    fi

    OUT=$(
        printf "%s" "${IN##*/}"
    )

    ARGS="-t $TO"
    ARGS="$ARGS"" -i \"$IN\""
    ARGS="$ARGS"' -c:a copy'
    ARGS="$ARGS"" \"$OUT\""

    eval "ffmpeg ${ARGS}"
)
ffmpeg_a_get_fromto() (
    { # Variables expected to be present: OUT, FILENAME.
        handle_err() {
            trap - EXIT
            [ -d "$TMP_DIR" ] && rm -rf "$TMP_DIR"
            [ -d "$DIR" ] && cd "$DIR"
            exit $1
        }; handle_exit() {
            case $1 in
                0) : ;;
                *) handle_err $1 ;;
            esac
            case ":$OUT" in
                :) set -- * ;;
                *) set -- "$OUT" ;;
            esac
            case ":$FILENAME" in
                :)
                    mv "$TMP_DIR"/"$1" "$DIR"/"$1"
                    printf "%bFILE:%b %b%s%b\n" \
                           "\033[1;32m" "\033[0m" "\033[1;37m" \
                           "$DIR/$1" "\033[0m"
                ;;
                *)
                    mv "$TMP_DIR"/"$1" "$DIR"/"${FILENAME}${1#"${1%.*}"}"
                    printf "%bFILE:%b %b%s%b\n" \
                           "\033[1;32m" "\033[0m" "\033[1;37m" \
                           "$DIR/${FILENAME}${1#"${1%.*}"}" "\033[0m"
                ;;
            esac
            [ -d "$TMP_DIR" ] && rm -rf "$TMP_DIR"
            [ -d "$DIR" ] && cd "$DIR"
        }; work() {
            DIR="$PWD"; TMP_DIR="$HOME"/.b81y7yt73627iyqguo9v3ryrand0mstr1ng
            [ -d "$TMP_DIR" ] && rm -rf "$TMP_DIR"
            mkdir "$TMP_DIR"; cd "$TMP_DIR"
        }
        trap "handle_err \$?" INT TERM
        trap "handle_exit \$?" EXIT
        set -e
        work;
    } # Provided variables: DIR; TMP_DIR.

    case ":$1" in
        :)
            printf "%bERROR:%b No FROM time specified.\n" \
                   "\033[1;31m" "\033[0m"
            exit 2
        ;;
    esac
    case ":$2" in
        :)
            printf "%bERROR:%b No TO time specified.\n" \
                   "\033[1;31m" "\033[0m"
            exit 2
        ;;
    esac
    case ":$3" in
        :)
            printf "%bERROR:%b No file specified.\n" \
                   "\033[1;31m" "\033[0m"
            exit 2
        ;;
    esac

    FROM="$1"
    TO="$2"
    [ -f "$3" ] && IN="$3" || IN="$DIR/$3"
    

    if [ ! -f "$IN" ]; then
        printf "%bERROR:%b No file found.\n" \
               "\033[1;31m" "\033[0m"
        exit 2
    fi

    OUT=$(
        printf "%s" "${IN##*/}"
    )

    ARGS="-ss $FROM"
    ARGS="$ARGS"" -t $TO"
    ARGS="$ARGS"" -i \"$IN\""
    ARGS="$ARGS"' -c:a copy'
    ARGS="$ARGS"" \"$OUT\""

    eval "ffmpeg ${ARGS}"
)
ffmpeg_merge() (
    { # Variables expected to be present: OUT, FILENAME.
        handle_err() {
            trap - EXIT
            [ -d "$TMP_DIR" ] && rm -rf "$TMP_DIR"
            [ -d "$DIR" ] && cd "$DIR"
            exit $1
        }; handle_exit() {
            case $1 in
                0) : ;;
                *) handle_err $1 ;;
            esac
            case ":$OUT" in
                :) set -- * ;;
                *) set -- "$OUT" ;;
            esac
            case ":$FILENAME" in
                :)
                    mv "$TMP_DIR"/"$1" "$DIR"/"$1"
                    printf "%bFILE:%b %b%s%b\n" \
                           "\033[1;32m" "\033[0m" "\033[1;37m" \
                           "$DIR/$1" "\033[0m"
                ;;
                *)
                    mv "$TMP_DIR"/"$1" "$DIR"/"${FILENAME}${1#"${1%.*}"}"
                    printf "%bFILE:%b %b%s%b\n" \
                           "\033[1;32m" "\033[0m" "\033[1;37m" \
                           "$DIR/${FILENAME}${1#"${1%.*}"}" "\033[0m"
                ;;
            esac
            [ -d "$TMP_DIR" ] && rm -rf "$TMP_DIR"
            [ -d "$DIR" ] && cd "$DIR"
        }; work() {
            DIR="$PWD"; TMP_DIR="$HOME"/.b81y7yt73627iyqguo9v3ryrand0mstr1ng
            [ -d "$TMP_DIR" ] && rm -rf "$TMP_DIR"
            mkdir "$TMP_DIR"; cd "$TMP_DIR"
        }
        trap "handle_err \$?" INT TERM
        trap "handle_exit \$?" EXIT
        set -e
        work;
    } # Provided variables: DIR; TMP_DIR.

    case ":$1" in
        :)
            printf "%bERROR:%b No audio file specified.\n" \
                   "\033[1;31m" "\033[0m"
            exit 2
        ;;
    esac
    case ":$2" in
        :)
            printf "%bERROR:%b No video file specified.\n" \
                   "\033[1;31m" "\033[0m"
            exit 2
        ;;
    esac
    case ":$3" in
        :)
            printf "%bERROR:%b No output name specified.\n" \
                   "\033[1;31m" "\033[0m"
            exit 2
        ;;
    esac

    AUDIO_IN="$DIR/$1"
    VIDEO_IN="$DIR/$2"

    OUT="$3"

    ARGS="-i \"$VIDEO_IN\""
    ARGS="$ARGS"" -i \"$AUDIO_IN\""
    ARGS="$ARGS"' -c:v copy -c:a copy -map 0:v:0 -map 1:a:0'
    ARGS="$ARGS"" \"$OUT\""

    eval "ffmpeg ${ARGS}"
)
ffmpeg_merge_mp4() (
    { # Variables expected to be present: OUT, FILENAME.
        handle_err() {
            trap - EXIT
            [ -d "$TMP_DIR" ] && rm -rf "$TMP_DIR"
            [ -d "$DIR" ] && cd "$DIR"
            exit $1
        }; handle_exit() {
            case $1 in
                0) : ;;
                *) handle_err $1 ;;
            esac
            case ":$OUT" in
                :) set -- * ;;
                *) set -- "$OUT" ;;
            esac
            case ":$FILENAME" in
                :)
                    mv "$TMP_DIR"/"$1" "$DIR"/"$1"
                    printf "%bFILE:%b %b%s%b\n" \
                           "\033[1;32m" "\033[0m" "\033[1;37m" \
                           "$DIR/$1" "\033[0m"
                ;;
                *)
                    mv "$TMP_DIR"/"$1" "$DIR"/"${FILENAME}${1#"${1%.*}"}"
                    printf "%bFILE:%b %b%s%b\n" \
                           "\033[1;32m" "\033[0m" "\033[1;37m" \
                           "$DIR/${FILENAME}${1#"${1%.*}"}" "\033[0m"
                ;;
            esac
            [ -d "$TMP_DIR" ] && rm -rf "$TMP_DIR"
            [ -d "$DIR" ] && cd "$DIR"
        }; work() {
            DIR="$PWD"; TMP_DIR="$HOME"/.b81y7yt73627iyqguo9v3ryrand0mstr1ng
            [ -d "$TMP_DIR" ] && rm -rf "$TMP_DIR"
            mkdir "$TMP_DIR"; cd "$TMP_DIR"
        }
        trap "handle_err \$?" INT TERM
        trap "handle_exit \$?" EXIT
        set -e
        work;
    } # Provided variables: DIR; TMP_DIR.

    case ":$1" in
        :)
            printf "%bERROR:%b No audio file specified.\n" \
                   "\033[1;31m" "\033[0m"
            exit 2
        ;;
    esac
    case ":$2" in
        :)
            printf "%bERROR:%b No video file specified.\n" \
                   "\033[1;31m" "\033[0m"
            exit 2
        ;;
    esac

    AUDIO_IN="$DIR/$1"
    VIDEO_IN="$DIR/$2"

    if [ "$3" ]; then
        case "$OUT" in
            *'.mp4') OUT="$3" ;;
            *) OUT="${3}.mp4" ;;
        esac
    else
        case "$2" in
            *'.mp4') OUT="$2" ;;
            *) OUT="${2}.mp4" ;;
        esac
    fi

    ARGS="-i \"$VIDEO_IN\""
    ARGS="$ARGS"" -i \"$AUDIO_IN\""
    ARGS="$ARGS"' -c:v copy -c:a copy -map 0:v:0 -map 1:a:0'
    ARGS="$ARGS"" \"$OUT\""

    eval "ffmpeg ${ARGS}"
)

# gpg
gpg_d() {
    gpg -o "${1%.gpg}" -d "$1"
}
gpg_e() {
    gpg -r 7D1F56FAD6FB86652A60BEE65BC3343816EAB179 --compress-algo none -e "$1"
}

# steam
:

# tar
tar_c() {
    tar --numeric-owner -cvpf "$1".tar "$1"
}
tar_e() {
    if [ ! -e "$1" ] && [ -e "$1".tar ]; then
        set -- "$1".tar
    fi

    tar --numeric-owner -xvpf "$1"
}

# youtube-dl
:

# yt-dlp
#
# Audio:
# --format 338 - opus/aac[?] ambisonic audio, contained in webm/mp4(m4a)[?]
# --format 258 - 384 kbps 5.1 aac, contained in mp4(m4a)
# --format 327 - 256 kbps 5.1 aac, contained in mp4(m4a)
# --format 141 - 256 kbps aac, contained in mp4(m4a); premium accounts only
# --format 256 - 192 kbps 5.1 aac, contained in mp4(m4a)
# --format 251 - normal opus, contained in webm
# --format 140 - 128 kbps aac, contained in mp4(m4a)
# --format 22  - {128|192} kbps aac premuxed 720p mp4
#
# Video:
# --format ::: - 4320p60 HDR vp9(.2), contained in webm
# --format ::: - 4320p60 HDR av1, contained in mp4
# --format ::: - 4320p30 HDR vp9(.2), contained in webm
# --format ::: - 4320p30 HDR av1, contained in webm
# --format ::: - 4320p60 vp9, contained in webm
# --format ::: - 4320p60 av1, contained in mp4
# --format ::: - 4320p30 vp9, contained in webm
# --format ::: - 4320p30 av1, contained in webm

# --format ::: - 2160p60 HDR vp9(.2), contained in webm
# --format ::: - 2160p60 HDR av1, contained in mp4
# --format ::: - 2160p30 HDR vp9(.2), contained in webm
# --format ::: - 2160p30 HDR av1, contained in webm
# --format ::: - 2160p60 vp9, contained in webm
# --format ::: - 2160p60 av1, contained in mp4
# --format ::: - 2160p30 vp9, contained in webm
# --format ::: - 2160p30 av1, contained in webm

# --format ::: - 1440p60 HDR vp9(.2), contained in webm
# --format ::: - 1440p60 HDR av1, contained in mp4
# --format ::: - 1440p30 HDR vp9(.2), contained in webm
# --format ::: - 1440p30 HDR av1, contained in webm
# --format ::: - 1440p60 vp9, contained in webm
# --format ::: - 1440p60 av1, contained in mp4
# --format ::: - 1440p30 vp9, contained in webm
# --format ::: - 1440p30 av1, contained in webm

# --format ::: - 1080p60 HDR vp9(.2), contained in webm
# --format ::: - 1080p60 HDR av1, contained in mp4
# --format ::: - 1080p30 HDR vp9(.2), contained in webm
# --format ::: - 1080p30 HDR av1, contained in webm
# --format ::: - 1080p60 vp9, contained in webm
# --format ::: - 1080p60 av1, contained in mp4
# --format ::: - 1080p60 avc1, contained in mp4
# --format ::: - 1080p30 vp9, contained in webm
# --format ::: - 1080p30 av1, contained in webm
# --format ::: - 1080p30 avc1, contained in mp4

# --format ::: - 720p60 HDR vp9(.2), contained in webm
# --format ::: - 720p60 HDR av1, contained in mp4
# --format ::: - 720p30 HDR vp9(.2), contained in webm
# --format ::: - 720p30 HDR av1, contained in webm
# --format ::: - 720p60 vp9, contained in webm
# --format ::: - 720p60 av1, contained in mp4
# --format ::: - 720p60 avc1, contained in mp4
# --format ::: - 720p30 vp9, contained in webm
# --format ::: - 720p30 av1, contained in webm
# --format ::: - 720p30 avc1, contained in mp4

# --format ::: - 480p60 HDR vp9(.2), contained in webm
# --format ::: - 480p60 HDR av1, contained in mp4
# --format ::: - 480p30 HDR vp9(.2), contained in webm
# --format ::: - 480p30 HDR av1, contained in webm
# --format ::: - 480p60 vp9, contained in webm
# --format ::: - 480p60 av1, contained in mp4
# --format ::: - 480p60 avc1, contained in mp4
# --format ::: - 480p30 vp9, contained in webm
# --format ::: - 480p30 av1, contained in webm
# --format ::: - 480p30 avc1, contained in mp4

# --format ::: - 360p60 HDR vp9(.2), contained in webm
# --format ::: - 360p60 HDR av1, contained in mp4
# --format ::: - 360p30 HDR vp9(.2), contained in webm
# --format ::: - 360p30 HDR av1, contained in webm
# --format ::: - 360p60 vp9, contained in webm
# --format ::: - 360p60 av1, contained in mp4
# --format ::: - 360p60 avc1, contained in mp4
# --format ::: - 360p30 vp9, contained in webm
# --format ::: - 360p30 av1, contained in webm
# --format ::: - 360p30 avc1, contained in mp4

# --format ::: - 240p60 HDR vp9(.2), contained in webm
# --format ::: - 240p60 HDR av1, contained in mp4
# --format ::: - 240p30 HDR vp9(.2), contained in webm
# --format ::: - 240p30 HDR av1, contained in webm
# --format ::: - 240p60 vp9, contained in webm
# --format ::: - 240p60 av1, contained in mp4
# --format ::: - 240p60 avc1, contained in mp4
# --format ::: - 240p30 vp9, contained in webm
# --format ::: - 240p30 av1, contained in webm
# --format ::: - 240p30 avc1, contained in mp4

# --format ::: - 144p60 HDR vp9(.2), contained in webm
# --format ::: - 144p60 HDR av1, contained in mp4
# --format ::: - 144p30 HDR vp9(.2), contained in webm
# --format ::: - 144p30 HDR av1, contained in webm
# --format ::: - 144p60 vp9, contained in webm
# --format ::: - 144p60 av1, contained in mp4
# --format ::: - 144p60 avc1, contained in mp4
# --format ::: - 144p30 vp9, contained in webm
# --format ::: - 144p30 av1, contained in webm
# --format ::: - 144p30 avc1, contained in mp4
#
# Above formats are YouTube-specific.
# -> Audio formats ordered by quality;
#    when same quality, by psychoacoustic model (codec).
#    --
#    NOTE[1]: Opus should be better, so it is preferred over AAC when available.
# -> Video formats ordered by quality;
#    when same quality, by various parameters (codec).
#    --
#    NOTE[1]: VP9 has better color, so it is preferred over AV1 when available.
#             Source: my eyes + window-over-window comparison.
#    NOTE[2]: At testing phase (2018-????), AV1 had 10-20% better bitrate over
#             VP9. For such videos, AV1 might be the bettter choice overall.
#             Note 1 still stands, though.
#
# FFmpeg code references:
# https://trac.ffmpeg.org/wiki
# https://trac.ffmpeg.org/wiki/Encode/HighQualityAudio
# https://trac.ffmpeg.org/wiki/FFmpeg%20and%20the%20SoX%20Resampler
ytdlp_a() (
    { # Variables expected to be present: OUT, FILENAME.
        handle_err() {
            trap - EXIT
            [ -d "$TMP_DIR" ] && rm -rf "$TMP_DIR"
            [ -d "$DIR" ] && cd "$DIR"
            exit $1
        }; handle_exit() {
            case $1 in
                0) : ;;
                *) handle_err $1 ;;
            esac
            case ":$OUT" in
                :) set -- * ;;
                *) set -- "$OUT" ;;
            esac
            case ":$FILENAME" in
                :)
                    mv "$TMP_DIR"/"$1" "$DIR"/"$1"
                    printf "%bFILE:%b %b%s%b\n" \
                           "\033[1;32m" "\033[0m" "\033[1;37m" \
                           "$DIR/$1" "\033[0m"
                ;;
                *)
                    mv "$TMP_DIR"/"$1" "$DIR"/"${FILENAME}${1#"${1%.*}"}"
                    printf "%bFILE:%b %b%s%b\n" \
                           "\033[1;32m" "\033[0m" "\033[1;37m" \
                           "$DIR/${FILENAME}${1#"${1%.*}"}" "\033[0m"
                ;;
            esac
            [ -d "$TMP_DIR" ] && rm -rf "$TMP_DIR"
            [ -d "$DIR" ] && cd "$DIR"
        }; work() {
            DIR="$PWD"; TMP_DIR="$HOME"/.b81y7yt73627iyqguo9v3ryrand0mstr1ng
            [ -d "$TMP_DIR" ] && rm -rf "$TMP_DIR"
            mkdir "$TMP_DIR"; cd "$TMP_DIR"
        }
        trap "handle_err \$?" INT TERM
        trap "handle_exit \$?" EXIT
        set -e
        work;
    } # Provided variables: DIR; TMP_DIR.

    case ":$1" in
        :)
            printf "%bERROR:%b No URL specified.\n" \
                   "\033[1;31m" "\033[0m"
            exit 2
        ;;
    esac

    URL="$1";
    case ":$2" in
        :) : ;;
        *) FILENAME="$2" ;;
    esac

    ARGS='--cookies-from-browser'
    ARGS="$ARGS"' firefox'
    ARGS="$ARGS"' --format'
    ARGS="$ARGS"' 338/258/327/141/256/251/140/22'

    yt-dlp_ ${ARGS} "$URL"

    IN=$(
        set -- *
        printf "%s" "$1"
    )
    OUT=$(
        case "$IN" in
            *.webm) printf "%s" "${IN%.webm}.opus" ;;
            *.m4a|*.mp4) printf "%s" "${IN%.*}.aac" ;;
            *)
                printf "%bYOUTUBE DID SOMETHING UNEXPECTED.%b\n"
                       "\033[1;31m" "\033[0m" 1>&2
                exit 1
            ;;
        esac
    )

    ARGS='-vn'
    ARGS="$ARGS"' -c:a copy'

    ffmpeg -i "$IN" ${ARGS} "$OUT"
)
ytdlp_a_opus() (
    { # Variables expected to be present: OUT, FILENAME.
        handle_err() {
            trap - EXIT
            [ -d "$TMP_DIR" ] && rm -rf "$TMP_DIR"
            [ -d "$DIR" ] && cd "$DIR"
            exit $1
        }; handle_exit() {
            case $1 in
                0) : ;;
                *) handle_err $1 ;;
            esac
            case ":$OUT" in
                :) set -- * ;;
                *) set -- "$OUT" ;;
            esac
            case ":$FILENAME" in
                :)
                    mv "$TMP_DIR"/"$1" "$DIR"/"$1"
                    printf "%bFILE:%b %b%s%b\n" \
                           "\033[1;32m" "\033[0m" "\033[1;37m" \
                           "$DIR/$1" "\033[0m"
                ;;
                *)
                    mv "$TMP_DIR"/"$1" "$DIR"/"${FILENAME}${1#"${1%.*}"}"
                    printf "%bFILE:%b %b%s%b\n" \
                           "\033[1;32m" "\033[0m" "\033[1;37m" \
                           "$DIR/${FILENAME}${1#"${1%.*}"}" "\033[0m"
                ;;
            esac
            [ -d "$TMP_DIR" ] && rm -rf "$TMP_DIR"
            [ -d "$DIR" ] && cd "$DIR"
        }; work() {
            DIR="$PWD"; TMP_DIR="$HOME"/.b81y7yt73627iyqguo9v3ryrand0mstr1ng
            [ -d "$TMP_DIR" ] && rm -rf "$TMP_DIR"
            mkdir "$TMP_DIR"; cd "$TMP_DIR"
        }
        trap "handle_err \$?" INT TERM
        trap "handle_exit \$?" EXIT
        set -e
        work;
    } # Provided variables: DIR; TMP_DIR.

    :
)
OPUS_CODE_TMP() {
    AUDIO_IN=$(
        set -- *
        printf "%s" "$1"
    )

    case "$AUDIO_IN" in
        *.opus) exit 0 ;;
        *) AUDIO_OUT=$(printf "%s" "${AUDIO_IN%.*}.opus") ;;
    esac

    ARGS=

    ffmpeg -i "$AUDIO_IN" ${ARGS} "$AUDIO_OUT"
}
ytdlp_a_aac() (
    :
)
ytdlp_a_mp3() (
    :
)
ytdlp_a_wav() (
    :
)
ytdlp_a_flac() (
    :
)
ytdlp_s() (
    { # Variables expected to be present: OUT, FILENAME.
        handle_err() {
            trap - EXIT
            [ -d "$TMP_DIR" ] && rm -rf "$TMP_DIR"
            [ -d "$DIR" ] && cd "$DIR"
            exit $1
        }; handle_exit() {
            case $1 in
                0) : ;;
                *) handle_err $1 ;;
            esac
            case ":$OUT" in
                :) set -- * ;;
                *) set -- "$OUT" ;;
            esac
            case ":$FILENAME" in
                :)
                    mv "$TMP_DIR"/"$1" "$DIR"/"$1"
                    printf "%bFILE:%b %b%s%b\n" \
                           "\033[1;32m" "\033[0m" "\033[1;37m" \
                           "$DIR/$1" "\033[0m"
                ;;
                *)
                    mv "$TMP_DIR"/"$1" "$DIR"/"${FILENAME}${1#"${1%.*}"}"
                    printf "%bFILE:%b %b%s%b\n" \
                           "\033[1;32m" "\033[0m" "\033[1;37m" \
                           "$DIR/${FILENAME}${1#"${1%.*}"}" "\033[0m"
                ;;
            esac
            [ -d "$TMP_DIR" ] && rm -rf "$TMP_DIR"
            [ -d "$DIR" ] && cd "$DIR"
        }; work() {
            DIR="$PWD"; TMP_DIR="$HOME"/.b81y7yt73627iyqguo9v3ryrand0mstr1ng
            [ -d "$TMP_DIR" ] && rm -rf "$TMP_DIR"
            mkdir "$TMP_DIR"; cd "$TMP_DIR"
        }
        trap "handle_err \$?" INT TERM
        trap "handle_exit \$?" EXIT
        set -e
        work;
    } # Provided variables: DIR; TMP_DIR.

    case ":$1" in
        :)
            printf "%bERROR:%b No URL specified.\n" \
                   "\033[1;31m" "\033[0m"
            exit 2
        ;;
    esac

    URL="$1";
    case ":$2" in
        :) : ;;
        *) FILENAME="$2" ;;
    esac

    ARGS='--write-sub'
    ARGS="$ARGS"' --skip-download'

    yt-dlp ${ARGS} "$URL"
)
ytdlp_s_srt() (
    { # Variables expected to be present: OUT, FILENAME.
        handle_err() {
            trap - EXIT
            [ -d "$TMP_DIR" ] && rm -rf "$TMP_DIR"
            [ -d "$DIR" ] && cd "$DIR"
            exit $1
        }; handle_exit() {
            case $1 in
                0) : ;;
                *) handle_err $1 ;;
            esac
            case ":$OUT" in
                :) set -- * ;;
                *) set -- "$OUT" ;;
            esac
            case ":$FILENAME" in
                :)
                    mv "$TMP_DIR"/"$1" "$DIR"/"$1"
                    printf "%bFILE:%b %b%s%b\n" \
                           "\033[1;32m" "\033[0m" "\033[1;37m" \
                           "$DIR/$1" "\033[0m"
                ;;
                *)
                    mv "$TMP_DIR"/"$1" "$DIR"/"${FILENAME}${1#"${1%.*}"}"
                    printf "%bFILE:%b %b%s%b\n" \
                           "\033[1;32m" "\033[0m" "\033[1;37m" \
                           "$DIR/${FILENAME}${1#"${1%.*}"}" "\033[0m"
                ;;
            esac
            [ -d "$TMP_DIR" ] && rm -rf "$TMP_DIR"
            [ -d "$DIR" ] && cd "$DIR"
        }; work() {
            DIR="$PWD"; TMP_DIR="$HOME"/.b81y7yt73627iyqguo9v3ryrand0mstr1ng
            [ -d "$TMP_DIR" ] && rm -rf "$TMP_DIR"
            mkdir "$TMP_DIR"; cd "$TMP_DIR"
        }
        trap "handle_err \$?" INT TERM
        trap "handle_exit \$?" EXIT
        set -e
        work;
    } # Provided variables: DIR; TMP_DIR.

    case ":$1" in
        :)
            printf "%bERROR:%b No URL specified.\n" \
                   "\033[1;31m" "\033[0m"
            exit 2
        ;;
    esac

    URL="$1";
    case ":$2" in
        :) : ;;
        *) FILENAME="$2" ;;
    esac

    ARGS='--write-sub'
    ARGS="$ARGS"' --skip-download'

    yt-dlp ${ARGS} "$URL"

    IN=$(
        set -- *
        printf "%s" "$1"
    )
    OUT=$(
        printf "%s" "${IN%.*}.srt"
    )

    ffmpeg -i "$IN" "$OUT"
)
ytdlp_s_auto() (
    { # Variables expected to be present: OUT, FILENAME.
        handle_err() {
            trap - EXIT
            [ -d "$TMP_DIR" ] && rm -rf "$TMP_DIR"
            [ -d "$DIR" ] && cd "$DIR"
            exit $1
        }; handle_exit() {
            case $1 in
                0) : ;;
                *) handle_err $1 ;;
            esac
            case ":$OUT" in
                :) set -- * ;;
                *) set -- "$OUT" ;;
            esac
            case ":$FILENAME" in
                :)
                    mv "$TMP_DIR"/"$1" "$DIR"/"$1"
                    printf "%bFILE:%b %b%s%b\n" \
                           "\033[1;32m" "\033[0m" "\033[1;37m" \
                           "$DIR/$1" "\033[0m"
                ;;
                *)
                    mv "$TMP_DIR"/"$1" "$DIR"/"${FILENAME}${1#"${1%.*}"}"
                    printf "%bFILE:%b %b%s%b\n" \
                           "\033[1;32m" "\033[0m" "\033[1;37m" \
                           "$DIR/${FILENAME}${1#"${1%.*}"}" "\033[0m"
                ;;
            esac
            [ -d "$TMP_DIR" ] && rm -rf "$TMP_DIR"
            [ -d "$DIR" ] && cd "$DIR"
        }; work() {
            DIR="$PWD"; TMP_DIR="$HOME"/.b81y7yt73627iyqguo9v3ryrand0mstr1ng
            [ -d "$TMP_DIR" ] && rm -rf "$TMP_DIR"
            mkdir "$TMP_DIR"; cd "$TMP_DIR"
        }
        trap "handle_err \$?" INT TERM
        trap "handle_exit \$?" EXIT
        set -e
        work;
    } # Provided variables: DIR; TMP_DIR.

    case ":$1" in
        :)
            printf "%bERROR:%b No URL specified.\n" \
                   "\033[1;31m" "\033[0m"
            exit 2
        ;;
    esac

    URL="$1";
    case ":$2" in
        :) : ;;
        *) FILENAME="$2" ;;
    esac

    ARGS='--write-auto-sub'
    ARGS="$ARGS"' --skip-download'

    yt-dlp ${ARGS} "$URL"
)
ytdlp_s_auto_srt() (
    { # Variables expected to be present: OUT, FILENAME.
        handle_err() {
            trap - EXIT
            [ -d "$TMP_DIR" ] && rm -rf "$TMP_DIR"
            [ -d "$DIR" ] && cd "$DIR"
            exit $1
        }; handle_exit() {
            case $1 in
                0) : ;;
                *) handle_err $1 ;;
            esac
            case ":$OUT" in
                :) set -- * ;;
                *) set -- "$OUT" ;;
            esac
            case ":$FILENAME" in
                :)
                    mv "$TMP_DIR"/"$1" "$DIR"/"$1"
                    printf "%bFILE:%b %b%s%b\n" \
                           "\033[1;32m" "\033[0m" "\033[1;37m" \
                           "$DIR/$1" "\033[0m"
                ;;
                *)
                    mv "$TMP_DIR"/"$1" "$DIR"/"${FILENAME}${1#"${1%.*}"}"
                    printf "%bFILE:%b %b%s%b\n" \
                           "\033[1;32m" "\033[0m" "\033[1;37m" \
                           "$DIR/${FILENAME}${1#"${1%.*}"}" "\033[0m"
                ;;
            esac
            [ -d "$TMP_DIR" ] && rm -rf "$TMP_DIR"
            [ -d "$DIR" ] && cd "$DIR"
        }; work() {
            DIR="$PWD"; TMP_DIR="$HOME"/.b81y7yt73627iyqguo9v3ryrand0mstr1ng
            [ -d "$TMP_DIR" ] && rm -rf "$TMP_DIR"
            mkdir "$TMP_DIR"; cd "$TMP_DIR"
        }
        trap "handle_err \$?" INT TERM
        trap "handle_exit \$?" EXIT
        set -e
        work;
    } # Provided variables: DIR; TMP_DIR.

    case ":$1" in
        :)
            printf "%bERROR:%b No URL specified.\n" \
                   "\033[1;31m" "\033[0m"
            exit 2
        ;;
    esac

    URL="$1";
    case ":$2" in
        :) : ;;
        *) FILENAME="$2" ;;
    esac

    ARGS='--write-auto-sub'
    ARGS="$ARGS"' --skip-download'

    yt-dlp ${ARGS} "$URL"

    IN=$(
        set -- *
        printf "%s" "$1"
    )
    OUT=$(
        printf "%s" "${IN%.*}.srt"
    )

    ffmpeg -i "$IN" "$OUT"
)
ytdlp_ramfs() (
    [ -e /mnt/ramdisk ] || {
        echo 'fail: /mnt/ramdisk does not exist'; return 0
    }
    yt-dlp --no-part --no-cache-dir -P /mnt/ramdisk "$@"
)

# unfinished
ytdlp_v() (
    { # Variables expected to be present: OUT, FILENAME.
        handle_err() {
            trap - EXIT
            [ -d "$TMP_DIR" ] && rm -rf "$TMP_DIR"
            [ -d "$DIR" ] && cd "$DIR"
            exit $1
        }; handle_exit() {
            case $1 in
                0) : ;;
                *) handle_err $1 ;;
            esac
            case ":$OUT" in
                :) set -- * ;;
                *) set -- "$OUT" ;;
            esac
            case ":$FILENAME" in
                :)
                    mv "$TMP_DIR"/"$1" "$DIR"/"$1"
                    printf "%bFILE:%b %b%s%b\n" \
                           "\033[1;32m" "\033[0m" "\033[1;37m" \
                           "$DIR/$1" "\033[0m"
                ;;
                *)
                    mv "$TMP_DIR"/"$1" "$DIR"/"${FILENAME}${1#"${1%.*}"}"
                    printf "%bFILE:%b %b%s%b\n" \
                           "\033[1;32m" "\033[0m" "\033[1;37m" \
                           "$DIR/${FILENAME}${1#"${1%.*}"}" "\033[0m"
                ;;
            esac
            [ -d "$TMP_DIR" ] && rm -rf "$TMP_DIR"
            [ -d "$DIR" ] && cd "$DIR"
        }; work() {
            DIR="$PWD"; TMP_DIR="$HOME"/.b81y7yt73627iyqguo9v3ryrand0mstr1ng
            [ -d "$TMP_DIR" ] && rm -rf "$TMP_DIR"
            mkdir "$TMP_DIR"; cd "$TMP_DIR"
        }
        trap "handle_err \$?" INT TERM
        trap "handle_exit \$?" EXIT
        set -e
        work;
    } # Provided variables: DIR; TMP_DIR.

    :
)
V_CODE_TMP() {
    URL="$1"; [ "$2" ] && FILENAME="$2" || FILENAME=

    ARGS='--format'
    ARGS="$ARGS"' 338/258/327/141/256/251/140/22'

    yt-dlp ${ARGS} "$URL"

    AUDIO_IN=$(
        set -- *
        printf "%s" "$1"
    )
    AUDIO_OUT=$(
        case "$AUDIO_IN" in
            *.webm) printf "%s" "${AUDIO_IN%.webm}.opus" ;;
            *.m4a|*.mp4) printf "%s" "${AUDIO_IN%.*}.aac" ;;
            *)
                printf "%bYOUTUBE DID SOMETHING UNEXPECTED.%b\n" "\033[1;31m" \
                                                                 "\033[0m" 1>&2
                exit 1
            ;;
        esac
    )

    ARGS='-vn'
    ARGS="$ARGS"' -c:a copy'

    ffmpeg -i "$AUDIO_IN" ${ARGS} "$AUDIO_OUT"

    ARGS='--format'
    ARGS="$ARGS"' bestvideo'

    yt-dlp ${ARGS} "$URL"

    VIDEO_IN=$(
        set -- *
        [ "$1" = "$AUDIO_OUT" ] && printf "%s" "$2" || printf "%s" "$1"
    )
    VIDEO_OUT=$(
        :
    )

    :
}
ytdlp_v_1080() (
    :
)
ytdlp_v_webm() (
    :
)
ytdlp_v_webm_1080() (
    :
)
ytdlp_v_mp4() (
    :
)
ytdlp_v_mp4_1080() (
    :
)
ytdlp_v_mkv() (
    :
)
ytdlp_v_mkv_1080() (
    :
)
ytdlp_v_ogg() (
    :
)
ytdlp_v_ogg_1080() (
    :
)
steamwinerun() ( WINEPREFIX="$HOME"/.steam/root/steamapps/compatdata/$1/pfx wine "$2"; )
dgrd() (
    if [ ! "$1" ] || [ ! "$2" ]; then
        printf "%s\n" 'STEP (1-X) = $1'
        printf "%s\n" 'NAME = $2+'
        exit 2
    fi

    STEP="$1"; shift
    DIR=/var/cache/pacman/pkg
    OUT_FLAG=0

    while [ "$#" -ge 1 ]; do
        NAME="$1"
        FILES=$(
            find "$DIR" -name "$NAME"-[0123456789]*.zst -printf "%T+ %p\n" | \
            sort -r
        )

        if [ ! "$FILES" ]; then
            printf "%s\n" 'ERR NO FILES. NAME=%s' "$NAME"
            exit 1
        fi

        x=0; while IFS= read -r LINE; do
            [ "$x" = "$STEP" ] || { x=$((x + 1)); continue; }

            LINE="${LINE#* }"
            if [ "$OUT_FLAG" = 0 ]; then
                printf "%s\n" 'pacman -U \'
                OUT_FLAG=1
            fi
            if [ "$2" ]; then
                printf "%s %s\n" "$LINE" '\'
            else
                printf "%s\n" "$LINE"
            fi
            shift; continue 2
        done <<EOF
$FILES
EOF

        printf "ERR PKG DGRD STEP NO EXIST. x=%s\n" "$x"
        exit 1
    done
)
ytv() { youtube-dl --format bestvideo+bestaudio "$1"; }
ytv1080() { youtube-dl --format bestvideo[height<=1080]+bestaudio "$1"; }
ipv6disable() { su -c 'sysctl -w net.ipv6.conf.all.disable_ipv6=1; sysctl -w net.ipv6.conf.default.disable_ipv6=1'; }
ipv6enable() { su -c 'sysctl -w net.ipv6.conf.all.disable_ipv6=0; sysctl -w net.ipv6.conf.default.disable_ipv6=0'; }
_BASH_FUNCTIONS

    __file_write;

    FILE_PATH \
<<_BASHRC
$home/.bashrc
_BASHRC

    FILE \
<<'_BASHRC'
# Don't parse .bashrc if not running interactively
[[ $- != *i* ]] && return

PS1=\
'\[\033[1;32m\]['\
"\$(\
RC=\$?; \
[ "\$RC" -eq 0 ] \
    && printf "%s%d" '\[\033[1;32m\]' "\$RC" \
    || printf "%s%d" '\[\033[1;33m\]' "\$RC" \
)"' '\
'\[\033[1;36m\]\u@\h '\
'\[\033[1;31m\]\W\[\033[1;32m\]]\$\[\033[0m\] '

export HISTCONTROL=ignoreboth:erasedups
export PATH="${PATH}:$HOME/.local/bin:$HOME/scripts"
export EDITOR=nano

alias ls='ls --color'
alias grep='grep --color=always'
alias ip='ip --color'
alias clr='tput reset; stty -ixon susp undef'
alias gfix='git add .; git commit --amend --date="now" -s'
alias gfixf='git add .; git commit --amend --date="now" --no-edit -s'
alias gchk='git diff --check HEAD~10'

# Source useful custom functions
[ -f "$HOME"/.bash_functions ] && . "$HOME"/.bash_functions

# '-ixon': Disable "Ctrl + S"; WHY IS THIS STILL DEFAULT?
# 'susp undef': Disable "Ctrl + Z"
stty -ixon susp undef
_BASHRC

    __file_write;
}

_bluez_conf() {
    FILE_PATH \
<<'MAIN_CONF'
/etc/bluetooth/main.conf
MAIN_CONF

    FILE \
<<'MAIN_CONF'
[General]
Name = gUcciestBlueZ420
DiscoverableTimeout = 0
FastConnectable = true

[Policy]
AutoEnable=false
ReconnectAttempts=3
ReconnectIntervals=2,8,16
MAIN_CONF

    __file_write_overwrite;
}

# RTC clock sync using the closest NTP server (pool.ntp.org)
_clk_sync() {
    cmd 'hwclock' || ENOCMD 'hwclock'
    cmd 'ntpd' || ENOCMD 'ntpd'

    if [ "$logging" = 1 ]; then
        info -w - 'ntpd:'

        if ! ntpd -gGLnq pool.ntp.org; then
            errF 235 - 'ntpd: Failed.'
        fi

        if ! hwclock -w; then
            errF 235 - 'hwclock: Failed to set the system clock.'
        fi
    else
        if ! ntpd -gGLnq pool.ntp.org > /dev/null 2>&1; then
            errF 235 - 'ntpd: Failed.'
        fi

        if ! hwclock -w > /dev/null 2>&1; then
            errF 235 - 'hwclock: Failed to set the system clock.'
        fi
    fi
}

# Software configuration - stage 1
#
# State-of-the-art config:
# > never overwrites or overwritten.
#
# Run stage 1 at any time of -- initial -- system configuration with:
# > the full filesystem mounted and user dir provided ($home; $user).
#
# The following functions shall -- only -- be defined in _conf_4() if they
# are influenced by utility switches; never to be defined in any other _conf_*()
# functions.
_conf_1() {
    _alsa_conf;
    _bash_conf;
    _doas_conf;
    _face_bin;
    _fontconfig_conf;
    _git_conf;
    _gtk_conf;
    _hostname;
    _imv_conf;
    _iwd_conf;
    _kitty_conf;
    _kvantum_conf;
    _moc_conf;
    _modprobe_conf;
    _mpv_conf;
    _mutt_conf;
    _nano_conf;
    _openal_conf;
    _pipewire_conf;
    _pipewire_media_session_conf;
    _ranger_conf;
    _sudo_conf;
    _sway_conf;
    _swaylock_conf;
    _sysctl_conf;
    _wireplumber_conf;
    _xdg_conf;
    _xorg_conf;
}

# Software configuration - stage 2
#
# Config might:
# > overwrite or be overwritten.
# > depend on installed software.
#
# Function might:
# > require $force
#
# Run stage 2 at any time of -- desired -- system configuration with:
# > the full filesystem mounted and user dir provided ($home; $user).
# > the output parsed to understand what is not yet being configured.
#
# The following functions shall -- only -- be defined in _conf_4() if they
# are influenced by utility switches; never to be defined in any other _conf_*()
# functions.
_conf_2() {
    _autostart;
    _env;
    _featherpad_conf;
    _hosts;
    _locale;
    _reflector;
    _resolv_conf;
    _sh;
    _tz;
    _xfce4_conf;

    if file '/etc/dhcpcd.conf'; then
        _dhcpcd_conf;
    else
        info -y -1 'Skipped _dhcpcd_conf()'
    fi

    if file '/etc/dnsmasq.conf'; then
        _dnsmasq_conf;
    else
        info -y -1 'Skipped _dnsmasq_conf()'
    fi

    if file '/etc/gai.conf'; then
        _gai_conf;
    else
        info -y -1 'Skipped _gai_conf()'
    fi

    if cmd 'grub-install' && cmd 'grub-mkconfig'; then
        _grub;

        if file '/etc/default/grub'; then
            _grub_conf;
        else
            info -y -1 'Skipped _grub_conf()'
        fi
    else
        info -y -1 'Skipped _grub()'
        info -y -1 'Skipped _grub_conf()'
    fi

    if file '/etc/mkinitcpio.conf'; then
        _initramfs_conf;
    else
        info -y -1 'Skipped _initramfs_conf()'
    fi

    if file '/etc/makepkg.conf'; then
        _makepkg_conf;
    else
        info -y -1 'Skipped _makepkg_conf()'
    fi

    if file '/etc/pacman.conf'; then
        _pacman_conf;
    else
        info -y -1 'Skipped _pacman_conf()'
    fi

    if file '/etc/security/faillock.conf' && \
       file '/etc/login.defs' && \
       file '/etc/pam.d/su' && \
       file '/etc/pam.d/system-auth'; then
        _pam_conf;
    else
        info -y -1 'Skipped _pam_conf()'
    fi
}

# Software configuration - stage 3
#
# Config might:
# > overwrite or be overwritten.
# > depend on specific installed software.
# > depend on ever-executed software.
#
# Function might:
# > require $force
#
# Run stage 3 at any time of -- desired -- system configuration with:
# > the full filesystem mounted and user dir provided ($home; $user).
# > the output parsed to understand what is not yet being configured.
#
# The following functions shall -- only -- be defined in _conf_4() if they
# are influenced by utility switches; never to be defined in any other _conf_*()
# functions.
_conf_3() {
    if file '/etc/bluetooth/main.conf'; then
        _bluez_conf;
    else
        info -y -1 'Skipped _bluez_conf()'
    fi

    if file "$home"/'.mozilla/firefox/profiles.ini'; then
        _firefox_conf;
    else
        info -y -1 'Skipped _firefox_conf()'
    fi

    if file '/etc/fuse.conf'; then
        _fuse_conf;
    else
        info -y -1 'Skipped _fuse_conf()'
    fi

    if file '/etc/pulse/default.pa'; then
        _pulseaudio_conf;
    else
        info -y -1 'Skipped _pulseaudio_conf()'
    fi
}

# Software configuration - stage 4
#
# Config is:
# > influenced by utility switches.
#
# Config might:
# > overwrite or be overwritten.
# > depend on specific installed software.
# > depend on ever-executed software.
#
# Function might:
# > require $force
#
# Run stage 4 at any time of -- desired -- system configuration with:
# > the full filesystem mounted and user dir provided ($home; $user).
# > the intent of reproducing the currently declared configuration.
_conf_4() {
    _alsa_conf;
    _autostart;
    _env;
    _hosts;
    _iwd_conf;
    _pipewire_conf;
    _reflector;
    _resolv_conf;
    _sh;
    _sway_conf;
    _tz;
    _wireplumber_conf;
    _xfce4_conf;
    _xorg_conf;

    if file '/etc/dhcpcd.conf'; then
        _dhcpcd_conf;
    fi

    if file '/etc/dnsmasq.conf'; then
        _dnsmasq_conf;
    fi

    if file '/etc/gai.conf'; then
        _gai_conf;
    fi

    if cmd 'grub-mkconfig' && file '/etc/default/grub'; then
        _grub_conf;
    fi

    if file '/etc/mkinitcpio.conf'; then
        _initramfs_conf;
    fi

    if file '/etc/pulse/default.pa'; then
        _pulseaudio_conf;
    fi
}

_dhcpcd_conf() {
    FILE_PATH \
<<'DHCPCD_CONF'
/etc/dhcpcd.conf
DHCPCD_CONF

    if [ "$ipv6" = 1 ]; then
        FILE \
<<'DHCPCD_CONF'
static domain_name_servers=::1 127.0.0.1
slaac private
duid
noipv4ll

DHCPCD_CONF
    else
        FILE \
<<'DHCPCD_CONF'
static domain_name_servers=127.0.0.1
slaac hwaddr
clientid
noipv6rs
noipv6

DHCPCD_CONF
    fi

    FILE \
<<'DHCPCD_CONF'
option classless_static_routes
option interface_mtu
option host_name
option rapid_commit
require dhcp_server_identifier
vendorclassid

noarp
nohook resolv.conf
DHCPCD_CONF

    __file_write_overwrite;
}

# DNS stub resolver configuration
_dnsmasq_conf() {
    FILE_PATH \
<<'DNSMASQ_CONF'
/etc/dnsmasq.conf
DNSMASQ_CONF

    FILE \
<<'DNSMASQ_CONF'
bind-interfaces
cache-size=2048
domain-needed
bogus-priv
no-resolv
no-poll
no-hosts
no-negcache
dnssec
dnssec-check-unsigned
trust-anchor=.,20326,8,2,E06D44B80B8F1D39A95C0B0D7C65D08458E880409BBC683457104237C7F8EC8D
trust-anchor=.,38696,8,2,683D2D0ACB8C9B712A1948B27F741219298D0A450D612C483AF444A4C0FB2B16
all-servers
DNSMASQ_CONF

    if [ "$ipv6" = 1 ]; then
        FILE \
<<'DNSMASQ_CONF'
listen-address=::1,127.0.0.1
server=2606:4700:4700::1111
server=2606:4700:4700::1001
server=2620:119:35::35
server=2620:119:53::53
server=2001:4860:4860::8888
server=2001:4860:4860::8844
server=2620:fe::fe
server=2620:fe::9
server=1.1.1.1
server=1.0.0.1
server=208.67.222.222
server=208.67.220.220
server=8.8.8.8
server=8.8.4.4
server=9.9.9.9
server=149.112.112.112
DNSMASQ_CONF
    else
        FILE \
<<'DNSMASQ_CONF'
listen-address=127.0.0.1
server=1.1.1.1
server=1.0.0.1
server=208.67.222.222
server=208.67.220.220
server=8.8.8.8
server=8.8.4.4
server=9.9.9.9
server=149.112.112.112
DNSMASQ_CONF
    fi

    __file_write_overwrite;
}

_doas_conf() {
    FILE_PATH \
<<'DOAS_CONF'
/etc/doas.conf
DOAS_CONF

    FILE \
<<'DOAS_CONF'
permit persist :wheel as root
DOAS_CONF

    __file_write;
    __loc_chmod '0400'
}

_env() {
    FILE_PATH \
<<BROWSER
$home/.syscfg_env/browser
BROWSER

    if [ "$browser" = firefox ]; then
        if [ "$server" = wayland ]; then
            FILE \
<<'BROWSER'
MOZ_ENABLE_WAYLAND=1
BROWSER

            __file_write_overwrite;
        elif [ "$server" = x11 ]; then
            FILE \
<<'BROWSER'
MOZ_ENABLE_WAYLAND=0
BROWSER

            __file_write_overwrite;
        elif [ "$server" = none ] || [ ! "$server" ]; then
            __loc_delete;
        fi
    fi

    FILE_PATH \
<<QT_THEME
$home/.syscfg_env/qt_theme
QT_THEME

    if [ "$qt_theme" = kvantum ]; then
        FILE \
<<'QT_THEME'
QT_STYLE_OVERRIDE=kvantum
QT_THEME

        __file_write_overwrite;
    elif [ "qt_theme" = none ] || [ ! "$qt_theme" ]; then
        __loc_delete;
    fi

    FILE_PATH \
<<SERVER
$home/.syscfg_env/server
SERVER

    if [ "$server" = wayland ]; then
        FILE \
<<'SERVER'
QT_QPA_PLATFORM=wayland
QT_WAYLAND_DISABLE_WINDOWDECORATION=1
SDL_VIDEODRIVER=wayland
GDK_BACKEND=wayland
GTK_USE_PORTAL=1
SERVER

        __file_write_overwrite;
    elif [ "$server" = x11 ]; then
        FILE \
<<'SERVER'
QT_QPA_PLATFORM=xcb
SDL_VIDEODRIVER=x11
GDK_BACKEND=x11
SERVER

        __file_write_overwrite;
    elif [ "$server" = none ] || [ ! "$server" ]; then
        __loc_delete;
    fi

    FILE_PATH \
<<WM
$home/.syscfg_env/wm
WM

    if [ "$wm" = sway ]; then
        FILE \
<<'WM'
XDG_CURRENT_DESKTOP=sway
XDG_SESSION_DESKTOP=sway
DESKTOP_SESSION=sway
WM

        __file_write_overwrite;
    elif [ "$wm" = xfce4 ]; then
        FILE \
<<'WM'
XDG_CURRENT_DESKTOP=XFCE
XDG_SESSION_DESKTOP=xfce
DESKTOP_SESSION=xfce
WM

        __file_write_overwrite;
    elif [ "$wm" = none ] || [ ! "$wm" ]; then
        __loc_delete;
    fi

    FILE_PATH \
<<_BASH_PROFILE
$home/.bash_profile
_BASH_PROFILE

    FILE \
<<'_BASH_PROFILE'
set -a; for file in "$HOME"/.syscfg_env/*; do
    . "$file"
done; set +a
_BASH_PROFILE

    if [ "$wm" = sway ]; then
        FILE \
<<'_BASH_PROFILE'

if [ -z "$DISPLAY" ] && [ "$(tty)" = '/dev/tty1' ]; then
    if command -v sway > /dev/null 2>&1; then
        exec sway > /var/log/sway.log 2>&1
    fi
fi
_BASH_PROFILE
    elif [ "$wm" = xfce4 ]; then
        FILE \
<<'_BASH_PROFILE'

if [ -z "$DISPLAY" ] && [ "$(tty)" = '/dev/tty1' ]; then
    if command -v startx > /dev/null 2>&1; then
        exec startx
    fi
fi
_BASH_PROFILE
    fi

    __file_write;

    if [ "$wm" = sway ]; then
        FILE_PATH \
<<'SWAY_LOG'
/var/log/sway.log
SWAY_LOG

        __loc_empty;
        __loc_chmod '0644'
        __loc_chown "$user"
    fi
}

# .face png in $home (user $HOME); some applications use this file.
_face_bin() {
    FILE_PATH \
<<_FACE
$home/.face
_FACE

    FILE \
<<'_FACE'
 211 120 116 107 015 012 032 012 000 000 000 015 111 110 104 122
 000 000 000 144 000 000 000 144 010 002 000 000 000 377 200 002
 003 000 000 000 003 163 102 111 124 010 010 010 333 341 117 340
 000 000 010 010 111 104 101 124 170 234 355 235 117 150 023 117
 024 307 137 252 325 370 277 326 077 304 077 075 010 125 243 124
 232 050 005 251 010 332 136 104 004 053 036 104 301 322 256 005
 017 005 351 101 017 036 212 207 212 050 071 064 170 116 215 030
 355 105 321 252 330 253 101 244 212 042 046 324 103 113 212 177
 132 264 242 025 135 250 156 252 326 375 035 346 327 141 234 375
 237 314 314 116 045 237 123 166 166 063 373 366 333 231 267 157
 346 315 244 001 135 327 241 204 073 312 374 066 140 066 121 022
 313 003 045 261 074 120 022 313 003 045 261 074 060 013 304 112
 247 323 175 175 175 176 133 001 060 053 304 112 245 122 207 016
 035 272 172 365 252 337 206 000 350 162 323 335 335 215 115 115
 046 223 376 032 043 173 313 032 031 031 301 237 133 133 133 375
 155 137 054 305 312 144 062 055 055 055 147 317 236 145 130 047
 205 317 172 261 155 250 065 065 065 000 120 133 133 313 252 302
 366 366 166 243 315 167 356 334 141 125 277 047 030 167 303 301
 301 301 171 363 346 145 263 331 160 070 314 266 146 222 267 157
 337 362 253 334 006 366 076 353 324 251 123 000 060 074 074 314
 111 057 105 121 072 072 072 170 324 354 010 173 261 142 261 130
 165 165 065 160 323 153 303 206 015 314 353 164 111 121 142 145
 062 031 323 160 061 227 313 141 275 366 356 335 133 314 055 244
 242 050 261 042 221 110 062 231 104 375 216 042 227 313 125 124
 124 000 100 072 235 276 161 343 106 061 167 261 047 036 217 007
 002 001 176 365 223 024 333 015 357 336 275 333 327 327 267 151
 323 046 143 304 360 365 353 327 271 163 347 002 000 127 027 063
 070 070 310 257 162 012 006 076 153 164 164 364 335 273 167 027
 057 136 154 153 153 243 116 041 231 046 046 046 166 355 332 125
 374 215 214 234 077 177 376 312 225 053 074 152 066 207 131 014
 122 126 006 146 021 026 352 214 000 160 374 370 361 002 252 065
 306 131 135 135 135 350 124 127 127 027 363 247 260 207 331 333
 160 172 172 072 020 010 144 263 331 225 053 127 222 345 270 063
 246 122 051 206 316 053 036 217 167 166 166 262 252 315 045 054
 103 207 077 177 376 000 300 227 057 137 202 301 040 131 216 175
 126 001 043 041 112 172 104 042 221 270 166 355 132 101 066 026
 005 343 070 113 327 165 000 230 232 232 042 365 212 305 142 353
 326 255 003 200 261 261 061 257 221 304 304 304 204 261 060 223
 311 274 174 371 262 070 113 013 201 175 120 212 365 132 270 160
 041 056 074 172 364 050 372 120 174 044 061 060 060 060 060 060
 120 114 015 205 303 311 027 242 312 053 052 052 160 011 152 134
 000 260 177 377 176 367 365 234 076 175 332 307 247 240 340 170
 033 024 053 256 130 261 002 035 222 217 175 375 372 165 367 365
 140 225 377 145 261 364 031 275 252 253 253 321 141 141 215 313
 164 226 306 027 261 370 316 224 176 370 360 001 000 106 106 106
 220 137 157 152 152 102 345 375 375 375 356 075 227 351 013 321
 027 370 212 025 012 205 132 133 133 001 040 235 116 267 265 265
 055 130 260 000 237 352 355 355 165 131 211 351 013 221 244 256
 256 256 140 013 275 041 240 365 342 111 225 023 047 116 220 016
 310 245 347 262 357 206 212 242 360 266 037 043 042 141 361 372
 365 353 245 113 227 002 100 117 117 317 326 255 133 161 271 313
 306 225 315 146 155 316 212 234 336 022 224 335 121 125 025 015
 036 037 075 172 204 013 135 172 256 071 163 346 330 234 135 274
 170 161 361 346 271 144 256 260 073 115 117 117 227 225 225 115
 115 115 221 205 157 336 274 161 374 242 225 317 332 261 143 307
 341 303 207 205 116 061 013 353 360 272 131 204 351 030 103 220
 111 126 222 140 060 070 076 076 056 306 154 214 350 214 364 242
 105 213 250 307 266 167 363 212 242 230 212 325 331 331 051 314
 146 214 150 261 352 353 353 251 307 306 363 123 106 056 135 272
 144 252 324 366 355 333 105 332 214 021 235 276 067 212 145 105
 076 237 267 352 203 113 226 054 141 147 221 007 104 213 025 213
 305 052 053 053 335 134 171 341 302 205 217 037 077 232 236 232
 077 177 076 123 243 334 342 303 302 020 074 135 143 317 373 367
 357 255 116 215 216 216 262 063 307 003 376 257 242 061 215 071
 343 361 270 115 046 142 150 150 150 150 150 210 247 121 346 370
 057 326 203 007 017 214 205 337 276 175 263 377 326 275 173 367
 370 230 143 207 377 142 151 232 266 173 367 156 257 337 372 371
 363 047 017 143 354 361 137 054 000 170 374 370 061 065 356 031
 033 033 363 313 030 033 244 020 013 376 036 124 333 073 054 304
 357 337 277 071 133 144 202 017 142 151 232 146 054 044 007 325
 246 316 073 032 215 222 207 317 237 077 347 141 233 003 202 203
 140 253 070 023 146 306 211 232 246 205 102 041 343 131 343 014
 237 247 211 174 046 210 233 165 100 220 013 152 051 120 343 032
 036 036 066 215 105 311 304 032 042 227 313 061 066 316 011 321
 142 331 323 333 333 153 332 254 140 046 035 111 202 126 005 210
 104 012 261 312 313 313 177 375 372 005 000 375 375 375 246 027
 050 212 162 346 314 231 055 133 266 210 265 213 106 264 203 067
 365 356 015 015 015 366 337 332 274 171 163 070 034 246 026 135
 212 177 041 012 025 313 064 046 120 024 005 255 251 264 042 030
 014 066 067 067 003 000 025 273 212 357 206 102 305 062 365 356
 216 031 207 366 366 166 344 310 326 256 135 113 226 377 343 055
 313 264 017 002 000 231 117 064 262 176 375 172 364 101 125 125
 262 034 255 160 022 212 260 040 305 052 302 102 063 245 126 013
 032 310 264 340 370 370 070 231 351 011 207 303 302 214 107 210
 153 131 126 021 026 312 145 341 314 076 005 331 111 103 241 320
 221 043 107 360 241 370 211 032 101 142 045 022 011 323 105 125
 216 333 045 250 264 340 306 215 033 311 103 301 023 065 202 304
 262 132 253 207 033 216 351 024 240 243 224 077 176 374 140 142
 236 113 104 210 145 325 254 200 150 070 224 363 106 124 125 125
 121 045 124 302 125 260 217 027 041 326 223 047 117 114 233 225
 143 303 061 106 122 324 362 243 313 227 057 347 363 371 342 055
 164 011 307 315 231 211 104 142 337 276 175 015 015 015 126 223
 123 216 021 226 061 222 242 032 240 252 252 075 075 075 205 332
 353 031 226 101 160 044 022 171 361 342 305 253 127 257 122 251
 124 115 115 315 247 117 237 154 326 024 107 243 321 110 044 142
 137 041 336 160 200 071 170 360 140 074 036 047 113 076 177 376
 134 260 301 236 141 036 214 240 325 105 216 120 211 350 155 333
 266 121 027 230 246 235 065 115 243 026 331 237 073 167 216 371
 043 130 301 336 147 251 252 352 250 027 325 254 022 211 204 261
 201 054 137 276 334 370 305 140 060 270 163 347 116 262 104 344
 010 221 213 203 167 324 253 271 271 371 300 201 003 350 163 046
 223 271 165 353 226 125 362 331 010 025 152 211 034 041 362 372
 263 250 252 272 152 325 052 352 115 037 215 106 053 053 053 033
 033 033 311 227 140 044 022 131 263 146 215 373 232 251 165 070
 102 243 007 256 235 274 251 251 251 256 256 256 161 206 373 367
 357 133 135 151 164 366 215 215 215 246 127 122 043 304 075 173
 366 160 063 237 106 226 137 014 061 256 262 265 022 113 327 365
 143 307 216 341 313 202 301 240 246 151 142 214 224 045 157 150
 144 365 352 325 126 247 110 267 225 317 347 237 076 175 052 304
 042 151 222 254 106 310 165 315 024 224 053 174 366 354 031 177
 163 000 344 021 313 323 066 212 362 362 162 362 160 162 162 222
 265 071 346 310 042 226 161 111 262 115 114 160 362 344 111 362
 120 330 010 121 026 261 214 330 104 233 124 246 107 330 010 121
 026 261 274 356 146 242 062 075 142 106 210 262 210 365 375 373
 167 117 327 123 356 137 314 240 107 026 261 360 076 152 214 375
 070 246 243 243 243 245 245 005 037 212 131 333 046 213 130 140
 310 131 070 066 226 144 062 211 365 272 171 363 046 047 253 110
 044 022 253 200 115 230 130 057 061 231 036 211 304 242 334 226
 313 351 004 254 227 210 114 217 230 121 225 113 226 055 133 206
 015 363 264 217 272 273 273 373 341 303 207 334 354 372 037 271
 304 242 266 215 211 137 333 147 217 104 335 020 014 357 104 067
 273 021 105 042 227 130 360 367 146 225 333 267 157 373 150 211
 011 176 067 155 023 012 330 164 056 006 351 132 026 374 335 270
 344 352 211 176 377 265 314 301 211 173 117 357 104 336 110 052
 226 116 154 020 226 247 047 312 330 015 021 223 223 223 150 304
 343 376 267 105 170 043 257 130 000 020 213 305 300 343 017 327
 360 305 357 246 355 000 032 312 124 125 125 371 155 210 256 313
 354 263 060 110 257 372 372 172 277 015 231 015 142 351 063 172
 025 366 343 235 014 231 035 142 351 063 172 371 373 146 224 142
 357 216 033 222 311 144 155 155 255 233 237 264 343 107 100 057
 375 143 065 327 110 035 072 310 106 111 054 017 224 304 362 100
 111 054 017 224 304 362 100 111 054 017 374 007 045 367 037 310
 075 064 164 315 000 000 000 000 111 105 116 104 256 102 140 202
_FACE

    __bin_write;
}

_featherpad_conf() {
    FILE_PATH \
<<FP_CONF
$home/.config/featherpad/fp.conf
FP_CONF

    FILE \
<<'FP_CONF'
[text]
appendEmptyLine=true
autoBracket=false
autoReplace=false
autoSave=false
autoSaveInterval=1
darkBgColorValue=30
darkColorScheme=true
dateFormat=
dictionaryPath=
executeCommand=
executeScripts=false
font="Source Code Pro,12,-1,5,50,0,0,0,0,0"
inertialScrolling=false
lightBgColorValue=255
lineNumbers=true
maxSHSize=2
noIndent=false
noSyntaxHighlighting=false
noWrap=false
pastePaths=false
recentFiles=
recentFilesNumber=10
recentOpened=false
removeTrailingSpaces=false
saveLastFilesList=false
saveUnmodified=false
scrollJumpWorkaround=false
selectionHighlighting=false
showEndings=false
showWhiteSpace=false
skipNonText=true
spellCheckFromStart=false
textMargin=false
textTabSize=8
thickCursor=false
vLineDistance=80

[window]
closeWithLastTab=false
disableMenubarAccel=false
fullscreen=false
hideSearchbar=false
hideSingleTab=false
max=true
menubarTitle=false
nativeDialog=true
noMenubar=false
noToolbar=true
openInWindows=false
position=none
prefSize=@Size(497 530)
sharedSearchHistory=false
showCursorPos=false
showLangSelector=false
showStatusbar=true
sidePaneMode=false
size=@Size(700 500)
splitterPos=20
startSize=@Size(700 500)
sysIcons=false
tabPosition=0
tabWrapAround=false
FP_CONF

    __file_write;
}

_firefox_conf() {
    cmd 'git' || ENOCMD 'git'

    FILE_PATH \
<<PROFILES_INI
$home/.mozilla/firefox/profiles.ini
PROFILES_INI

    if ! exist "$FILE_PATH"; then
        ENOENT;
        err -r -- 'F '; err - - "$FILE_PATH"
        exit 202
    fi

    __git_get 'https://github.com/mscalindt/firefox-profile-private'

    FILE_PATH \
<<IRA5808S_MSCALINDT
$tmpd/firefox-profile-private/ira5808s.mscalindt
IRA5808S_MSCALINDT

    FILE_PATH_TARGET \
<<IRA5808S_MSCALINDT
$home/.mozilla/firefox/ira5808s.mscalindt
IRA5808S_MSCALINDT

    __dir_target_write;

    FILE_PATH \
<<PROFILES_INI
$home/.mozilla/firefox/profiles.ini
PROFILES_INI

    __FILE_PATH_preload;

    FILE=$(
        line_add() {
            while IFS= read -r line; do
                i=$((i + 1))

                if [ "$logging" = 1 ]; then
                    LOG_write 1 "$i" "$line"
                fi

                printf "%s\n" "$line"
            done <<EOF
$1
EOF
        }

        case "${FILE#"${FILE%??}"}" in
            "$LF$LF") : ;;
            *"$LF") FILE="$FILE$LF" ;;
            *) FILE="$FILE$LF$LF" ;;
        esac

        FLAG_PROFILE=0

        i=0; j=0; printf "%s" "$FILE" | { while IFS= read -r LINE; do
            i=$((i + 1))

            case "$LINE" in
                'Path=ira5808s.mscalindt')
                    FLAG_PROFILE=1
                ;;
                '[Profile'*']')
                    j=$((j + 1))
                ;;
            esac

            printf "%s\n" "$LINE"
        done

        while :; do
            if [ "$FLAG_PROFILE" = 0 ]; then
                FLAG_PROFILE=1

                line_add "[Profile${j}]"
                line_add 'Name=mscalindt'
                line_add 'IsRelative=1'
                line_add 'Path=ira5808s.mscalindt'
            else
                break
            fi
        done; }
    ); FILE="$FILE$LF"

    __file_write_overwrite;

    __git_get 'https://github.com/mscalindt/firefox-profiles'

    FILE_PATH \
<<499SH1EV_HARDENED
$tmpd/firefox-profiles/499sh1ev.HARDENED
499SH1EV_HARDENED

    FILE_PATH_TARGET \
<<499SH1EV_HARDENED
$home/.mozilla/firefox/499sh1ev.HARDENED
499SH1EV_HARDENED

    __dir_target_write;

    FILE_PATH \
<<PROFILES_INI
$home/.mozilla/firefox/profiles.ini
PROFILES_INI

    __FILE_PATH_preload;

    FILE=$(
        line_add() {
            while IFS= read -r line; do
                i=$((i + 1))

                if [ "$logging" = 1 ]; then
                    LOG_write 1 "$i" "$line"
                fi

                printf "%s\n" "$line"
            done <<EOF
$1
EOF
        }

        case "${FILE#"${FILE%??}"}" in
            "$LF$LF") : ;;
            *"$LF") FILE="$FILE$LF" ;;
            *) FILE="$FILE$LF$LF" ;;
        esac

        FLAG_PROFILE=0

        i=0; j=0; printf "%s" "$FILE" | { while IFS= read -r LINE; do
            i=$((i + 1))

            case "$LINE" in
                'Path=499sh1ev.HARDENED')
                    FLAG_PROFILE=1
                ;;
                '[Profile'*']')
                    j=$((j + 1))
                ;;
            esac

            printf "%s\n" "$LINE"
        done

        while :; do
            if [ "$FLAG_PROFILE" = 0 ]; then
                FLAG_PROFILE=1

                line_add "[Profile${j}]"
                line_add 'Name=HARDENED'
                line_add 'IsRelative=1'
                line_add 'Path=499sh1ev.HARDENED'
            else
                break
            fi
        done; }
    ); FILE="$FILE$LF"

    __file_write_overwrite;
}

_fontconfig_conf() {
    FILE_PATH \
<<01_FONT_CONF
$home/.config/fontconfig/conf.d/01-font.conf
01_FONT_CONF

    FILE \
<<'01_FONT_CONF'
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE fontconfig SYSTEM "fonts.dtd">
<fontconfig>
  <alias>
    <family>serif</family>
    <prefer>
      <family>DejaVu Serif</family>
    </prefer>
  </alias>
  <alias>
    <family>DejaVu Serif</family>
    <default>
      <family>serif</family>
    </default>
  </alias>

  <alias>
    <family>sans-serif</family>
    <prefer>
      <family>Cantarell</family>
    </prefer>
  </alias>
  <alias>
    <family>Cantarell</family>
    <default>
      <family>sans-serif</family>
    </default>
  </alias>

  <alias>
    <family>monospace</family>
    <prefer>
      <family>Cantarell</family>
    </prefer>
  </alias>
  <alias>
    <family>Cantarell</family>
    <default>
      <family>monospace</family>
    </default>
  </alias>
</fontconfig>
01_FONT_CONF

    __file_write;
}

_fuse_conf() {
    FILE_PATH \
<<'FUSE_CONF'
/etc/fuse.conf
FUSE_CONF

    FILE \
<<'FUSE_CONF'
user_allow_other
FUSE_CONF

    __file_write_overwrite;
}

_gai_conf() {
    FILE_PATH \
<<'GAI_CONF'
/etc/gai.conf
GAI_CONF

    if [ "$ipv6" = 1 ]; then
        __loc_delete;
    else
        FILE \
<<'GAI_CONF'
precedence ::ffff:0:0/96  100
GAI_CONF

        __file_write_overwrite;
    fi
}

_git_conf() {
    FILE_PATH \
<<_GITCONFIG
$home/.gitconfig
_GITCONFIG

    FILE \
<<'_GITCONFIG'
[core]
	editor = nano
[credential]
	helper = cache --timeout=86400
[http]
	version = HTTP/2
[merge]
	log = 10000
[rerere]
	enabled = true
[sendemail]
        smtpuser = mscalindt@gmail.com
	smtpserver = smtp.gmail.com
	smtpencryption = tls
	smtpserverport = 587
[user]
	email = mscalindt@protonmail.com
	name = Dimitar Yurukov
	signingkey = 7D1F56FAD6FB86652A60BEE65BC3343816EAB179
[commit]
	gpgsign = 1
[color "diff"]
	old = red
	new = yellow
_GITCONFIG

    __file_write;
}

_gov_performance() {
    FILE_PATH \
<<'CPU'
/sys/devices/system/cpu
CPU

    if ! exist "$FILE_PATH"/cpu0/cpufreq/scaling_governor; then
        ENOENT;
        err -r -- 'F '; err - - "$FILE_PATH"/cpu0/cpufreq/scaling_governor
        exit 202
    fi

    for core in "$FILE_PATH"/cpu*/cpufreq/scaling_governor; do
        FILE_PATH \
<<SCALING_GOVERNOR
$core
SCALING_GOVERNOR

        FILE \
<<'SCALING_GOVERNOR'
performance
SCALING_GOVERNOR

        __file_write_overwrite;

        if ! file_equiv "$FILE_PATH" "$FILE"; then
            EERROR 'Failed to set the governor:'
            err -r -- 'F '; err - - "$FILE_PATH"
        fi
    done
}

_gov_schedutil() {
    FILE_PATH \
<<'CPU'
/sys/devices/system/cpu
CPU

    if ! exist "$FILE_PATH"/cpu0/cpufreq/scaling_governor; then
        ENOENT;
        err -r -- 'F '; err - - "$FILE_PATH"/cpu0/cpufreq/scaling_governor
        exit 202
    fi

    for core in "$FILE_PATH"/cpu*/cpufreq/scaling_governor; do
        FILE_PATH \
<<SCALING_GOVERNOR
$core
SCALING_GOVERNOR

        FILE \
<<'SCALING_GOVERNOR'
schedutil
SCALING_GOVERNOR

        __file_write_overwrite;

        if ! file_equiv "$FILE_PATH" "$FILE"; then
            EERROR 'Failed to set the governor:'
            err -r -- 'F '; err - - "$FILE_PATH"
        fi
    done
}

# "Removable" GRUB UEFI installation (NVRAM-less... when no NVRAM entries)
_grub() {
    is_uefi || EERROR 'Not in UEFI mode.'
    cmd 'grub-install' || ENOCMD 'grub-install'
    cmd 'grub-mkconfig' || ENOCMD 'grub-mkconfig'

    if [ "$force" = 1 ]; then
        set -- "$efi_mnt"/*

        if exist "$1"; then
            if [ "$logging" = 1 ]; then
                info -w -1 'Will delete:'
                for arg in "$@"; do
                    if [ -d "$arg" ]; then
                        info -w -- 'D '
                    elif [ -f "$arg" ]; then
                        info -w -- 'F '
                    else
                        info -w -- '> '
                    fi
                    info - - "$arg"
                done
            fi

            if [ "$logging" = 1 ]; then
                if ! rm -rf "$@"; then
                    errF 235 - 'rm: Failed.'
                fi
            else
                if ! rm -rf "$@" > /dev/null 2>&1; then
                    errF 235 - 'rm: Failed.'
                fi
            fi
        fi
    fi

    if [ "$logging" = 1 ]; then
        info -w - 'grub-install:'

        if ! grub-install --target=x86_64-efi \
                          --efi-directory="$efi_mnt" \
                          --boot-directory="$efi_mnt"/EFI/BOOT \
                          --removable \
                          --no-nvram; then
            errF 235 - 'grub-install: Failed.'
        fi

        info -w - 'grub-mkconfig:'

        if ! grub-mkconfig -o "$efi_mnt"/EFI/BOOT/grub/grub.cfg; then
            errF 235 - 'grub-mkconfig: Failed.'
        fi
    else
        if ! grub-install --target=x86_64-efi \
                          --efi-directory="$efi_mnt" \
                          --boot-directory="$efi_mnt"/EFI/BOOT \
                          --removable \
                          --no-nvram > /dev/null 2>&1; then
            errF 235 - 'grub-install: Failed.'
        fi

        if ! grub-mkconfig -o "$efi_mnt"/EFI/BOOT/grub/grub.cfg \
             > /dev/null 2>&1; then
            errF 235 - 'grub-mkconfig: Failed.'
        fi
    fi
}

# To simulate a config file, we drop-in our replacement of /etc/default/grub,
# even though this shall usually only be done in a predefined environment
# (such as ours: 'syscfg grub grub-conf')
#
# As indicated by the above statement, GRUB is old and rather fixed on its
# configuration; that is, it does not provide the same flexibility as, for
# example, the configuration of rEFInd. rEFInd should be considered as a
# replacement.
_grub_conf() {
    is_uefi || EERROR 'Not in UEFI mode.'
    cmd 'grub-mkconfig' || ENOCMD 'grub-mkconfig'

    FILE_PATH \
<<'GRUB'
/etc/default/grub
GRUB

    FILE \
<<'GRUB'
GRUB_PRELOAD_MODULES="part_gpt"
GRUB_TIMEOUT_STYLE=menu
GRUB_TERMINAL_INPUT=console
GRUB_GFXMODE=auto
GRUB_GFXPAYLOAD_LINUX=keep
GRUB_DISABLE_RECOVERY=true
GRUB_DISABLE_OS_PROBER=false

GRUB_DEFAULT=0
GRUB_TIMEOUT=5
GRUB_CMDLINE_LINUX="\
loglevel=3 nowatchdog mitigations=off processor.ignore_ppc=1 \
usbhid.mousepoll=1 tsc=unstable \
GRUB

    if [ "$ipv6" != 1 ]; then
        FILE \
<<'GRUB'
ipv6.disable=1 \
GRUB
    fi

    FILE \
<<'GRUB'
"
GRUB

    if [ "$arch_linux" = 1 ]; then
        FILE \
<<'GRUB'
GRUB_DISTRIBUTOR="Arch"
GRUB
    fi

    __file_write_overwrite;

    if [ "$logging" = 1 ]; then
        info -w - 'grub-mkconfig:'

        if ! grub-mkconfig -o "$efi_mnt"/EFI/BOOT/grub/grub.cfg; then
            errF 235 - 'grub-mkconfig: Failed.'
        fi
    else
        if ! grub-mkconfig -o "$efi_mnt"/EFI/BOOT/grub/grub.cfg \
             > /dev/null 2>&1; then
            errF 235 - 'grub-mkconfig: Failed.'
        fi
    fi
}

_gtk_conf() {
    FILE_PATH \
<<_GTKRC_2_0
$home/.gtkrc-2.0
_GTKRC_2_0

    FILE \
<<'_GTKRC_2_0'
gtk-cursor-theme-name="Breeze"
gtk-icon-theme-name="Papirus-Dark"
gtk-theme-name="Arc-Dark-solid"
gtk-font-name="Cantarell 12"
gtk-document-font-name="DejaVu Serif 12"
gtk-monospace-font-name="Cantarell 12"
gtk-cursor-theme-size=0
gtk-application-prefer-dark-theme=true
gtk-enable-primary-paste=false
gtk-toolbar-style=GTK_TOOLBAR_ICONS
gtk-toolbar-icon-size=GTK_ICON_SIZE_LARGE_TOOLBAR
gtk-button-images=1
gtk-menu-images=1
gtk-enable-event-sounds=0
gtk-enable-input-feedback-sounds=0
gtk-xft-antialias=1
gtk-xft-hinting=1
gtk-xft-hintstyle=hintfull
gtk-xft-rgba=rgb
_GTKRC_2_0

    __file_write;

    FILE_PATH \
<<GTK_CSS
$home/.config/gtk-3.0/gtk.css
GTK_CSS

    FILE \
<<'GTK_CSS'
.titlebar,
window {
	border-radius: 0;
	box-shadow: none;
}

decoration {
	box-shadow: none;
}

decoration:backdrop {
	box-shadow: none;
}
GTK_CSS

    __file_write;

    FILE_PATH \
<<SETTINGS_INI
$home/.config/gtk-3.0/settings.ini
SETTINGS_INI

    FILE \
<<'SETTINGS_INI'
[Settings]
gtk-cursor-theme-name="Breeze"
gtk-icon-theme-name="Papirus-Dark"
gtk-theme-name="Arc-Dark-solid"
gtk-font-name="Cantarell 12"
gtk-document-font-name="DejaVu Serif 12"
gtk-monospace-font-name="Cantarell 12"
gtk-cursor-theme-size=0
gtk-application-prefer-dark-theme=true
gtk-enable-primary-paste=false
gtk-toolbar-style=GTK_TOOLBAR_ICONS
gtk-toolbar-icon-size=GTK_ICON_SIZE_LARGE_TOOLBAR
gtk-button-images=1
gtk-menu-images=1
gtk-enable-event-sounds=0
gtk-enable-input-feedback-sounds=0
gtk-xft-antialias=1
gtk-xft-hinting=1
gtk-xft-hintstyle=hintfull
gtk-xft-rgba=rgb
SETTINGS_INI

    __file_write;
}

_hostname() {
    if [ "$m533ia" != 1 ]; then
        info -w -1 'Nothing to be done.'
        return 0
    fi

    FILE_PATH \
<<'HOSTNAME'
/etc/hostname
HOSTNAME

    FILE \
<<'HOSTNAME'
m533ia
HOSTNAME

    __file_write;
}

_hosts() {
    FILE_PATH \
<<'HOSTS'
/etc/hosts
HOSTS

    if [ "$ipv6" = 1 ]; then
        FILE \
<<'HOSTS'
::1              localhost
127.0.0.1        localhost
HOSTS
    else
        FILE \
<<'HOSTS'
127.0.0.1        localhost
HOSTS
    fi

    if [ "$m533ia" = 1 ]; then
        FILE \
<<'HOSTS'
127.0.1.1        m533ia
HOSTS
    fi

    __file_write;
}

_imv_conf() {
    FILE_PATH \
<<CONFIG
$home/.config/imv/config
CONFIG

    FILE \
<<'CONFIG'
[options]
background = 696969
CONFIG

    __file_write;
}

_initramfs_conf() {
    if [ "$arch_linux" != 1 ]; then
        info -w -1 'Nothing to be done.'
        return 0
    fi

    cmd 'mkinitcpio' || ENOCMD 'mkinitcpio'

    FILE_PATH \
<<'MKINITCPIO_CONF'
/etc/mkinitcpio.conf
MKINITCPIO_CONF

    if [ "$m533ia" = 1 ]; then
        FILE \
<<'MKINITCPIO_CONF'
MODULES=(amdgpu pinctrl-amd)
MKINITCPIO_CONF
    else
        FILE \
<<'MKINITCPIO_CONF'
MODULES=()
MKINITCPIO_CONF
    fi

    FILE \
<<'MKINITCPIO_CONF'
BINARIES=()
FILES=()
HOOKS=(base udev autodetect microcode modconf keyboard block filesystems fsck)
MODULES_DECOMPRESS="yes"
MKINITCPIO_CONF

    __file_write_overwrite;

    if [ "$logging" = 1 ]; then
        info -w - 'mkinitcpio:'

        if ! mkinitcpio -P; then
            errF 235 - 'mkinitcpio: Failed to regenerate initramfs.'
        fi
    else
        if ! mkinitcpio -P > /dev/null 2>&1; then
            errF 235 - 'mkinitcpio: Failed to regenerate initramfs.'
        fi
    fi
}

_iwd_conf() {
    FILE_PATH \
<<'MAIN_CONF'
/etc/iwd/main.conf
MAIN_CONF

    FILE \
<<'MAIN_CONF'
[General]
EnableNetworkConfiguration=true
AddressRandomization=network
AddressRandomizationRange=nic

[Network]
MAIN_CONF

    if [ "$ipv6" = 1 ]; then
        FILE \
<<'MAIN_CONF'
EnableIPv6=true
MAIN_CONF
    else
        FILE \
<<'MAIN_CONF'
EnableIPv6=false
MAIN_CONF
    fi

    FILE \
<<'MAIN_CONF'
NameResolvingService=none

[Scan]
DisablePeriodicScan=true
MAIN_CONF

    __file_write;
}

_kitty_conf() {
    FILE_PATH \
<<KITTY_CONF
$home/.config/kitty/kitty.conf
KITTY_CONF

    FILE \
<<'KITTY_CONF'
font_family Source Code Pro
font_size 10.0
cursor_text_color background
cursor_shape beam
cursor_beam_thickness 1.0
cursor_stop_blinking_after 0.0
scrollback_lines 300000
wheel_scroll_multiplier 3.0
mouse_hide_wait 0.0
url_color #FFFFFF
url_style single
select_by_word_characters -A-Za-z0-9,./?%&#:_=+@~
enable_audio_bell no
remember_window_size no
initial_window_width 814
initial_window_height 498
hide_window_decorations yes
background_opacity 0.5
update_check_interval 0
shell_integration disabled
confirm_os_window_close 0
color0 #767676
color1 #f2201f
color2 #23fd00
color3 #fffd00
color4 #1a8fff
color5 #fd28ff
color6 #14ffff
color7 #ffffff
background #300924
map kitty_mod+a scroll_page_up
map kitty_mod+s scroll_page_down
map kitty_mod+z scroll_home
map kitty_mod+x scroll_end
KITTY_CONF

    __file_write;
}

_kvantum_conf() {
    FILE_PATH \
<<KVANTUM_KVCONFIG
$home/.config/Kvantum/kvantum.kvconfig
KVANTUM_KVCONFIG

    FILE \
<<'KVANTUM_KVCONFIG'
[General]
theme=KvArcDark#
KVANTUM_KVCONFIG

    __file_write;

    FILE_PATH \
<<KVARCDARK__KVCONFIG
$home/.config/Kvantum/KvArcDark#/KvArcDark#.kvconfig
KVARCDARK__KVCONFIG

    FILE \
<<'KVARCDARK__KVCONFIG'
[%General]
author=Tsu Jan
comment=A minimalistic dark theme inspired by the Arc GTK theme
x11drag=menubar_and_primary_toolbar
alt_mnemonic=true
left_tabs=true
attach_active_tab=true
mirror_doc_tabs=true
group_toolbar_buttons=false
toolbar_item_spacing=1
toolbar_interior_spacing=3
spread_progressbar=true
composite=false
menu_shadow_depth=5
menu_separator_height=6
tooltip_shadow_depth=6
splitter_width=4
scroll_width=9
scroll_arrows=false
scroll_min_extent=60
slider_width=6
slider_handle_width=18
slider_handle_length=18
center_toolbar_handle=true
check_size=14
textless_progressbar=false
progressbar_thickness=3font
menubar_mouse_tracking=true
toolbutton_style=0
click_behavior=0
translucent_windows=false
blurring=false
popup_blurring=false
vertical_spin_indicators=false
spin_button_width=32
fill_rubberband=false
merge_menubar_with_toolbar=true
small_icon_size=16
large_icon_size=32
button_icon_size=16
toolbar_icon_size=22
combo_as_lineedit=true
animate_states=false
combo_menu=true
hide_combo_checkboxes=true
combo_focus_rect=true
groupbox_top_label=true
inline_spin_indicators=false
joined_inactive_tabs=false
layout_spacing=6
layout_margin=9
scrollbar_in_view=true
transient_scrollbar=true
transient_groove=true
submenu_overlap=3
tooltip_delay=-1
tree_branch_line=true
dark_titlebar=true
contrast=1.00
dialog_button_layout=0
drag_from_buttons=false
intensity=1.00
menu_blur_radius=0
no_inactiveness=false
no_window_pattern=false
opaque=kaffeine,kmplayer,subtitlecomposer,kdenlive,vlc,smplayer,smplayer2,avidemux,avidemux2_qt4,avidemux3_qt4,avidemux3_qt5,kamoso,QtCreator,VirtualBox,VirtualBoxVM,trojita,dragon,digikam,lyx
reduce_menu_opacity=0
reduce_window_opacity=0
respect_DE=true
saturation=1.00
scrollable_menu=true
shadowless_popup=false
submenu_delay=250
tooltip_blur_radius=0

[GeneralColors]
window.color=#383c4a
base.color=#404552
alt.base.color=#3c434f
button.color=#414654
light.color=#5f677f
mid.light.color=#313131
dark.color=black
mid.color=#191919
highlight.color=#5294e2
inactive.highlight.color=#5294e2
text.color=#ffffffc8
window.text.color=#ffffffc8
button.text.color=#ffffffc8
disabled.text.color=#ffffff73
tooltip.text.color=#eefcff
highlight.text.color=white
link.color=#009DFF
link.visited.color=#9E4FFF
progress.indicator.text.color=white

[Hacks]
transparent_ktitle_label=false
transparent_dolphin_view=false
transparent_pcmanfm_sidepane=false
blur_translucent=false
transparent_menutitle=false
respect_darkness=true
force_size_grip=true
iconless_pushbutton=true
iconless_menu=false
disabled_icon_opacity=100
lxqtmainmenu_iconsize=22
normal_default_pushbutton=true
single_top_toolbar=true
tint_on_mouseover=0
transparent_pcmanfm_view=false
blur_only_active_window=false
centered_forms=false
kinetic_scrolling=false
middle_click_scroll=false
no_selection_tint=false
noninteger_translucency=false
style_vertical_toolbars=false

[PanelButtonCommand]
frame=true
frame.element=button
frame.top=3
frame.bottom=3
frame.left=3
frame.right=3
interior=true
interior.element=button
indicator.size=9
text.normal.color=#ffffffc8
text.focus.color=white
text.press.color=white
text.toggle.color=white
text.shadow=0
text.margin=1
text.iconspacing=4
indicator.element=arrow
text.margin.top=2
text.margin.bottom=2
text.margin.left=2
text.margin.right=2
min_width=+0.3font
min_height=+0.3font
frame.expansion=6

[PanelButtonTool]
inherits=PanelButtonCommand

[Dock]
inherits=PanelButtonCommand
interior.element=dock
frame.element=dock
frame.top=1
frame.bottom=1
frame.left=1
frame.right=1
text.normal.color=#ffffffc8

[DockTitle]
inherits=PanelButtonCommand
frame=false
interior=false
text.normal.color=#ffffff96
text.focus.color=white
text.bold=true

[IndicatorSpinBox]
inherits=PanelButtonCommand
frame=true
interior=true
frame.left=1
indicator.element=spin
indicator.size=10
text.normal.color=#ffffffc8

[RadioButton]
inherits=PanelButtonCommand
frame=false
interior.element=radio
text.normal.color=#ffffffc8
text.focus.color=white

[CheckBox]
inherits=PanelButtonCommand
frame=false
interior.element=checkbox
text.normal.color=#ffffffc8
text.focus.color=white

[Focus]
inherits=PanelButtonCommand
frame=true
frame.element=focus
frame.top=1
frame.bottom=1
frame.left=1
frame.right=1
frame.patternsize=20

[GenericFrame]
inherits=PanelButtonCommand
frame=true
interior=false
frame.element=common
interior.element=common
frame.top=3
frame.bottom=3
frame.left=3
frame.right=3

[LineEdit]
inherits=PanelButtonCommand
frame.element=lineedit
interior.element=lineedit
text.margin.left=1
text.margin.right=1

[DropDownButton]
inherits=PanelButtonCommand
indicator.element=arrow-down

[IndicatorArrow]
indicator.element=arrow
indicator.size=9

[ToolboxTab]
inherits=PanelButtonCommand
text.normal.color=#ffffffc8
text.press.color=#ffffff96
text.focus.color=white

[Tab]
inherits=PanelButtonCommand
interior.element=tab
text.margin.left=8
text.margin.right=8
text.margin.top=2
text.margin.bottom=2
frame.element=tab
indicator.element=tab
frame.top=4
frame.bottom=4
frame.left=4
frame.right=4
text.normal.color=#ffffff78
text.focus.color=#ffffffb4
text.toggle.color=#ffffffd2
frame.expansion=0

[TabFrame]
inherits=PanelButtonCommand
frame.element=tabframe
interior.element=tabframe
frame.top=4
frame.bottom=4
frame.left=4
frame.right=4

[TreeExpander]
inherits=PanelButtonCommand
indicator.size=12
indicator.element=tree

[HeaderSection]
inherits=PanelButtonCommand
interior.element=header
frame.element=header
frame.top=3
frame.bottom=3
frame.left=1
frame.right=1
text.bold=true
text.normal.color=#ffffff96
text.focus.color=#5796e8
text.toggle.color=white
frame.expansion=0

[SizeGrip]
indicator.element=resize-grip

[Toolbar]
inherits=PanelButtonCommand
indicator.element=toolbar
indicator.size=5
text.margin=0
frame=false
interior.element=menubar
frame.element=menubar
text.normal.color=#ffffffc8
text.focus.color=white
frame.bottom=0
frame.expansion=0

[Slider]
inherits=PanelButtonCommand
frame.element=slider
interior.element=slider
frame.top=3
frame.bottom=3
frame.left=3
frame.right=3

[SliderCursor]
inherits=PanelButtonCommand
frame=false
interior.element=slidercursor

[Progressbar]
inherits=PanelButtonCommand
frame.element=progress
interior.element=progress
text.margin=0
text.normal.color=#ffffffc8
text.focus.color=white
text.press.color=white
text.toggle.color=white
text.bold=false
frame.expansion=8

[ProgressbarContents]
inherits=PanelButtonCommand
frame=true
frame.element=progress-pattern
interior.element=progress-pattern

[ItemView]
inherits=PanelButtonCommand
text.margin=0
frame.element=itemview
interior.element=itemview
frame.top=2
frame.bottom=2
frame.left=2
frame.right=2
text.margin.top=2
text.margin.bottom=2
text.margin.left=4
text.margin.right=4
text.normal.color=#ffffffc8
text.focus.color=white
text.press.color=white
text.toggle.color=white
frame.expansion=0

[Splitter]
indicator.size=48

[Scrollbar]
inherits=PanelButtonCommand
indicator.element=arrow
indicator.size=10

[ScrollbarSlider]
inherits=PanelButtonCommand
frame.element=scrollbarslider
interior=false
frame.left=6
frame.right=6
frame.top=6
frame.bottom=6
indicator.element=grip
indicator.size=13
frame.expansion=48

[ScrollbarGroove]
inherits=PanelButtonCommand
interior=false
frame=false

[MenuItem]
inherits=PanelButtonCommand
frame=true
frame.element=menuitem
interior.element=menuitem
indicator.element=menuitem
text.normal.color=#ffffffc8
text.focus.color=white
text.margin.top=1
text.margin.bottom=1
text.margin.left=15
text.margin.right=5
frame.top=3
frame.bottom=3
frame.left=3
frame.right=3
frame.expansion=0

[MenuBar]
inherits=PanelButtonCommand
frame.element=menubar
interior.element=menubar
frame.bottom=0
frame.expansion=0

[MenuBarItem]
inherits=PanelButtonCommand
interior=true
interior.element=menubaritem
frame.element=menubaritem
frame.top=2
frame.bottom=2
frame.left=2
frame.right=2
text.margin.left=4
text.margin.right=4
text.margin.top=0
text.margin.bottom=0
text.normal.color=#000000b4
text.focus.color=white
frame.expansion=0

[TitleBar]
inherits=PanelButtonCommand
frame=false
interior.element=titlebar
indicator.size=12
indicator.element=mdi
text.normal.color=#787878
text.focus.color=white
text.bold=true
text.italic=true
frame.expansion=0

[ComboBox]
inherits=PanelButtonCommand
interior.element=combo
frame.element=combo
text.press.color=#ffffffc8
indicator.element=carrow

[Menu]
inherits=PanelButtonCommand
frame.top=1
frame.bottom=1
frame.left=1
frame.right=1
frame.element=menu
interior.element=menu
text.normal.color=#ffffffc8
text.shadow=false
frame.expansion=0

[GroupBox]
inherits=GenericFrame
frame=false
text.shadow=0
text.margin=0
text.normal.color=#ffffff96
text.focus.color=white
text.bold=true
frame.expansion=0

[TabBarFrame]
inherits=GenericFrame
frame=true
frame.element=tabBarFrame
interior=false
frame.top=4
frame.bottom=4
frame.left=4
frame.right=4

[ToolTip]
inherits=GenericFrame
frame.top=3
frame.bottom=3
frame.left=3
frame.right=3
interior=true
text.shadow=0
text.margin=0
interior.element=tooltip
frame.element=tooltip
frame.expansion=0

[StatusBar]
inherits=GenericFrame
frame=false
interior=false

[Window]
interior=true
interior.element=window
KVARCDARK__KVCONFIG

    __file_write;
}

# English locale config
_locale() {
    cmd 'locale-gen' || ENOCMD 'locale-gen'

    FILE_PATH \
<<'LOCALE_CONF'
/etc/locale.conf
LOCALE_CONF

    FILE \
<<'LOCALE_CONF'
LANG=en_US.UTF-8
LOCALE_CONF

    __file_write;

    FILE_PATH \
<<'LOCALE_GEN'
/etc/locale.gen
LOCALE_GEN

    FILE \
<<'LOCALE_GEN'
bg_BG.UTF-8 UTF-8
en_US.UTF-8 UTF-8
LOCALE_GEN

    __file_write;

    if [ "$logging" = 1 ]; then
        info -w - 'locale-gen:'

        if ! locale-gen; then
            errF 235 - 'locale-gen: Failed to generate locales.'
        fi
    else
        if ! locale-gen > /dev/null 2>&1; then
            errF 235 - 'locale-gen: Failed to generate locales.'
        fi
    fi
}

_makepkg_conf() {
    if [ "$arch_linux" != 1 ]; then
        info -w -1 'Nothing to be done.'
        return 0
    fi

    FILE_PATH \
<<'MAKEPKG_CONF'
/etc/makepkg.conf
MAKEPKG_CONF

    libfile ~~~1 \
            ' -O2 -pipe -fno-plt -fexceptions \' \
            'CFLAGS="-march=x86-64 -mtune=' \
            'CFLAGS="-march=x86-64 -mtune=native -O2 -pipe -fno-plt -fexceptions \' \
            ~~3 \
            'MAKEFLAGS="-j' \
            'MAKEFLAGS="-j6"'

    __file_write_overwrite;
}

_moc_conf() {
    FILE_PATH \
<<CONFIG
$home/.moc/config
CONFIG

    FILE \
<<'CONFIG'
SoundDriver = ALSA
Theme = transparent-background
CONFIG

    __file_write;
}

# Fix pop on idle resume
_modprobe_conf() {
    FILE_PATH \
<<'99_SND_POWERSAVE_CONF'
/etc/modprobe.d/99-snd_powersave.conf
99_SND_POWERSAVE_CONF

    FILE \
<<'99_SND_POWERSAVE_CONF'
options snd_hda_intel power_save=0 power_save_controller=N
99_SND_POWERSAVE_CONF

    __file_write;
}

_mpv_conf() {
    FILE_PATH \
<<MPV_CONF
$home/.config/mpv/mpv.conf
MPV_CONF

    FILE \
<<'MPV_CONF'
profile=gpu-hq
scale=ewa_lanczossharp
cscale=ewa_lanczossharp
override-display-fps=60
video-sync=display-resample
interpolation=yes
tscale=oversample
hwdec=auto
border=no
msg-color=yes
cursor-autohide=1000
screenshot-template="%F - [%P]v%#01n"
save-position-on-quit=yes
alang=en
slang=en
sub-auto=fuzzy
sub-bold=yes
MPV_CONF

    __file_write;
}

_mutt_conf() {
    FILE_PATH \
<<MUTTRC
$home/.mutt/muttrc
MUTTRC

    FILE \
<<'MUTTRC'
# Personal
set realname = "Dimitar Yurukov"
set from = "mscalindt@gmail.com"

# SMTP
set smtp_url = "smtps://mscalindt@smtp.gmail.com"
set ssl_force_tls = yes

# IMAP
set imap_user = "mscalindt@gmail.com"
set folder = "imaps://imap.gmail.com"
set spoolfile = "imaps://imap.gmail.com/INBOX"

# Settings
set signature="~/.mutt/muttsig"
set send_charset="us-ascii:utf-8"
set charset = UTF-8
set edit_headers = yes
set use_from = yes
set envelope_from = yes
unset use_domain

# Keybindings
bind index "^" imap-fetch-mail
MUTTRC

    __file_write;

    FILE_PATH \
<<MUTTSIG
$home/.mutt/muttsig
MUTTSIG

    FILE \
<<'MUTTSIG'
PGP: https://github.com/mscalindt.gpg
Email: mscalindt@gmail.com
MUTTSIG

    __file_write;
}

_nano_conf() {
    FILE_PATH \
<<_NANORC
$home/.nanorc
_NANORC

    FILE \
<<'_NANORC'
set fill 72
set breaklonglines
_NANORC

    __file_write;
}

# Delete all boot entries (UEFI)
_nvram_clr() {
    is_uefi || EERROR 'Not in UEFI mode.'

    set -- '/sys/firmware/efi/efivars'/Boot0*

    if ! exist "$1"; then
        info -w -1 'No valid entries have been found.'
        return 0
    fi

    set -- '/sys/firmware/efi/efivars'/Boot*

    if cmd 'chattr'; then
        if [ "$logging" = 1 ]; then
            if ! chattr -ia "$@"; then
                EFSFLAG "$@"
            fi
        else
            if ! chattr -ia "$@" > /dev/null 2>&1; then
                EFSFLAG "$@"
            fi
        fi
    fi

    if [ "$logging" = 1 ]; then
        info -w -1 'Will delete:'
        printf "%s\n" '/sys/firmware/efi/efivars'/BootOrder*
        printf "%s\n" '/sys/firmware/efi/efivars'/Boot0*
    fi

    if [ "$logging" = 1 ]; then
        if ! rm -f '/sys/firmware/efi/efivars'/BootOrder* \
                   '/sys/firmware/efi/efivars'/Boot0*; then
            errF 235 - 'rm: Failed.'
        fi
    else
        if ! rm -f '/sys/firmware/efi/efivars'/BootOrder* \
                   '/sys/firmware/efi/efivars'/Boot0* > /dev/null 2>&1; then
            errF 235 - 'rm: Failed.'
        fi
    fi

    set -- '/sys/firmware/efi/efivars'/Boot0*

    if exist "$1"; then
        EERROR 'Entry removal failed.'
    fi

    info -w -1 'The entries were removed; firmware will attempt recovery.'
}

_openal_conf() {
    FILE_PATH \
<<'ALSOFT_CONF'
/etc/openal/alsoft.conf
ALSOFT_CONF

    FILE \
<<'ALSOFT_CONF'
frequency = 48000
ALSOFT_CONF

    __file_write;
}

_pacman_conf() {
    if [ "$arch_linux" != 1 ]; then
        info -w -1 'Nothing to be done.'
        return 0
    fi

    FILE_PATH \
<<'PACMAN_CONF'
/etc/pacman.conf
PACMAN_CONF

    libfile ~~3 \
            'Color' \
            'Color' \
            ~~3 \
            'ParallelDownloads' \
            'ParallelDownloads = 5' \
            ~~3 \
            'VerbosePkgLists' \
            'VerbosePkgLists'

    FILE=$(
        line_add() {
            while IFS= read -r line; do
                i=$((i + 1))

                if [ "$logging" = 1 ]; then
                    LOG_write 1 "$i" "$line"
                fi

                printf "%s\n" "$line"
            done <<EOF
$1
EOF
        }

        line_replace() {
            l=0; while IFS= read -r line; do
                l=$((l + 1))

                if [ "$l" -ne 1 ]; then
                    i=$((i + 1))
                fi

                if [ "$logging" = 1 ]; then
                    if [ "$l" -eq 1 ]; then
                        if [ "$LINE" != "$line" ]; then
                            LOG_write 3 "$i" "$LINE" "$line"
                        fi
                    else
                        LOG_write 1 "$i" "$line"
                    fi
                fi

                printf "%s\n" "$line"
            done <<EOF
$1
EOF
        }

        case "${FILE#"${FILE%??}"}" in
            "$LF$LF") : ;;
            *"$LF") FILE="$FILE$LF" ;;
            *) FILE="$FILE$LF$LF" ;;
        esac

        _FLAG_MLIB=0; FLAG_MLIB=0

        i=0; printf "%s" "$FILE" | { while IFS= read -r LINE; do
            i=$((i + 1))

            if [ "$_FLAG_MLIB" = 1 ]; then
                _FLAG_MLIB=0

                case "$LINE" in
                    *'Include = '*)
                        line_replace "Include = $arch_mirlist"
                    ;;
                    *)
                        line_add "Include = $arch_mirlist"
                    ;;
                esac

                continue
            fi

            case "$LINE" in
                *'[multilib]'*)
                    FLAG_MLIB=1; _FLAG_MLIB=1

                    line_replace '[multilib]'

                    continue
                ;;
            esac

            printf "%s\n" "$LINE"
        done

        while :; do
            if [ "$FLAG_MLIB" = 0 ]; then
                FLAG_MLIB=1

                line_add '[multilib]'
                line_add "Include = $arch_mirlist"
            else
                break
            fi
        done; }
    ); FILE="$FILE$LF"

    __file_write_overwrite;
}

_pam_conf() {
    FILE_PATH \
<<'FAILLOCK_CONF'
/etc/security/faillock.conf
FAILLOCK_CONF

    FILE \
<<'FAILLOCK_CONF'
deny=7
even_deny_root
nodelay
root_unlock_time=8400
unlock_time=600
FAILLOCK_CONF

    __file_write_overwrite;

    FILE_PATH \
<<'LOGIN_DEFS'
/etc/login.defs
LOGIN_DEFS

    libfile ~1 \
            'FAIL_DELAY' \
            'FAIL_DELAY 0'

    __file_write_overwrite;

    FILE_PATH \
<<'SU'
/etc/pam.d/su
SU

    __FILE_PATH_preload;

    FILE=$(
        line_replace() {
            l=0; while IFS= read -r line; do
                l=$((l + 1))

                if [ "$l" -ne 1 ]; then
                    i=$((i + 1))
                fi

                if [ "$logging" = 1 ]; then
                    if [ "$l" -eq 1 ]; then
                        if [ "$LINE" != "$line" ]; then
                            LOG_write 3 "$i" "$LINE" "$line"
                        fi
                    else
                        LOG_write 1 "$i" "$line"
                    fi
                fi

                printf "%s\n" "$line"
            done <<EOF
$1
EOF
        }

        case "${FILE#"${FILE%??}"}" in
            "$LF$LF") : ;;
            *"$LF") FILE="$FILE$LF" ;;
            *) FILE="$FILE$LF$LF" ;;
        esac

        i=0; printf "%s" "$FILE" | while IFS= read -r LINE; do
            i=$((i + 1))

            case "$LINE" in
                'auth'*'pam_unix.so'*)
                    case "$LINE" in
                        *'nodelay'*)
                            printf "%s\n" "$LINE"

                            continue
                        ;;
                    esac

                    line_replace "${LINE} nodelay"

                    continue
                ;;
            esac

            printf "%s\n" "$LINE"
        done
    ); FILE="$FILE$LF"

    __file_write_overwrite;

    FILE_PATH \
<<'SYSTEM_AUTH'
/etc/pam.d/system-auth
SYSTEM_AUTH

    __FILE_PATH_preload;

    FILE=$(
        line_replace() {
            l=0; while IFS= read -r line; do
                l=$((l + 1))

                if [ "$l" -ne 1 ]; then
                    i=$((i + 1))
                fi

                if [ "$logging" = 1 ]; then
                    if [ "$l" -eq 1 ]; then
                        if [ "$LINE" != "$line" ]; then
                            LOG_write 3 "$i" "$LINE" "$line"
                        fi
                    else
                        LOG_write 1 "$i" "$line"
                    fi
                fi

                printf "%s\n" "$line"
            done <<EOF
$1
EOF
        }

        case "${FILE#"${FILE%??}"}" in
            "$LF$LF") : ;;
            *"$LF") FILE="$FILE$LF" ;;
            *) FILE="$FILE$LF$LF" ;;
        esac

        i=0; printf "%s" "$FILE" | while IFS= read -r LINE; do
            i=$((i + 1))

            case "$LINE" in
                'auth'*'pam_unix.so'*)
                    case "$LINE" in
                        *'nodelay'*)
                            printf "%s\n" "$LINE"

                            continue
                        ;;
                    esac

                    line_replace "${LINE} nodelay"

                    continue
                ;;
            esac

            printf "%s\n" "$LINE"
        done
    ); FILE="$FILE$LF"

    __file_write_overwrite;
}

_pipewire_conf() {
    FILE_PATH \
<<'CLIENT_CONF'
/etc/pipewire/client.conf.d/client.conf
CLIENT_CONF

    if [ "$audio_hq" = 1 ]; then
        FILE \
<<'CLIENT_CONF'
stream.properties = {
    resample.quality = 15
}
CLIENT_CONF
    else
        FILE \
<<'CLIENT_CONF'
stream.properties = {
    resample.quality = 11
}
CLIENT_CONF
    fi

    __file_write;

    FILE_PATH \
<<'CLIENT_RT_CONF'
/etc/pipewire/client-rt.conf.d/client-rt.conf
CLIENT_RT_CONF

    if [ "$audio_hq" = 1 ]; then
        FILE \
<<'CLIENT_RT_CONF'
stream.properties = {
    resample.quality = 15
}
CLIENT_RT_CONF
    else
        FILE \
<<'CLIENT_RT_CONF'
stream.properties = {
    resample.quality = 11
}
CLIENT_RT_CONF
    fi

    __file_write;

    FILE_PATH \
<<'MINIMAL_CONF'
/etc/pipewire/minimal.conf.d/minimal.conf
MINIMAL_CONF

    FILE \
<<'MINIMAL_CONF'
context.properties = {
    default.clock.allowed-rates = [ 44100 48000 96000 192000 ]
}
MINIMAL_CONF

    if [ "$audio_hq" = 1 ]; then
        FILE \
<<'MINIMAL_CONF'
context.objects = [
    { factory = adapter
        args = {
            resample.quality = 15
        }
    }
]
MINIMAL_CONF
    else
        FILE \
<<'MINIMAL_CONF'
context.objects = [
    { factory = adapter
        args = {
            resample.quality = 11
        }
    }
]
MINIMAL_CONF
    fi

    __file_write;

    FILE_PATH \
<<'PIPEWIRE_CONF'
/etc/pipewire/pipewire.conf.d/pipewire.conf
PIPEWIRE_CONF

    FILE \
<<'PIPEWIRE_CONF'
context.properties = {
    default.clock.allowed-rates = [ 44100 48000 96000 192000 ]
}
PIPEWIRE_CONF

    __file_write;

    FILE_PATH \
<<'PIPEWIRE_AVB_CONF'
/etc/pipewire/pipewire-pulse.conf.d/pipewire-avb.conf
PIPEWIRE_AVB_CONF

    if [ "$audio_hq" = 1 ]; then
        FILE \
<<'PIPEWIRE_AVB_CONF'
stream.properties = {
    resample.quality = 15
}
PIPEWIRE_AVB_CONF
    else
        FILE \
<<'PIPEWIRE_AVB_CONF'
stream.properties = {
    resample.quality = 11
}
PIPEWIRE_AVB_CONF
    fi

    __file_write;

    FILE_PATH \
<<'PIPEWIRE_PULSE_CONF'
/etc/pipewire/pipewire-pulse.conf.d/pipewire-pulse.conf
PIPEWIRE_PULSE_CONF

    if [ "$audio_hq" = 1 ]; then
        FILE \
<<'PIPEWIRE_PULSE_CONF'
stream.properties = {
    resample.quality = 15
}
PIPEWIRE_PULSE_CONF
    else
        FILE \
<<'PIPEWIRE_PULSE_CONF'
stream.properties = {
    resample.quality = 11
}
PIPEWIRE_PULSE_CONF
    fi

    __file_write;
}

_pipewire_media_session_conf() {
    FILE_PATH \
<<'MEDIA_SESSION_CONF'
/etc/pipewire/media-session.d/media-session.conf
MEDIA_SESSION_CONF

    FILE \
<<'MEDIA_SESSION_CONF'
context.properties = {
    # Properties to configure the session and some
    # modules.
    #mem.mlock-all                     = false
    #support.dbus                      = true
    #log.level                         = 2
    #alsa.seq.name                     = Midi-Bridge
    #default-profile.restore-bluetooth = false
}

context.spa-libs = {
    # Mapping from factory name to library.
    api.bluez5.*    = bluez5/libspa-bluez5
    api.alsa.*      = alsa/libspa-alsa
    api.v4l2.*      = v4l2/libspa-v4l2
    api.libcamera.* = libcamera/libspa-libcamera
}

context.modules = [
    #{ name = <module-name>
    #    [ args  = { <key> = <value> ... } ]
    #    [ flags = [ [ ifexists ] [ nofail ] ]
    #}
    #
    # Loads a module with the given parameters.
    # If ifexists is given, the module is ignored when it is not found.
    # If nofail is given, module initialization failures are ignored.
    #
    # Uses RTKit to boost the data thread priority.
    { name = libpipewire-module-rtkit
        args = {
            #nice.level   = -11
            #rt.prio      = 88
            #rt.time.soft = 2000000
            #rt.time.hard = 2000000
        }
        flags = [ ifexists nofail ]
    }

    # The native communication protocol.
    { name = libpipewire-module-protocol-native }

    # Allows creating nodes that run in the context of the
    # client. Is used by all clients that want to provide
    # data to PipeWire.
    { name = libpipewire-module-client-node }

    # Allows creating devices that run in the context of the
    # client. Is used by the session manager.
    { name = libpipewire-module-client-device }

    # Makes a factory for wrapping nodes in an adapter with a
    # converter and resampler.
    { name = libpipewire-module-adapter }

    # Allows applications to create metadata objects. It creates
    # a factory for Metadata objects.
    { name = libpipewire-module-metadata }

    # Provides factories to make session manager objects.
    { name = libpipewire-module-session-manager }
]

session.modules = {
    # These are the modules that are enabled when a file with
    # the key name is found in the media-session.d config directory.
    # the default bundle is always enabled.

    default = [
        flatpak                 # manages flatpak access
        portal                  # manage portal permissions
        v4l2                    # video for linux udev detection
        #libcamera              # libcamera udev detection
        #suspend-node            # suspend inactive nodes
        policy-node             # configure and link nodes
        #metadata               # export metadata API
        #default-nodes          # restore default nodes
        #default-profile        # restore default profiles
        #default-routes         # restore default route
        #streams-follow-default # move streams when default changes
        #alsa-no-dsp            # do not configure audio nodes in DSP mode
        #alsa-seq               # alsa seq midi support
        #alsa-monitor           # alsa udev detection
        #bluez5                 # bluetooth support
        #bluez5-autoswitch      # automatic bluetooth HSP/HFP profile switch
        #restore-stream         # restore stream settings
        #logind                 # systemd-logind seat support
    ]
    with-audio = [
        metadata
        default-nodes
        default-profile
        default-routes
        alsa-seq
        alsa-monitor
    ]
    with-alsa = [
        with-audio
    ]
    with-jack = [
        with-audio
    ]
    with-pulseaudio = [
        with-audio
        bluez5
        bluez5-autoswitch
        logind
        restore-stream
        streams-follow-default
    ]
}
MEDIA_SESSION_CONF

    __file_write;
}

_pulseaudio_conf() {
    FILE_PATH \
<<'DAEMON_CONF'
/etc/pulse/daemon.conf
DAEMON_CONF

    FILE \
<<'DAEMON_CONF'
avoid-resampling = true
default-sample-format = s24le
default-sample-rate = 48000
exit-idle-time = -1
DAEMON_CONF

    if [ "$audio_hq" = 1 ]; then
        FILE \
<<'DAEMON_CONF'
resample-method = soxr-vhq
DAEMON_CONF
    else
        FILE \
<<'DAEMON_CONF'
resample-method = speex-float-8
DAEMON_CONF
    fi

    __file_write;

    FILE_PATH \
<<'DEFAULT_PA'
/etc/pulse/default.pa
DEFAULT_PA

    libfile ~0 \
            'load-module module-suspend-on-idle'
            '#load-module module-suspend-on-idle'

    __file_write_overwrite;
}

_ranger_conf() {
    FILE_PATH \
<<RC_CONF
$home/.config/ranger/rc.conf
RC_CONF

    FILE \
<<'RC_CONF'
map D console delete
copymap J <C-z>
copymap K <C-x>
copymap S <C-s>
set autosave_bookmarks false
set display_free_space_in_status_bar false
set display_size_in_status_bar false
set draw_borders both
set hostname_in_titlebar false
set idle_delay 100
set max_console_history_size 100
set mouse_enabled false
set preview_images_method kitty
set tilde_in_titlebar true
RC_CONF

    __file_write;

    FILE_PATH \
<<RIFLE_CONF
$home/.config/ranger/rifle.conf
RIFLE_CONF

    FILE \
<<'RIFLE_CONF'
# Video
mime ^video, has mpv,       X,  flag f = mpv -- "$@"
mime ^video, has parole,    X,  flag f = parole -- "$@"
mime ^video, has vlc,       X,  flag f = vlc -- "$@"
mime ^video, has mpv,       !X, terminal = mpv -- "$@"

# Audio
ext midi?, has wildmidi,    terminal = wildmidi -- "$@"
mime ^audio, has mocp,      terminal = mocp -l -- "$@"
mime ^audio, has mpv,       terminal = mpv -- "$@"
mime ^audio, has parole,    X, flag f = parole -- "$@"
mime ^audio, has vlc,       X, flag f = vlc -- "$@"

# Images
ext xcf, has gimp,                X, flag f = gimp -- "$@"
mime ^image/svg, has inkscape,    X, flag f = inkscape -- "$@"
mime ^image/svg, has display,     X, flag f = display -- "$@"
mime ^image, has swayimg,         X, flag f = swayimg -- "$@"
mime ^image, has imv,             X, flag f = imv -- "$@"
mime ^image, has ristretto,       X, flag f = ristretto "$@"
mime ^image, has gimp,            X, flag f = gimp -- "$@"

# PDF/Books
ext pdf, has firefox,          X, flag f = firefox -- "$@"
ext pdf, has zathura,          X, flag f = zathura -- "$@"
ext djvu, has zathura,         X, flag f = zathura -- "$@"
ext djvu, has djview,          X, flag f = djview -- "$@"
ext epub, has zathura,         X, flag f = zathura -- "$@"
ext epub, has ebook-viewer,    X, flag f = ebook-viewer -- "$@"
ext mobi, has ebook-viewer,    X, flag f = ebook-viewer -- "$@"
ext cbr|cbz, has zathura,      X, flag f = zathura -- "$@"

# Archives (atool)
ext 7z|ace|ar|arc|bz2?|cab|cpio|cpt|deb|dgc|dmg|gz|iso|jar|msi|pkg|rar|shar|tar|tgz|xar|xpi|xz|zip,    has atool = atool --list --each -- "$@" | "$PAGER"
ext 7z|ace|ar|arc|bz2?|cab|cpio|cpt|deb|dgc|dmg|gz|iso|jar|msi|pkg|rar|shar|tar|tgz|xar|xpi|xz|zip,    has atool = atool --extract --each -- "$@"

# Archives
ext 7z      has 7z = 7z -p l "$@" | "$PAGER"
ext 7z,     has 7z = for file in "$@"; do 7z -p -o"${file%???}" x -- "$file"; done
ext ace,    has unace = unace l "$1" | less
ext ace,    has unace = for file in "$@"; do unace e "$file"; done
ext bz2,    has tar = tar vvtf "$1" | "$PAGER"
ext bz2,    has tar = for file in "$@"; do tar vvxf "$file"; done
ext bz2,    has bzip2 = for file in "$@"; do bzip2 -dk "$file"; done
ext gz,     has tar = tar vvtf "$1" | "$PAGER"
ext gz,     has tar = for file in "$@"; do tar vvxf "$file"; done
ext rar,    has unrar = unrar l "$1" | less
ext rar,    has unrar = for file in "$@"; do unrar x "$file"; done
ext tar,    has tar = tar vvtf "$1" | "$PAGER"
ext tar,    has tar = for file in "$@"; do tar vvxf "$file"; done
ext xz,     has tar = tar vvtf "$1" | "$PAGER"
ext xz,     has tar = for file in "$@"; do tar vvxf "$file"; done
ext zip,    has unzip = unzip -l "$1" | less
ext zip,    has unzip = for file in "$@"; do unzip -d "${file%.*}" "$file"; done
ext zst,    has tar = tar vvtf "$1" | "$PAGER"
ext zst,    has tar = for file in "$@"; do tar vvxf "$file"; done

# HTML
ext x?html?, has firefox,     X, flag f = firefox -- "$@"
ext x?html?, has midori,      X, flag f = midori -- "$@"
ext x?html?, has chromium,    X, flag f = midori -- "$@"

# Docs/Text
ext sh,    has featherpad,     X, flag f = featherpad "$@"
ext shfn,  has featherpad,     X, flag f = featherpad "$@"
ext ini,   has featherpad,     X, flag f = featherpad "$@"
ext docx?, has catdoc,         terminal = catdoc -- "$@" | "$PAGER"
mime ^text, has featherpad,    X, flag f = featherpad "$@"
mime ^text, label editor                 = "${VISUAL:-$EDITOR}" -- "$@"
mime ^text, label pager                  = "$PAGER" -- "$@"

# Misc exts
ext 1|5 = man "$1"
ext exe = wine "$1"

# Misc mEmes
mime application/x-executable               = "$1"
mime ^font, has fontforge, X, flag f        = fontforge "$@"
mime ^ranger/x-terminal-emulator, has kitty = kitty -- "$@"

label open,   has xdg-open = xdg-open "$@"
label editor, !mime ^text, = "${VISUAL:-$EDITOR}" -- "$@"
label pager,  !mime ^text, = "$PAGER" -- "$@"
RIFLE_CONF

    __file_write;
}

_reflector() {
    if [ "$arch_linux" != 1 ]; then
        info -w -1 'Nothing to be done.'
        return 0
    fi

    if [ "$bg" = 1 ]; then
        _reflector_bg;
    elif [ "$de" = 1 ]; then
        _reflector_de;
    else
        info -w -1 'Nothing to be done.'
        return 0
    fi
}

_reflector_bg() {
    cmd 'reflector' || ENOCMD 'reflector'

    FILE_PATH \
<<MIRRORLIST
$arch_mirlist
MIRRORLIST

    info -w -1 'Executing reflector. This may take some time.'

    { FILE=$(
        reflector --country Bulgaria \
                  --connection-timeout 1 \
                  --download-timeout 20 \
                  --protocol https \
                  --completion-percent 100 \
                  --sort rate \
                  --threads 8 \
                  --latest 10 \
                  --number 3 2> /dev/null
    ); } 2> /dev/null || :

    FILE=$(
        printf "%s\n" "$FILE" | while IFS= read -r LINE; do
            if str_pfix 'Server =' "$LINE"; then
                printf "%s\n" "$LINE"
            fi
        done
    )

    if [ "$FILE" ]; then
        FILE="$FILE$LF"
    else
        err -r - 'reflector: Failed.'
        errF 235 - 'Try again on a static network condition.'
    fi

    __file_write_overwrite;
}

_reflector_de() {
    cmd 'reflector' || ENOCMD 'reflector'

    FILE_PATH \
<<MIRRORLIST
$arch_mirlist
MIRRORLIST

    info -w -1 'Executing reflector. This may take some time.'

    { FILE=$(
        reflector --country Germany \
                  --connection-timeout 1 \
                  --download-timeout 60 \
                  --protocol https \
                  --completion-percent 100 \
                  --sort rate \
                  --threads 8 \
                  --latest 15 \
                  --number 3 2> /dev/null
    ); } 2> /dev/null || :

    FILE=$(
        printf "%s\n" "$FILE" | while IFS= read -r LINE; do
            if str_pfix 'Server =' "$LINE"; then
                printf "%s\n" "$LINE"
            fi
        done
    )

    if [ "$FILE" ]; then
        FILE="$FILE$LF"
    else
        err -r - 'reflector: Failed.'
        errF 235 - 'Try again on a static network condition.'
    fi

    __file_write_overwrite;
}

_resolv_conf() {
    if [ "$dns" = localhost ] || [ "$dns" = none ] || [ ! "$dns" ]; then
        :
    else
        info -w -1 'Nothing to be done.'
        return 0
    fi

    FILE_PATH \
<<'RESOLV_CONF'
/etc/resolv.conf
RESOLV_CONF

    if [ "$dns" = localhost ]; then
        if [ "$ipv6" = 1 ]; then
            FILE \
<<'RESOLV_CONF'
nameserver ::1
nameserver 127.0.0.1
RESOLV_CONF
        else
            FILE \
<<'RESOLV_CONF'
nameserver 127.0.0.1
RESOLV_CONF
        fi

        FILE \
<<'RESOLV_CONF'
options trust-ad
RESOLV_CONF

        __file_write;
        __loc_chattr 'i'
    elif [ "$dns" = none ] || [ ! "$dns" ]; then
        __loc_delete;
    fi
}

_sh() {
    FILE_PATH \
<<'DASH'
/usr/bin/dash
DASH

    FILE_PATH_TARGET \
<<'SH'
/usr/bin/sh
SH

    __loc_target_link_overwrite;

    if [ "$arch_linux" = 1 ]; then
        FILE_PATH \
<<'DASHBINSH_HOOK'
/usr/share/libalpm/hooks/dashbinsh.hook
DASHBINSH_HOOK

        FILE \
<<'DASHBINSH_HOOK'
[Trigger]
Type = Package
Operation = Install
Operation = Upgrade
Target = bash

[Action]
Description = Updating /bin/sh symlink to dash...
When = PostTransaction
Exec = /usr/bin/ln -sf /usr/bin/dash /usr/bin/sh
Depends = dash
DASHBINSH_HOOK

        __file_write;
    fi
}

_sudo_conf() {
    FILE_PATH \
<<'WHEEL'
/etc/sudoers.d/wheel
WHEEL

    FILE \
<<'WHEEL'
%wheel ALL=(ALL:ALL) ALL
WHEEL

    __file_write;
    __loc_chmod '0440'
}

_sway_conf() {
    FILE_PATH \
<<CONFIG
$home/.config/sway/config
CONFIG

    FILE \
<<'CONFIG'
output * adaptive_sync off
output * allow_tearing yes
output * max_render_time off

# Mod4 = Super key
set $mod Mod4
set $term kitty
set $menu exec \
    $term --class=sway-app-launcher \
    /usr/bin/sway-launcher-desktop

focus_follows_mouse always

# Prevent annoying apps from disrupting active focus by pinning them to a
# certain workplace, in our case `7`, used as a last resort workspace or "bag".
# Steam's "launcher"
assign [title="Steam"] 7
# Steam
assign [class="steam"] 7

# Pin specific apps to specific workspaces.
# FeatherPad
assign [app_id="featherpad"] 2

for_window [app_id="sway-app-launcher"] \
    floating enable, sticky enable, resize set 30 ppt 60 ppt, border pixel 5
for_window [app_id="firefox"] \
    border none

input type:touchpad {
    dwt disabled
    tap enabled
}

input type:keyboard {
    xkb_layout us,bg(phonetic)
    xkb_model pc86
CONFIG

    if [ "$gaming" = 1 ]; then
        FILE \
<<'CONFIG'
    xkb_options grp:alt_shift_toggle
CONFIG
    else
        FILE \
<<'CONFIG'
    xkb_options grp:alt_shift_toggle,caps:super
CONFIG
    fi

    FILE \
<<'CONFIG'
    repeat_delay 222
    repeat_rate 50
}

# Disable mouse acceleration
input type:pointer {
    accel_profile flat
}

# Appearance {
    output * bg #241f31 solid_color
    default_border pixel
    client.focused #0A75AD #0A75AD #0A75AD #0A75AD #0A75AD
    font pango:Cantarell 12
    seat seat0 xcursor_theme Breeze
    exec_always /home/$USER/.config/sway/import-gsettings
    exec_always /home/$USER/.config/sway/wp-handler
# }

# App keybindings {
    bindsym $mod+Return exec $term
    bindsym $mod+a exec $menu
    bindsym $mod+t exec /usr/bin/telegram-desktop
    bindsym $mod+b exec /usr/bin/blueman-manager
# }

# Control keybindings {
    bindsym $mod+1 workspace number 1
    bindsym $mod+2 workspace number 2
    bindsym $mod+3 workspace number 3
    bindsym $mod+4 workspace number 4
    bindsym $mod+5 workspace number 5
    bindsym $mod+6 workspace number 6
    bindsym $mod+7 workspace number 7

    bindsym $mod+Left focus left
    bindsym $mod+Down focus down
    bindsym $mod+Up focus up
    bindsym $mod+Right focus right
    bindsym Alt+Tab focus right
    bindsym Alt+Shift+Tab focus left

    # Basic functions
    bindsym $mod+z exec pamixer -d5
    bindsym $mod+x exec pamixer -i5
    bindsym $mod+c exec brightnessctl s 5%-
    bindsym $mod+v exec brightnessctl s 5%+
    bindsym print exec grim -l 9 $(date +'SS_%Y-%m-%d_%H%M%S.png')
    bindsym $mod+p exec grim -l 9 -g "$(slurp)" \
                            $(date +'SS_%Y-%m-%d_%H%M%S.png')
    bindsym $mod+Shift+p exec grim -l 9 -g "$(slurp; sleep 2.5)" \
                                  $(date +'SS_%Y-%m-%d_%H%M%S.png')

    # Extended functions
    # get hex color of a pixel
    bindsym $mod+h exec grim -g "$(slurp -p)" -t ppm - | \
                        convert - -format '%[pixel:p{0,0}]' txt:- | \
                        tail -n 1 | cut -d ' ' -f 4 | wl-copy -n
    # toggle audio playback
    bindsym $mod+Space exec /home/$USER/.config/sway/music_toggle

    # Kill window
    bindsym $mod+q kill

    # Force kill window
    bindsym $mod+Shift+q exec /home/$USER/.config/sway/fkill

    # Fullscreen window
    bindsym $mod+f fullscreen

    # Drag window by holding down $mod + LMB
    # Resize window by holding down $mod + RMB
    floating_modifier $mod normal

    # Invoke swaylock
    bindsym $mod+l exec swaylock

    # Reload the config
    bindsym $mod+Shift+c reload
# }

mode "nointercept" {
    bindsym $mod+Escape mode "default"
}
bindsym $mod+Shift+Escape mode "nointercept"

bar {
CONFIG

    if [ "$gaming" != 1 ]; then
        FILE \
<<'CONFIG'
    status_command while /home/$USER/.config/sway/status; do sleep 0.1; done
CONFIG
    fi

    FILE \
<<'CONFIG'
    position top
    font pango:Source Code Pro 10

    colors {
        statusline #ffffff
        background #2b2e37
        inactive_workspace #32323200 #32323200 #5c5c5c
    }
}

CONFIG

    if [ "$polkit_agent" ]; then
        FILE \
<<CONFIG
exec $polkit_agent
CONFIG
    fi

    if [ "$arch_linux" = 1 ]; then
        FILE \
<<'CONFIG'
exec /home/$USER/.config/sway/systemd-handler
CONFIG
    fi

    FILE \
<<'CONFIG'
exec_always sh -c 'rm -f "${TMPDIR:-/tmp}"/nettotal'
CONFIG

    __file_write;

    if [ "$arch_linux" = 1 ]; then
        FILE_PATH \
<<SYSTEMD_HANDLER
$home/.config/sway/systemd-handler
SYSTEMD_HANDLER

        FILE \
<<'SYSTEMD_HANDLER'
#!/bin/sh

systemctl --user import-environment \
    DISPLAY WAYLAND_DISPLAY SWAYSOCK XDG_CURRENT_DESKTOP XDG_SESSION_DESKTOP \
    DESKTOP_SESSION
dbus-update-activation-environment && \
    dbus-update-activation-environment --systemd \
    DISPLAY WAYLAND_DISPLAY SWAYSOCK XDG_CURRENT_DESKTOP XDG_SESSION_DESKTOP \
    DESKTOP_SESSION
sleep 2 && \
    systemctl --user restart \
    xdg-desktop-portal xdg-desktop-portal-wlr xdg-desktop-portal-gtk \
    xdg-document-portal
sleep 2 && \
    systemctl --user restart \
    pipewire pipewire-pulse pipewire-media-session

set -- 'pipewire' 'pipewire-pulse' 'pipewire-media-session' \
       'xdg-desktop-portal' 'pipewire' 'pipewire-pulse' 'pipewire-media-session'
while [ "$1" ]; do
    case "$(systemctl status --user "$1")" in
        *'mod.rt: RTKit error: org.freedesktop.DBus.Error.NoReply'* | \
        *'Failed connect to PipeWire: No node factory discovered'* | \
        *'Caught PipeWire error: connection error'* | \
        *'realtime using RTKit: Input/output error'* | \
        *'mod.rt:'*'Input/output error'* | \
        *'mod.rt: could not make thread'*)
            systemctl restart --user "$1"
            sleep 0.2
        ;;
        *)
            shift
        ;;
    esac
done

sleep 12
systemctl restart --user xdg-desktop-portal

return 0
SYSTEMD_HANDLER

        __file_write;
        __file_executable;
    fi

    FILE_PATH \
<<FKILL
$home/.config/sway/fkill
FKILL

    FILE \
<<'FKILL'
#!/bin/sh

PID=$(
    swaymsg -t get_tree | \
    jq '.. | select(.type?) | select(.focused==true).pid'
)

kill -9 "$PID"
FKILL

    __file_write;
    __file_executable;

    FILE_PATH \
<<IMPORT_GSETTINGS
$home/.config/sway/import-gsettings
IMPORT_GSETTINGS

    FILE \
<<'IMPORT_GSETTINGS'
#!/bin/sh

cfg="${XDG_CONFIG_HOME:-$HOME/.config}/gtk-3.0/settings.ini"

[ -f "$cfg" ] || return 1

gnome_schema='org.gnome.desktop.interface'

while read -r LINE; do
    case "$LINE" in
        'gtk-theme-name='*)
            gsettings set "$gnome_schema" gtk-theme "${LINE#*=}"
        ;;
        'gtk-icon-theme-name='*)
            gsettings set "$gnome_schema" icon-theme "${LINE#*=}"
        ;;
        'gtk-cursor-theme-name='*)
            gsettings set "$gnome_schema" cursor-theme "${LINE#*=}"
        ;;
        'gtk-font-name='*)
            gsettings set "$gnome_schema" font-name "${LINE#*=}"
        ;;
        'gtk-document-font-name='*)
            gsettings set "$gnome_schema" document-font-name "${LINE#*=}"
        ;;
        'gtk-monospace-font-name='*)
            gsettings set "$gnome_schema" monospace-font-name "${LINE#*=}"
        ;;
    esac
done < "$cfg"
IMPORT_GSETTINGS

    __file_write;
    __file_executable;

    FILE_PATH \
<<STATUS
$home/.config/sway/status
STATUS

    FILE \
<<'STATUS'
#!/bin/sh

NET_INTERFACE=wlan0

replchars() {
    replchar() {
        IFS="$1"; _chars="$2"

        set -f; set -- $3 "$3"; set +f

        _str=; while [ "$#" -ge 3 ]; do
            _str="$_str$1$_chars"; shift
        done

        case "$IFS" in
            *"${2#"${2%?}"}"*) _str="$_str$1$_chars" ;;
            *) _str="$_str$1" ;;
        esac
    }

    _old_IFS="$IFS" 2> /dev/null
    ${IFS+':'} unset _old_IFS 2> /dev/null

    replchar "$1" "$2" "$3"

    IFS="$_old_IFS" 2> /dev/null
    ${_old_IFS+':'} unset IFS 2> /dev/null
}

TITLE=$(
    swaymsg -t get_tree | \
    jq -r '.. | select(.type?) | select(.focused==true).name' 2> /dev/null
)
if [ "$TITLE" ]; then
    replchars '&' '&amp;' "$TITLE"; TITLE="$_str";
fi

MEMHOG=$(ps aux 2> /dev/null)
{
CUR=
CUR_F_PERC=
CUR_S_PERC=
while IFS= read -r LINE; do
    set -- $LINE

    case "$4" in
        '%MEM') continue ;;
    esac

    f_perc="${4%.*}"
    s_perc="${4#*.}"

    if [ "$CUR_F_PERC" ]; then
        if [ "$f_perc" -gt "$CUR_F_PERC" ]; then
            CUR="$LINE"
            CUR_F_PERC="$f_perc"
            CUR_S_PERC="$s_perc"
        elif [ "$f_perc" -eq "$CUR_F_PERC" ]; then
            if [ "$s_perc" -gt "$CUR_S_PERC" ]; then
                CUR="$LINE"
                CUR_S_PERC="$s_perc"
            fi
        fi
    else
        CUR="$LINE"
        CUR_F_PERC="$f_perc"
        CUR_S_PERC="$s_perc"
    fi
done \
<<EOF
$MEMHOG
EOF

read -r _ MEMTOTAL_BYTES _ < /proc/meminfo
MEMTOTAL_BYTES=$((MEMTOTAL_BYTES * 1024))

MEMHOG=$(
    set -- $CUR

    printf "%s" "$2 /"  # pid
    printf "%s" "${11##*/} /"  # cmd

    MEMHOG_BYTES=$((MEMTOTAL_BYTES * $CUR_F_PERC$CUR_S_PERC / 1000))  # base 2
    awk -v 'bytes_memhog'="$MEMHOG_BYTES" '
	function hsize(x, base) {
		basesuf = (base == "1024") ? "iB" : "B"

		s = "BKMGTEPYZ"
		while (x >= base && length(s) > 1)
			{x /= base; s = substr(s, 2)}
		s = substr(s, 1, 1)

		xf = (s == "B") ? "%d" : "%.2f"

		if (s != "B")
			s = s basesuf

		printf((xf " %s"), x, s)
	}

	BEGIN {
		printf hsize(bytes_memhog, 1000)
	}
    '  # mem_usage
)
} 2> /dev/null

while :; do
NET_USAGE=
if [ -h /sys/class/net/"$NET_INTERFACE" ]; then
    PREV_TX=0
    PREV_RX=0
    TOTAL=0
    if [ -f "${TMPDIR:-/tmp}"/netprevtx ]; then
        read -r PREV_TX < "${TMPDIR:-/tmp}"/netprevtx
    fi
    if [ -f "${TMPDIR:-/tmp}"/netprevrx ]; then
        read -r PREV_RX < "${TMPDIR:-/tmp}"/netprevrx
    fi
    if [ -f "${TMPDIR:-/tmp}"/nettotal ]; then
        read -r TOTAL < "${TMPDIR:-/tmp}"/nettotal
    fi
    read -r TX < /sys/class/net/"$NET_INTERFACE"/statistics/tx_bytes
    read -r RX < /sys/class/net/"$NET_INTERFACE"/statistics/rx_bytes
    [ "$TX" ] || break
    [ "$RX" ] || break

    if [ "$PREV_TX" = 0 ]; then
        printf "%s\n" "$TX" > "${TMPDIR:-/tmp}"/netprevtx; TX=0
    else
        CUR_TX=$((TX - PREV_TX))
    fi

    if [ "$PREV_RX" = 0 ]; then
        printf "%s\n" "$RX" > "${TMPDIR:-/tmp}"/netprevrx; RX=0
    else
        CUR_RX=$((RX - PREV_RX))
    fi

    if [ "$TX" = 0 ] || [ "$RX" = 0 ]; then
        break
    fi

    TOTAL=$((TOTAL + (CUR_TX + CUR_RX)))

    printf "%s\n" "$TX" > "${TMPDIR:-/tmp}"/netprevtx
    printf "%s\n" "$RX" > "${TMPDIR:-/tmp}"/netprevrx
    printf "%s\n" "$TOTAL" > "${TMPDIR:-/tmp}"/nettotal

    NET_USAGE=$(awk -v 'bytes_tx'="$CUR_TX" -v 'bytes_rx'="$CUR_RX" \
                    -v 'bytes_total'="$TOTAL" '
	function hsize(x, base) {
		basesuf = (base == "1024") ? "iB" : "B"

		s = "BKMGTEPYZ"
		while (x >= base && length(s) > 1)
			{x /= base; s = substr(s, 2)}
		s = substr(s, 1, 1)

		xf = (s == "B") ? "%d" : "%.2f"

		if (s != "B")
			s = s basesuf

		printf((xf " %s"), x, s)
	}

	BEGIN {
		printf "UDT"
		printf " /"
		printf hsize(bytes_tx, 1000)
		printf " /"
		printf hsize(bytes_rx, 1000)
		printf " /"
		printf hsize(bytes_total, 1000)
	}
    ' 2> /dev/null)
fi
break; done

PREV_IDLE=0
PREV_TOTAL=0
if [ -f "${TMPDIR:-/tmp}"/cpustatprevi ]; then
    read -r PREV_IDLE < "${TMPDIR:-/tmp}"/cpustatprevi
fi
if [ -f "${TMPDIR:-/tmp}"/cpustatprevt ]; then
    read -r PREV_TOTAL < "${TMPDIR:-/tmp}"/cpustatprevt
fi
read -r line < /proc/stat
PFIX="${line%%[0123456789]*}"
SFIX="${line#*[0123456789]}"
case "$SFIX" in
    [0123456789]*)
        SFIX="${SFIX#"${SFIX%%[!0123456789]*}"}"
    ;;
esac
IDLE="${line#"$PFIX"}"
IDLE="${IDLE%"$SFIX"}"
LINE="$PFIX$IDLE$SFIX"
x=0; while [ "$x" -ne 3 ]; do
    LINE="${LINE#"$PFIX$IDLE"}"
    PFIX="$PFIX$IDLE${LINE%%[0123456789]*}"
    SFIX="${LINE#*[0123456789]}"
    case "$SFIX" in
        [0123456789]*)
            SFIX="${SFIX#"${SFIX%%[!0123456789]*}"}"
        ;;
    esac
    IDLE="${LINE#"${LINE%%[0123456789]*}"}"
    IDLE="${IDLE%"$SFIX"}"
    LINE="$PFIX$IDLE$SFIX"
    x=$((x + 1))
done
PFIX="${line%%[0123456789]*}"
SFIX="${line#*[0123456789]}"
case "$SFIX" in
    [0123456789]*)
        SFIX="${SFIX#"${SFIX%%[!0123456789]*}"}"
    ;;
esac
_TOTAL="${line#"$PFIX"}"
_TOTAL="${_TOTAL%"$SFIX"}"
TOTAL="$_TOTAL"
LINE="$PFIX$_TOTAL$SFIX"
x=0; while [ "$x" -ne 6 ]; do
    LINE="${LINE#"$PFIX$_TOTAL"}"
    PFIX="$PFIX$_TOTAL${LINE%%[0123456789]*}"
    SFIX="${LINE#*[0123456789]}"
    case "$SFIX" in
        [0123456789]*)
            SFIX="${SFIX#"${SFIX%%[!0123456789]*}"}"
        ;;
    esac
    _TOTAL="${LINE#"${LINE%%[0123456789]*}"}"
    _TOTAL="${_TOTAL%"$SFIX"}"
    TOTAL=$((TOTAL + _TOTAL))
    LINE="$PFIX$_TOTAL$SFIX"
    x=$((x + 1))
done
printf "%s\n" "$IDLE" > "${TMPDIR:-/tmp}"/cpustatprevi
printf "%s\n" "$TOTAL" > "${TMPDIR:-/tmp}"/cpustatprevt
DIFF_IDLE=$((IDLE - PREV_IDLE))
DIFF_TOTAL=$((TOTAL - PREV_TOTAL))
CPU=$(((1000 * (DIFF_TOTAL - DIFF_IDLE) / DIFF_TOTAL + 5) / 10))

{ while read -r LINE; do
    case "$LINE" in
        'MemAvailable:'*)
            PFIX="${LINE%%[0123456789]*}"
            SFIX="${LINE#*[0123456789]}"
            case "$SFIX" in
                [0123456789]*)
                    SFIX="${SFIX#"${SFIX%%[!0123456789]*}"}"
                ;;
            esac

            MEMORY="${LINE#"$PFIX"}"
            MEMORY="${MEMORY%"$SFIX"}"
            MEMORY=$((MEMORY * 1024))

            MEMORY=$(awk -v 'bytes'="$MEMORY" '
	        function hsize(x, base) {
	        	basesuf = (base == "1024") ? "iB" : "B"

	        	s = "BKMGTEPYZ"
	        	while (x >= base && length(s) > 1)
	        		{x /= base; s = substr(s, 2)}
	        	s = substr(s, 1, 1)

	        	xf = (s == "B") ? "%d" : "%.2f"

	        	if (s != "B")
	        		s = s basesuf

	        	printf((xf " %s"), x, s)
	        }

	        BEGIN {
	        	printf hsize(bytes, 1000)
	        }
            ' 2> /dev/null)
        ;;
    esac
done < /proc/meminfo; } 2> /dev/null

{ read -r BATTERY < /sys/class/power_supply/BAT0/capacity; } 2> /dev/null

VOLUME=$(pamixer --get-volume 2> /dev/null)

AUDIO_SINK=$(pactl list sinks 2> /dev/null)
{
_STATE=; _NAME=
while IFS= read -r LINE; do
    case "$LINE" in
        *'State: RUNNING'*) _STATE=1 ;;
    esac

    case "$LINE" in
        *'Name: '*)
            if [ "$_STATE" = 1 ]; then
                _NAME="${LINE#*Name: }"; break
            fi
        ;;
    esac
done \
<<EOF
$AUDIO_SINK
EOF

AUDIO_SINK="$_NAME"
} 2> /dev/null
case "$AUDIO_SINK" in
    'alsa_output'*) AUDIO_SINK=ALSA ;;
    'bluez_output'*) AUDIO_SINK=BLUEZ ;;
esac

KB_LAYOUT=$(
    swaymsg -t get_inputs | \
    jq 'map(select(has("xkb_active_layout_name")))[0].xkb_active_layout_name'
)
case "$KB_LAYOUT" in
    *'English'*)
        KB_LAYOUT=EN
    ;;
    *'Bulgarian'*)
        KB_LAYOUT=BG
    ;;
esac

DATE=$(date "+%A%_d,%_I:%M %p" 2> /dev/null)
while :; do case "$DATE" in
    *[0123456789]','[0123456789]*)
        DATE="${DATE%\,*}, ${DATE#*\,}"
    ;;
    *'day'[0123456789]*)
        DATE="${DATE%day*}day ${DATE#*day}"
    ;;
    *)
        break
    ;;
esac done

STATUS="$TITLE | $MEMHOG"
if [ "$NET_USAGE" ]; then
    STATUS="$STATUS | $NET_USAGE"
fi
STATUS="$STATUS | ${CPU}% | $MEMORY"
case "$BATTERY" in
    100) : ;;
    *) STATUS="$STATUS | ~${BATTERY}%" ;;
esac
STATUS="$STATUS | ${VOLUME}%"
if [ "$AUDIO_SINK" ]; then
    STATUS="$STATUS | $AUDIO_SINK"
fi
STATUS="$STATUS | $KB_LAYOUT | $DATE |"

printf "%s" "$STATUS"
STATUS

    __file_write;
    __file_executable;

    FILE_PATH \
<<MUSIC_TOGGLE
$home/.config/sway/music_toggle
MUSIC_TOGGLE

    FILE \
<<'MUSIC_TOGGLE'
#!/bin/sh

MOCP_STATE=$(mocp -Q %state)
MOCP_PAUSE_FILE="${TMPDIR:-/tmp}"/music_toggle_mocp

if [ -f "$MOCP_PAUSE_FILE" ]; then
    if playerctl status 2> /dev/null | grep -q 'Playing'; then
        playerctl play-pause
    elif [ "$MOCP_STATE" = 'PAUSE' ]; then
        mocp -U
    fi

    rm -f "$MOCP_PAUSE_FILE"
    exit 0
elif [ "$MOCP_STATE" = 'PLAY' ]; then
    mocp -P
    : > "$MOCP_PAUSE_FILE"
    exit 0
fi

playerctl play-pause > /dev/null 2>&1
MUSIC_TOGGLE

    __file_write;
    __file_executable;

    FILE_PATH \
<<WP_HANDLER
$home/.config/sway/wp-handler
WP_HANDLER

    FILE \
<<'WP_HANDLER'
#!/bin/sh

WP_HANDLER

    FILE \
<<WP_HANDLER
WP=$home/.config/sway/wp
WP_HANDLER

    FILE \
<<'WP_HANDLER'
WP_NEW="${TMPDIR:-/tmp}"/wp

if [ -f "$WP_NEW" ]; then
    swaymsg output '*' bg "$WP_NEW" fill
elif [ -f "$WP" ]; then
    swaymsg output '*' bg "$WP" fill
fi
WP_HANDLER

    __file_write;
    __file_executable;
}

_swaylock_conf() {
    FILE_PATH \
<<CONFIG
$home/.swaylock/config
CONFIG

    FILE \
<<'CONFIG'
color=2b2e37
indicator-idle-visible
inside-color=2b2e37
ring-color=0A75AD
layout-bg-color=2b2e37
layout-border-color=2b2e37
CONFIG

    __file_write;
}

_sysctl_conf() {
    FILE_PATH \
<<'99_SYSCTL_CONF'
/etc/sysctl.d/99-sysctl.conf
99_SYSCTL_CONF

    FILE \
<<'99_SYSCTL_CONF'
kernel.sysrq = 1
99_SYSCTL_CONF

    __file_write;
}

_tz() {
    if [ "$bg" = 1 ]; then
        _tz_bg;
    elif [ "$de" = 1 ]; then
        _tz_de;
    else
        info -w -1 'Nothing to be done.'
        return 0
    fi
}

# Bulgarian timezone (Europe/Sofia)
_tz_bg() {
    cmd 'hwclock' || ENOCMD 'hwclock'

    FILE_PATH \
<<'SOFIA'
/usr/share/zoneinfo/Europe/Sofia
SOFIA

    FILE_PATH_TARGET \
<<'LOCALTIME'
/etc/localtime
LOCALTIME

    __loc_target_link_overwrite;

    if [ "$logging" = 1 ]; then
        if ! hwclock -w; then
            errF 235 - 'hwclock: Failed to set the system clock.'
        fi
    else
        if ! hwclock -w > /dev/null 2>&1; then
            errF 235 - 'hwclock: Failed to set the system clock.'
        fi
    fi
}

# German timezone (Europe/Berlin)
_tz_de() {
    cmd 'hwclock' || ENOCMD 'hwclock'

    FILE_PATH \
<<'BERLIN'
/usr/share/zoneinfo/Europe/Berlin
BERLIN

    FILE_PATH_TARGET \
<<'LOCALTIME'
/etc/localtime
LOCALTIME

    __loc_target_link_overwrite;

    if [ "$logging" = 1 ]; then
        if ! hwclock -w; then
            errF 235 - 'hwclock: Failed to set the system clock.'
        fi
    else
        if ! hwclock -w > /dev/null 2>&1; then
            errF 235 - 'hwclock: Failed to set the system clock.'
        fi
    fi
}

_wireplumber_conf() {
    FILE_PATH \
<<'99_ALSA_LUA'
/etc/wireplumber/main.lua.d/99-alsa.lua
99_ALSA_LUA

    FILE \
<<'99_ALSA_LUA'
table.insert (alsa_monitor.rules, {
    matches = {
        {
            { "node.name", "matches", "alsa_input.*" },
        },
        {
            { "node.name", "matches", "alsa_output.*" },
        },
    },
    apply_properties = {
        ["session.suspend-timeout-seconds"] = 0,
        ["resample.disable"] = true,
99_ALSA_LUA

    if [ "$audio_hq" = 1 ]; then
        FILE \
<<'99_ALSA_LUA'
        ["resample.quality"] = 15,
99_ALSA_LUA
    else
        FILE \
<<'99_ALSA_LUA'
        ["resample.quality"] = 11,
99_ALSA_LUA
    fi

    FILE \
<<'99_ALSA_LUA'
    },
})
99_ALSA_LUA

    __file_write;

    if [ "$bluetooth" = 1 ]; then
        FILE_PATH \
<<'99_BLUEZ_LUA'
/etc/wireplumber/bluetooth.lua.d/99-bluez.lua
99_BLUEZ_LUA

        FILE \
<<'99_BLUEZ_LUA'
table.insert (bluez_monitor.rules, {
    matches = {
        {
            { "node.name", "matches", "bluez_input..*" },
        },
        {
            { "node.name", "matches", "bluez_output..*" },
        },
    },
    apply_properties = {
        ["session.suspend-timeout-seconds"] = 0,
99_BLUEZ_LUA

        if [ "$audio_hq" = 1 ]; then
            FILE \
<<'99_BLUEZ_LUA'
        ["resample.quality"] = 15,
99_BLUEZ_LUA
        else
            FILE \
<<'99_BLUEZ_LUA'
        ["resample.quality"] = 11,
99_BLUEZ_LUA
        fi

        FILE \
<<'99_BLUEZ_LUA'
    },
})
99_BLUEZ_LUA

        __file_write;
    fi
}

_xdg_conf() {
    FILE_PATH \
<<MIMEAPPS_LIST
$home/.config/mimeapps.list
MIMEAPPS_LIST

    FILE \
<<'MIMEAPPS_LIST'
# Programs that support:
[Added Associations]
application/json=featherpad.desktop
application/javascript=firefox.desktop

# Programs that don't support:
[Removed Associations]

# Programs that will be used to open by default:
[Default Applications]
# /usr/lib/firefox/firefox: URLs / `.html` / `.pdf` / `.json`
x-scheme-handler/http=firefox.desktop
x-scheme-handler/https=firefox.desktop
text/html=firefox.desktop
application/pdf=firefox.desktop
application/json=firefox.desktop
# /usr/bin/featherpad: Text / Empty file / `.patch`/`.diff` / `.sh` / `.c` /
# JavaScript source
text/plain=featherpad.desktop
inode/x-empty=featherpad.desktop
text/x-diff=featherpad.desktop
text/x-shellscript=featherpad.desktop
text/x-c=featherpad.desktop
application/javascript=featherpad.desktop
MIMEAPPS_LIST

    __file_write;

    FILE_PATH_TARGET \
<<MIMEAPPS_LIST
$home/.local/share/applications/mimeapps.list
MIMEAPPS_LIST

    __loc_target_link_overwrite;

    FILE_PATH \
<<INDEX_THEME
$home/.icons/default/index.theme
INDEX_THEME

    FILE \
<<'INDEX_THEME'
[icon theme]
Inherits=Breeze
INDEX_THEME

    __file_write;
}

# Reproducible simple XFCE4 setup.
# The numbers in the filenames of .../xfce4/panel directory are in relation to
# the plugin IDs in xfce4-panel.xml
_xfce4_conf() {
    FILE_PATH \
<<HELP_RC
$home/.config/xfce4/help.rc
HELP_RC

    FILE \
<<'HELP_RC'
auto-online=false
HELP_RC

    __file_write;

    FILE_PATH \
<<HELPERS_RC
$home/.config/xfce4/helpers.rc
HELPERS_RC

    FILE \
<<'HELPERS_RC'
TerminalEmulator=custom-TerminalEmulator
HELPERS_RC

    if [ "$browser" = firefox ]; then
        FILE \
<<'HELPERS_RC'
WebBrowser=firefox
HELPERS_RC
    elif [ "$browser" = none ] || [ ! "$browser" ]; then
        FILE \
<<'HELPERS_RC'
WebBrowser=
HELPERS_RC
    fi

    __file_write;

    FILE_PATH \
<<XFCE4_SCREENSHOOTER
$home/.config/xfce4/xfce4-screenshooter
XFCE4_SCREENSHOOTER

    FILE \
<<'XFCE4_SCREENSHOOTER'
app=imv
last_user=
screenshot_dir=
action=4
delay=0
region=3
show_mouse=0
last_extension=png
enable_imgur_upload=false
show_border=0
show_in_folder=false
custom_action_command=none
XFCE4_SCREENSHOOTER

    __file_write;

    FILE_PATH \
<<15990473633_DESKTOP
$home/.config/xfce4/panel/launcher-2/15990473633.desktop
15990473633_DESKTOP

    FILE \
<<'15990473633_DESKTOP'
[Desktop Entry]
Version=1.0
Name=Firefox
GenericName=Web Browser
Comment=Browse the World Wide Web
Keywords=Internet;WWW;Browser;Web;Explorer
Exec=/usr/lib/firefox/firefox %u
Icon=firefox
Terminal=false
X-MultipleArgs=false
Type=Application
MimeType=text/html;text/xml;application/xhtml+xml;x-scheme-handler/http;x-scheme-handler/https;application/x-xpinstall;application/pdf;application/json;
StartupNotify=true
StartupWMClass=firefox
Categories=Network;WebBrowser;
Actions=private-window;
X-XFCE-Source=file:///usr/share/applications/firefox.desktop

[Desktop Action private-window]
Name=Private Window
Name[en_US]=Private Window
Exec=/usr/lib/firefox/firefox --private-window %u
15990473633_DESKTOP

    __file_write;

    FILE_PATH \
<<15990556735_DESKTOP
$home/.config/xfce4/panel/launcher-3/15990556735.desktop
15990556735_DESKTOP

    FILE \
<<'15990556735_DESKTOP'
[Desktop Entry]
Name=FeatherPad
GenericName=Text Editor
Comment=Lightweight Qt5 text editor
Exec=featherpad %F
Icon=featherpad
Terminal=false
Type=Application
MimeType=text/plain;
Categories=Qt;Utility;TextEditor;
Keywords=Text;Editor;Plaintext;
X-XFCE-Source=file:///usr/share/applications/featherpad.desktop
15990556735_DESKTOP

    __file_write;

    FILE_PATH \
<<WHISKERMENU_12_RC
$home/.config/xfce4/panel/whiskermenu-12.rc
WHISKERMENU_12_RC

    FILE \
<<'WHISKERMENU_12_RC'
favorites=steam-native.desktop,telegramdesktop.desktop
recent=
button-icon=xfce4-whiskermenu
button-single-row=false
show-button-title=false
show-button-icon=true
launcher-show-name=true
launcher-show-description=true
launcher-show-tooltip=true
launcher-icon-size=3
hover-switch-category=false
category-show-name=true
category-icon-size=1
sort-categories=true
view-mode=1
default-category=0
recent-items-max=5
favorites-in-recent=true
position-search-alternate=true
position-commands-alternate=false
position-categories-alternate=false
position-categories-horizontal=false
stay-on-focus-out=false
profile-shape=0
confirm-session-command=true
menu-width=450
menu-height=505
menu-opacity=100
command-settings=xfce4-settings-manager
show-command-settings=true
command-lockscreen=xflock4
show-command-lockscreen=true
command-switchuser=
show-command-switchuser=false
command-logoutuser=
show-command-logoutuser=false
command-restart=
show-command-restart=false
command-shutdown=
show-command-shutdown=false
command-suspend=
show-command-suspend=false
command-hibernate=
show-command-hibernate=false
command-logout=xfce4-session-logout
show-command-logout=false
command-menueditor=
show-command-menueditor=false
command-profile=mugshot
show-command-profile=false
search-actions=5
WHISKERMENU_12_RC

    __file_write;

    FILE_PATH \
<<ACCESSIBILITY_XML
$home/.config/xfce4/xfconf/xfce-perchannel-xml/accessibility.xml
ACCESSIBILITY_XML

    FILE \
<<'ACCESSIBILITY_XML'
<?xml version="1.0" encoding="UTF-8"?>

<channel name="accessibility" version="1.0">
    <property name="StickyKeys" type="bool" value="false"/>
    <property name="SlowKeys" type="bool" value="false"/>
    <property name="BounceKeys" type="bool" value="false"/>
</channel>
ACCESSIBILITY_XML

    __file_write;

    FILE_PATH \
<<KEYBOARD_LAYOUT_XML
$home/.config/xfce4/xfconf/xfce-perchannel-xml/keyboard-layout.xml
KEYBOARD_LAYOUT_XML

    FILE \
<<'KEYBOARD_LAYOUT_XML'
<?xml version="1.0" encoding="UTF-8"?>

<channel name="keyboard-layout" version="1.0">
  <property name="Default" type="empty">
    <property name="XkbDisable" type="bool" value="false"/>
    <property name="XkbModel" type="string" value="pc86"/>
    <property name="XkbOptions" type="empty">
      <property name="Group" type="string" value="grp:alt_shift_toggle"/>
    </property>
    <property name="XkbLayout" type="string" value="us,bg"/>
    <property name="XkbVariant" type="string" value=",phonetic"/>
  </property>
</channel>
KEYBOARD_LAYOUT_XML

    __file_write;

    FILE_PATH \
<<KEYBOARDS_XML
$home/.config/xfce4/xfconf/xfce-perchannel-xml/keyboards.xml
KEYBOARDS_XML

    FILE \
<<'KEYBOARDS_XML'
<?xml version="1.0" encoding="UTF-8"?>

<channel name="keyboards" version="1.0">
  <property name="Default" type="empty">
    <property name="Numlock" type="bool" value="true"/>
    <property name="KeyRepeat" type="empty">
      <property name="Rate" type="int" value="50"/>
      <property name="Delay" type="int" value="222"/>
    </property>
  </property>
</channel>
KEYBOARDS_XML

    __file_write;

    FILE_PATH \
<<THUNAR_XML
$home/.config/xfce4/xfconf/xfce-perchannel-xml/thunar.xml
THUNAR_XML

    FILE \
<<'THUNAR_XML'
<?xml version="1.0" encoding="UTF-8"?>

<channel name="thunar" version="1.0">
  <property name="last-view" type="string" value="ThunarDetailsView"/>
  <property name="last-location-bar" type="string" value="ThunarLocationEntry"/>
  <property name="last-icon-view-zoom-level" type="string" value="THUNAR_ZOOM_LEVEL_100_PERCENT"/>
  <property name="last-separator-position" type="int" value="170"/>
  <property name="misc-single-click" type="bool" value="false"/>
  <property name="last-details-view-zoom-level" type="string" value="THUNAR_ZOOM_LEVEL_38_PERCENT"/>
  <property name="last-details-view-column-widths" type="string" value="50,158,50,50,404,50,50,76,50,181"/>
  <property name="last-show-hidden" type="bool" value="false"/>
  <property name="last-window-width" type="int" value="990"/>
  <property name="last-window-height" type="int" value="660"/>
  <property name="last-window-maximized" type="bool" value="false"/>
  <property name="hidden-bookmarks" type="array">
    <value type="string" value="network:///"/>
    <value type="string" value="computer:///"/>
  </property>
  <property name="last-sort-column" type="string" value="THUNAR_COLUMN_TYPE"/>
  <property name="last-sort-order" type="string" value="GTK_SORT_ASCENDING"/>
  <property name="last-statusbar-visible" type="bool" value="false"/>
  <property name="last-menubar-visible" type="bool" value="true"/>
  <property name="misc-file-size-binary" type="bool" value="false"/>
  <property name="last-side-pane" type="string" value="ThunarShortcutsPane"/>
  <property name="misc-date-style" type="string" value="THUNAR_DATE_STYLE_YYYYMMDD"/>
</channel>
THUNAR_XML

    __file_write;

    FILE_PATH \
<<XFCE4_DESKTOP_XML
$home/.config/xfce4/xfconf/xfce-perchannel-xml/xfce4-desktop.xml
XFCE4_DESKTOP_XML

    FILE \
<<'XFCE4_DESKTOP_XML'
<?xml version="1.0" encoding="UTF-8"?>

<channel name="xfce4-desktop" version="1.0">
    <property name="backdrop" type="empty">
        <property name="screen0" type="empty">
            <property name="monitoreDP" type="empty">
                <property name="workspace0" type="empty">
                    <property name="color-style" type="int" value="0"/>
                    <property name="image-style" type="int" value="0"/>
                    <property name="rgba1" type="array">
                        <value type="double" value="0.141176"/>
                        <value type="double" value="0.121569"/>
                        <value type="double" value="0.192157"/>
                        <value type="double" value="1.000000"/>
                    </property>
                    <property name="backdrop-cycle-enable" type="bool" value="false"/>
                </property>
                <property name="workspace1" type="empty">
                    <property name="color-style" type="int" value="0"/>
                    <property name="image-style" type="int" value="0"/>
                </property>
                <property name="workspace2" type="empty">
                    <property name="color-style" type="int" value="0"/>
                    <property name="image-style" type="int" value="0"/>
                </property>
                <property name="workspace3" type="empty">
                    <property name="color-style" type="int" value="0"/>
                    <property name="image-style" type="int" value="0"/>
                </property>
            </property>
            <property name="monitor0" type="empty">
                <property name="image-style" type="int" value="0"/>
                <property name="workspace0" type="empty">
                    <property name="color-style" type="int" value="0"/>
                    <property name="image-style" type="int" value="0"/>
                </property>
                <property name="workspace1" type="empty">
                    <property name="color-style" type="int" value="0"/>
                    <property name="image-style" type="int" value="0"/>
                </property>
                <property name="workspace2" type="empty">
                    <property name="color-style" type="int" value="0"/>
                    <property name="image-style" type="int" value="0"/>
                </property>
                <property name="workspace3" type="empty">
                    <property name="color-style" type="int" value="0"/>
                    <property name="image-style" type="int" value="0"/>
                </property>
            </property>
            <property name="monitoreDP-1" type="empty">
                <property name="workspace0" type="empty">
                    <property name="color-style" type="int" value="0"/>
                    <property name="image-style" type="int" value="0"/>
                    <property name="rgba1" type="array">
                        <value type="double" value="0.141176"/>
                        <value type="double" value="0.121569"/>
                        <value type="double" value="0.192157"/>
                        <value type="double" value="1.000000"/>
                    </property>
                    <property name="backdrop-cycle-enable" type="bool" value="false"/>
                </property>
                <property name="workspace1" type="empty">
                    <property name="color-style" type="int" value="0"/>
                    <property name="image-style" type="int" value="0"/>
                </property>
                <property name="workspace2" type="empty">
                    <property name="color-style" type="int" value="0"/>
                    <property name="image-style" type="int" value="0"/>
                </property>
                <property name="workspace3" type="empty">
                    <property name="color-style" type="int" value="0"/>
                    <property name="image-style" type="int" value="0"/>
                </property>
            </property>
        </property>
        <property name="single-workspace-mode" type="bool" value="true"/>
        <property name="single-workspace-number" type="int" value="0"/>
    </property>
    <property name="desktop-icons" type="empty">
        <property name="file-icons" type="empty">
            <property name="show-filesystem" type="bool" value="false"/>
            <property name="show-trash" type="bool" value="false"/>
            <property name="show-removable" type="bool" value="false"/>
            <property name="show-home" type="bool" value="false"/>
        </property>
    </property>
</channel>
XFCE4_DESKTOP_XML

    __file_write;

    FILE_PATH \
<<XFCE4_KEYBOARD_SHORTCUTS_XML
$home/.config/xfce4/xfconf/xfce-perchannel-xml/xfce4-keyboard-shortcuts.xml
XFCE4_KEYBOARD_SHORTCUTS_XML

    FILE \
<<'XFCE4_KEYBOARD_SHORTCUTS_XML'
<?xml version="1.0" encoding="UTF-8"?>

<channel name="xfce4-keyboard-shortcuts" version="1.0">
    <property name="commands" type="empty">
        <property name="default" type="empty">
            <property name="&lt;Alt&gt;F1" type="empty"/>
            <property name="&lt;Alt&gt;F2" type="empty">
                <property name="startup-notify" type="empty"/>
            </property>
            <property name="&lt;Alt&gt;F3" type="empty">
                <property name="startup-notify" type="empty"/>
            </property>
            <property name="&lt;Primary&gt;&lt;Alt&gt;Delete" type="empty"/>
            <property name="&lt;Primary&gt;&lt;Alt&gt;l" type="empty"/>
            <property name="&lt;Primary&gt;&lt;Alt&gt;t" type="empty"/>
            <property name="XF86Display" type="empty"/>
            <property name="&lt;Super&gt;p" type="empty"/>
            <property name="&lt;Primary&gt;Escape" type="empty"/>
            <property name="XF86WWW" type="empty"/>
            <property name="HomePage" type="empty"/>
            <property name="XF86Mail" type="empty"/>
            <property name="Print" type="empty"/>
            <property name="&lt;Alt&gt;Print" type="empty"/>
            <property name="&lt;Shift&gt;Print" type="empty"/>
            <property name="&lt;Super&gt;e" type="empty"/>
            <property name="&lt;Primary&gt;&lt;Alt&gt;f" type="empty"/>
            <property name="&lt;Primary&gt;&lt;Alt&gt;Escape" type="empty"/>
            <property name="&lt;Primary&gt;&lt;Shift&gt;Escape" type="empty"/>
            <property name="&lt;Super&gt;r" type="empty">
                <property name="startup-notify" type="empty"/>
            </property>
        </property>
        <property name="custom" type="empty">
            <property name="&lt;Alt&gt;F3" type="empty">
                <property name="startup-notify" type="bool" value="true"/>
            </property>
            <property name="&lt;Alt&gt;F2" type="empty">
                <property name="startup-notify" type="bool" value="true"/>
            </property>
            <property name="override" type="bool" value="true"/>
            <property name="Print" type="string" value="xfce4-screenshooter"/>
            <property name="&lt;Alt&gt;5" type="string" value="kitty"/>
        </property>
    </property>
    <property name="xfwm4" type="empty">
        <property name="default" type="empty">
            <property name="&lt;Alt&gt;Insert" type="empty"/>
            <property name="Escape" type="empty"/>
            <property name="Left" type="empty"/>
            <property name="Right" type="empty"/>
            <property name="Up" type="empty"/>
            <property name="Down" type="empty"/>
            <property name="&lt;Alt&gt;Tab" type="empty"/>
            <property name="&lt;Alt&gt;&lt;Shift&gt;Tab" type="empty"/>
            <property name="&lt;Alt&gt;Delete" type="empty"/>
            <property name="&lt;Primary&gt;&lt;Alt&gt;Down" type="empty"/>
            <property name="&lt;Primary&gt;&lt;Alt&gt;Left" type="empty"/>
            <property name="&lt;Shift&gt;&lt;Alt&gt;Page_Down" type="empty"/>
            <property name="&lt;Alt&gt;F4" type="empty"/>
            <property name="&lt;Alt&gt;F6" type="empty"/>
            <property name="&lt;Alt&gt;F7" type="empty"/>
            <property name="&lt;Alt&gt;F8" type="empty"/>
            <property name="&lt;Alt&gt;F9" type="empty"/>
            <property name="&lt;Alt&gt;F10" type="empty"/>
            <property name="&lt;Alt&gt;F11" type="empty"/>
            <property name="&lt;Alt&gt;F12" type="empty"/>
            <property name="&lt;Primary&gt;&lt;Shift&gt;&lt;Alt&gt;Left" type="empty"/>
            <property name="&lt;Primary&gt;&lt;Alt&gt;End" type="empty"/>
            <property name="&lt;Primary&gt;&lt;Alt&gt;Home" type="empty"/>
            <property name="&lt;Primary&gt;&lt;Shift&gt;&lt;Alt&gt;Right" type="empty"/>
            <property name="&lt;Primary&gt;&lt;Shift&gt;&lt;Alt&gt;Up" type="empty"/>
            <property name="&lt;Primary&gt;&lt;Alt&gt;KP_1" type="empty"/>
            <property name="&lt;Primary&gt;&lt;Alt&gt;KP_2" type="empty"/>
            <property name="&lt;Primary&gt;&lt;Alt&gt;KP_3" type="empty"/>
            <property name="&lt;Primary&gt;&lt;Alt&gt;KP_4" type="empty"/>
            <property name="&lt;Primary&gt;&lt;Alt&gt;KP_5" type="empty"/>
            <property name="&lt;Primary&gt;&lt;Alt&gt;KP_6" type="empty"/>
            <property name="&lt;Primary&gt;&lt;Alt&gt;KP_7" type="empty"/>
            <property name="&lt;Primary&gt;&lt;Alt&gt;KP_8" type="empty"/>
            <property name="&lt;Primary&gt;&lt;Alt&gt;KP_9" type="empty"/>
            <property name="&lt;Alt&gt;space" type="empty"/>
            <property name="&lt;Shift&gt;&lt;Alt&gt;Page_Up" type="empty"/>
            <property name="&lt;Primary&gt;&lt;Alt&gt;Right" type="empty"/>
            <property name="&lt;Primary&gt;&lt;Alt&gt;d" type="empty"/>
            <property name="&lt;Primary&gt;&lt;Alt&gt;Up" type="empty"/>
            <property name="&lt;Super&gt;Tab" type="empty"/>
            <property name="&lt;Primary&gt;F1" type="empty"/>
            <property name="&lt;Primary&gt;F2" type="empty"/>
            <property name="&lt;Primary&gt;F3" type="empty"/>
            <property name="&lt;Primary&gt;F4" type="empty"/>
            <property name="&lt;Primary&gt;F5" type="empty"/>
            <property name="&lt;Primary&gt;F6" type="empty"/>
            <property name="&lt;Primary&gt;F7" type="empty"/>
            <property name="&lt;Primary&gt;F8" type="empty"/>
            <property name="&lt;Primary&gt;F9" type="empty"/>
            <property name="&lt;Primary&gt;F10" type="empty"/>
            <property name="&lt;Primary&gt;F11" type="empty"/>
            <property name="&lt;Primary&gt;F12" type="empty"/>
            <property name="&lt;Super&gt;KP_Left" type="empty"/>
            <property name="&lt;Super&gt;KP_Right" type="empty"/>
            <property name="&lt;Super&gt;KP_Up" type="empty"/>
            <property name="&lt;Super&gt;KP_Down" type="empty"/>
            <property name="&lt;Super&gt;KP_Page_Up" type="empty"/>
            <property name="&lt;Super&gt;KP_Home" type="empty"/>
            <property name="&lt;Super&gt;KP_End" type="empty"/>
            <property name="&lt;Super&gt;KP_Next" type="empty"/>
        </property>
        <property name="custom" type="empty">
            <property name="&lt;Primary&gt;&lt;Shift&gt;&lt;Alt&gt;Left" type="string" value="move_window_left_key"/>
            <property name="&lt;Alt&gt;Tab" type="string" value="cycle_windows_key"/>
            <property name="&lt;Primary&gt;&lt;Shift&gt;&lt;Alt&gt;Right" type="string" value="move_window_right_key"/>
            <property name="&lt;Primary&gt;&lt;Alt&gt;d" type="string" value="show_desktop_key"/>
            <property name="&lt;Alt&gt;&lt;Shift&gt;Tab" type="string" value="cycle_reverse_windows_key"/>
            <property name="&lt;Primary&gt;&lt;Shift&gt;&lt;Alt&gt;Up" type="string" value="move_window_up_key"/>
            <property name="override" type="bool" value="true"/>
            <property name="&lt;Alt&gt;F1" type="string" value="fullscreen_key"/>
            <property name="&lt;Alt&gt;F2" type="string" value="maximize_window_key"/>
            <property name="&lt;Alt&gt;F3" type="string" value="hide_window_key"/>
            <property name="&lt;Alt&gt;F5" type="string" value="resize_window_key"/>
            <property name="&lt;Alt&gt;F6" type="string" value="move_window_key"/>
            <property name="&lt;Alt&gt;F4" type="string" value="close_window_key"/>
        </property>
    </property>
    <property name="providers" type="array">
        <value type="string" value="xfwm4"/>
        <value type="string" value="commands"/>
    </property>
</channel>
XFCE4_KEYBOARD_SHORTCUTS_XML

    __file_write;

    FILE_PATH \
<<XFCE4_NOTIFYD_XML
$home/.config/xfce4/xfconf/xfce-perchannel-xml/xfce4-notifyd.xml
XFCE4_NOTIFYD_XML

    FILE \
<<'XFCE4_NOTIFYD_XML'
<?xml version="1.0" encoding="UTF-8"?>

<channel name="xfce4-notifyd" version="1.0">
    <property name="primary-monitor" type="uint" value="0"/>
    <property name="notify-location" type="uint" value="2"/>
    <property name="log-level" type="uint" value="0"/>
    <property name="log-level-apps" type="uint" value="0"/>
    <property name="applications" type="empty">
        <property name="known_applications" type="array">
            <value type="string" value="Xfce volume control"/>
            <value type="string" value="xfce4-power-manager"/>
            <value type="string" value="xfce4-settings-helper"/>
        </property>
    </property>
</channel>
XFCE4_NOTIFYD_XML

    __file_write;

    FILE_PATH \
<<XFCE4_PANEL_XML
$home/.config/xfce4/xfconf/xfce-perchannel-xml/xfce4-panel.xml
XFCE4_PANEL_XML

    FILE \
<<'XFCE4_PANEL_XML'
<?xml version="1.0" encoding="UTF-8"?>

<channel name="xfce4-panel" version="1.0">
    <property name="configver" type="int" value="2"/>
    <property name="panels" type="array">
        <value type="int" value="1"/>
        <property name="panel-1" type="empty">
            <property name="icon-size" type="uint" value="0"/>
            <property name="length" type="uint" value="100"/>
            <property name="mode" type="uint" value="2"/>
            <property name="plugin-ids" type="array">
                <value type="int" value="1"/>
                <value type="int" value="2"/>
                <value type="int" value="3"/>
                <value type="int" value="4"/>
                <value type="int" value="5"/>
                <value type="int" value="6"/>
                <value type="int" value="7"/>
                <value type="int" value="8"/>
                <value type="int" value="9"/>
                <value type="int" value="10"/>
                <value type="int" value="11"/>
                <value type="int" value="12"/>
            </property>
            <property name="position" type="string" value="p=6;x=0;y=0"/>
            <property name="position-locked" type="bool" value="true"/>
            <property name="size" type="uint" value="31"/>
            <property name="length-adjust" type="bool" value="true"/>
            <property name="disable-struts" type="bool" value="false"/>
        </property>
        <property name="dark-mode" type="bool" value="false"/>
    </property>
    <property name="plugins" type="empty">
        <property name="clipman" type="empty">
            <property name="settings" type="empty">
                <property name="max-texts-in-history" type="uint" value="20"/>
            </property>
            <property name="tweaks" type="empty">
                <property name="never-confirm-history-clear" type="bool" value="true"/>
                <property name="popup-at-pointer" type="bool" value="false"/>
            </property>
        </property>
        <property name="plugin-1" type="string" value="clock">
            <property name="mode" type="uint" value="2"/>
            <property name="digital-format" type="string" value="&lt;span font=&quot;9&quot;&gt;%R&lt;/span&gt;"/>
            <property name="tooltip-format" type="string" value="%A %d %B %Y"/>
        </property>
        <property name="plugin-2" type="string" value="launcher">
            <property name="items" type="array">
                <value type="string" value="15990473633.desktop"/>
            </property>
        </property>
        <property name="plugin-3" type="string" value="launcher">
            <property name="items" type="array">
                <value type="string" value="15990556735.desktop"/>
            </property>
        </property>
        <property name="plugin-4" type="string" value="separator">
            <property name="expand" type="bool" value="true"/>
            <property name="style" type="uint" value="0"/>
        </property>
        <property name="plugin-5" type="string" value="tasklist">
            <property name="flat-buttons" type="bool" value="false"/>
            <property name="show-handle" type="bool" value="false"/>
            <property name="show-labels" type="bool" value="false"/>
        </property>
        <property name="plugin-6" type="string" value="separator">
            <property name="expand" type="bool" value="false"/>
            <property name="style" type="uint" value="0"/>
        </property>
        <property name="plugin-7" type="string" value="xkb">
            <property name="group-policy" type="uint" value="0"/>
        </property>
        <property name="plugin-8" type="string" value="xfce4-clipman-plugin"/>
        <property name="plugin-9" type="string" value="systray">
            <property name="size-max" type="uint" value="22"/>
            <property name="square-icons" type="bool" value="true"/>
        </property>
        <property name="plugin-10" type="string" value="power-manager-plugin"/>
        <property name="plugin-11" type="string" value="pulseaudio">
            <property name="enable-keyboard-shortcuts" type="bool" value="true"/>
        </property>
        <property name="plugin-12" type="string" value="whiskermenu">
            <property name="mode" type="uint" value="2"/>
        </property>
    </property>
</channel>
XFCE4_PANEL_XML

    __file_write;

    FILE_PATH \
<<XFCE4_POWER_MANAGER_XML
$home/.config/xfce4/xfconf/xfce-perchannel-xml/xfce4-power-manager.xml
XFCE4_POWER_MANAGER_XML

    FILE \
<<'XFCE4_POWER_MANAGER_XML'
<?xml version="1.0" encoding="UTF-8"?>

<channel name="xfce4-power-manager" version="1.0">
    <property name="xfce4-power-manager" type="empty">
        <property name="show-tray-icon" type="bool" value="false"/>
        <property name="brightness-switch-restore-on-exit" type="int" value="0"/>
        <property name="brightness-switch" type="int" value="0"/>
        <property name="show-panel-label" type="int" value="0"/>
        <property name="lid-action-on-battery" type="uint" value="3"/>
        <property name="logind-handle-lid-switch" type="bool" value="false"/>
        <property name="lid-action-on-ac" type="uint" value="3"/>
        <property name="inactivity-sleep-mode-on-battery" type="uint" value="1"/>
        <property name="brightness-on-battery" type="uint" value="9"/>
        <property name="brightness-on-ac" type="uint" value="9"/>
        <property name="brightness-level-on-battery" type="uint" value="1"/>
        <property name="brightness-level-on-ac" type="uint" value="1"/>
        <property name="blank-on-battery" type="int" value="0"/>
        <property name="dpms-on-battery-sleep" type="uint" value="0"/>
        <property name="dpms-on-battery-off" type="uint" value="0"/>
        <property name="dpms-on-ac-off" type="uint" value="0"/>
        <property name="blank-on-ac" type="int" value="0"/>
        <property name="dpms-on-ac-sleep" type="uint" value="0"/>
        <property name="general-notification" type="bool" value="false"/>
        <property name="lock-screen-suspend-hibernate" type="bool" value="false"/>
        <property name="dpms-enabled" type="bool" value="false"/>
        <property name="brightness-exponential" type="bool" value="false"/>
        <property name="brightness-step-count" type="uint" value="20"/>
        <property name="critical-power-level" type="uint" value="40"/>
        <property name="presentation-mode" type="bool" value="true"/>
    </property>
</channel>
XFCE4_POWER_MANAGER_XML

    __file_write;

    FILE_PATH \
<<XFCE4_SCREENSAVER_XML
$home/.config/xfce4/xfconf/xfce-perchannel-xml/xfce4-screensaver.xml
XFCE4_SCREENSAVER_XML

    FILE \
<<'XFCE4_SCREENSAVER_XML'
<?xml version="1.0" encoding="UTF-8"?>

<channel name="xfce4-screensaver" version="1.0">
    <property name="saver" type="empty">
        <property name="mode" type="int" value="2"/>
        <property name="idle-activation" type="empty">
            <property name="enabled" type="bool" value="false"/>
            <property name="delay" type="int" value="5"/>
        </property>
        <property name="enabled" type="bool" value="true"/>
        <property name="themes" type="empty">
            <property name="list" type="array">
                <value type="string" value="screensavers-xfce-popsquares"/>
            </property>
        </property>
    </property>
    <property name="lock" type="empty">
        <property name="enabled" type="bool" value="true"/>
    </property>
</channel>
XFCE4_SCREENSAVER_XML

    __file_write;

    FILE_PATH \
<<XFCE4_SCREENSHOOTER_XML
$home/.config/xfce4/xfconf/xfce-perchannel-xml/xfce4-screenshooter.xml
XFCE4_SCREENSHOOTER_XML

    FILE \
<<'XFCE4_SCREENSHOOTER_XML'
<?xml version="1.0" encoding="UTF-8"?>

<channel name="xfce4-screenshooter" version="1.0">
    <property name="actions" type="empty">
        <property name="actions" type="int" value="0"/>
    </property>
</channel>
XFCE4_SCREENSHOOTER_XML

    __file_write;

    FILE_PATH \
<<XFCE4_SESSION_XML
$home/.config/xfce4/xfconf/xfce-perchannel-xml/xfce4-session.xml
XFCE4_SESSION_XML

    FILE \
<<'XFCE4_SESSION_XML'
<?xml version="1.0" encoding="UTF-8"?>

<channel name="xfce4-session" version="1.0">
    <property name="general" type="empty">
        <property name="FailsafeSessionName" type="empty"/>
        <property name="LockCommand" type="empty"/>
        <property name="SessionName" type="string" value="Default"/>
        <property name="SaveOnExit" type="bool" value="false"/>
    </property>
    <property name="sessions" type="empty">
        <property name="Failsafe" type="empty">
            <property name="IsFailsafe" type="empty"/>
            <property name="Count" type="empty"/>
            <property name="Client0_Command" type="empty"/>
            <property name="Client0_Priority" type="empty"/>
            <property name="Client0_PerScreen" type="empty"/>
            <property name="Client1_Command" type="empty"/>
            <property name="Client1_Priority" type="empty"/>
            <property name="Client1_PerScreen" type="empty"/>
            <property name="Client2_Command" type="empty"/>
            <property name="Client2_Priority" type="empty"/>
            <property name="Client2_PerScreen" type="empty"/>
            <property name="Client3_Command" type="empty"/>
            <property name="Client3_Priority" type="empty"/>
            <property name="Client3_PerScreen" type="empty"/>
            <property name="Client4_Command" type="empty"/>
            <property name="Client4_Priority" type="empty"/>
            <property name="Client4_PerScreen" type="empty"/>
        </property>
    </property>
    <property name="shutdown" type="empty">
        <property name="LockScreen" type="bool" value="true"/>
    </property>
</channel>
XFCE4_SESSION_XML

    __file_write;

    FILE_PATH \
<<XFWM4_XML
$home/.config/xfce4/xfconf/xfce-perchannel-xml/xfwm4.xml
XFWM4_XML

    FILE \
<<'XFWM4_XML'
<?xml version="1.0" encoding="UTF-8"?>

<channel name="xfwm4" version="1.0">
    <property name="general" type="empty">
        <property name="activate_action" type="string" value="bring"/>
        <property name="borderless_maximize" type="bool" value="true"/>
        <property name="box_move" type="bool" value="false"/>
        <property name="box_resize" type="bool" value="false"/>
        <property name="button_layout" type="string" value="O|SHMC"/>
        <property name="button_offset" type="int" value="0"/>
        <property name="button_spacing" type="int" value="0"/>
        <property name="click_to_focus" type="bool" value="true"/>
        <property name="cycle_apps_only" type="bool" value="false"/>
        <property name="cycle_draw_frame" type="bool" value="true"/>
        <property name="cycle_raise" type="bool" value="false"/>
        <property name="cycle_hidden" type="bool" value="true"/>
        <property name="cycle_minimum" type="bool" value="true"/>
        <property name="cycle_preview" type="bool" value="true"/>
        <property name="cycle_tabwin_mode" type="int" value="0"/>
        <property name="cycle_workspaces" type="bool" value="false"/>
        <property name="double_click_action" type="string" value="maximize"/>
        <property name="double_click_distance" type="int" value="5"/>
        <property name="double_click_time" type="int" value="250"/>
        <property name="easy_click" type="string" value="None"/>
        <property name="focus_delay" type="int" value="250"/>
        <property name="focus_hint" type="bool" value="true"/>
        <property name="focus_new" type="bool" value="true"/>
        <property name="frame_opacity" type="int" value="100"/>
        <property name="frame_border_top" type="int" value="0"/>
        <property name="full_width_title" type="bool" value="true"/>
        <property name="horiz_scroll_opacity" type="bool" value="false"/>
        <property name="inactive_opacity" type="int" value="100"/>
        <property name="maximized_offset" type="int" value="0"/>
        <property name="mousewheel_rollup" type="bool" value="true"/>
        <property name="move_opacity" type="int" value="100"/>
        <property name="placement_mode" type="string" value="mouse"/>
        <property name="placement_ratio" type="int" value="46"/>
        <property name="popup_opacity" type="int" value="100"/>
        <property name="prevent_focus_stealing" type="bool" value="false"/>
        <property name="raise_delay" type="int" value="250"/>
        <property name="raise_on_click" type="bool" value="true"/>
        <property name="raise_on_focus" type="bool" value="false"/>
        <property name="raise_with_any_button" type="bool" value="true"/>
        <property name="repeat_urgent_blink" type="bool" value="false"/>
        <property name="resize_opacity" type="int" value="100"/>
        <property name="scroll_workspaces" type="bool" value="true"/>
        <property name="shadow_delta_height" type="int" value="0"/>
        <property name="shadow_delta_width" type="int" value="0"/>
        <property name="shadow_delta_x" type="int" value="0"/>
        <property name="shadow_delta_y" type="int" value="-3"/>
        <property name="shadow_opacity" type="int" value="50"/>
        <property name="show_app_icon" type="bool" value="false"/>
        <property name="show_dock_shadow" type="bool" value="false"/>
        <property name="show_frame_shadow" type="bool" value="false"/>
        <property name="show_popup_shadow" type="bool" value="false"/>
        <property name="snap_resist" type="bool" value="false"/>
        <property name="snap_to_border" type="bool" value="true"/>
        <property name="snap_to_windows" type="bool" value="false"/>
        <property name="snap_width" type="int" value="10"/>
        <property name="vblank_mode" type="string" value="auto"/>
        <property name="theme" type="string" value="Arc-Dark-solid"/>
        <property name="tile_on_move" type="bool" value="true"/>
        <property name="title_alignment" type="string" value="center"/>
        <property name="title_font" type="string" value="Sans Bold 9"/>
        <property name="title_horizontal_offset" type="int" value="0"/>
        <property name="titleless_maximize" type="bool" value="false"/>
        <property name="title_shadow_active" type="string" value="false"/>
        <property name="title_shadow_inactive" type="string" value="false"/>
        <property name="title_vertical_offset_active" type="int" value="0"/>
        <property name="title_vertical_offset_inactive" type="int" value="0"/>
        <property name="toggle_workspaces" type="bool" value="false"/>
        <property name="unredirect_overlays" type="bool" value="true"/>
        <property name="urgent_blink" type="bool" value="false"/>
        <property name="use_compositing" type="bool" value="true"/>
        <property name="workspace_count" type="int" value="1"/>
        <property name="wrap_cycle" type="bool" value="true"/>
        <property name="wrap_layout" type="bool" value="true"/>
        <property name="wrap_resistance" type="int" value="10"/>
        <property name="wrap_windows" type="bool" value="true"/>
        <property name="wrap_workspaces" type="bool" value="false"/>
        <property name="zoom_desktop" type="bool" value="true"/>
        <property name="workspace_names" type="array">
            <value type="string" value="Workspace 1"/>
            <value type="string" value="Workspace 2"/>
            <value type="string" value="Workspace 3"/>
            <value type="string" value="Workspace 4"/>
        </property>
        <property name="cycle_minimized" type="bool" value="false"/>
        <property name="zoom_pointer" type="bool" value="true"/>
    </property>
</channel>
XFWM4_XML

    __file_write;

    FILE_PATH \
<<XSETTINGS_XML
$home/.config/xfce4/xfconf/xfce-perchannel-xml/xsettings.xml
XSETTINGS_XML

    FILE \
<<'XSETTINGS_XML'
<?xml version="1.0" encoding="UTF-8"?>

<channel name="xsettings" version="1.0">
    <property name="Net" type="empty">
        <property name="ThemeName" type="string" value="Arc-Dark-solid"/>
        <property name="IconThemeName" type="string" value="Papirus-Dark"/>
        <property name="DoubleClickTime" type="empty"/>
        <property name="DoubleClickDistance" type="empty"/>
        <property name="DndDragThreshold" type="empty"/>
        <property name="CursorBlink" type="empty"/>
        <property name="CursorBlinkTime" type="empty"/>
        <property name="SoundThemeName" type="empty"/>
        <property name="EnableEventSounds" type="empty"/>
        <property name="EnableInputFeedbackSounds" type="empty"/>
    </property>
    <property name="Xft" type="empty">
        <property name="DPI" type="empty"/>
        <property name="Antialias" type="int" value="1"/>
        <property name="Hinting" type="int" value="1"/>
        <property name="HintStyle" type="string" value="hintfull"/>
        <property name="RGBA" type="string" value="rgb"/>
    </property>
    <property name="Gtk" type="empty">
        <property name="CanChangeAccels" type="empty"/>
        <property name="ColorPalette" type="empty"/>
        <property name="FontName" type="string" value="System-ui 12"/>
        <property name="MonospaceFontName" type="empty"/>
        <property name="IconSizes" type="empty"/>
        <property name="KeyThemeName" type="empty"/>
        <property name="ToolbarStyle" type="empty"/>
        <property name="ToolbarIconSize" type="empty"/>
        <property name="MenuImages" type="empty"/>
        <property name="ButtonImages" type="empty"/>
        <property name="MenuBarAccel" type="empty"/>
        <property name="CursorThemeName" type="string" value="Breeze"/>
        <property name="CursorThemeSize" type="empty"/>
        <property name="DecorationLayout" type="empty"/>
        <property name="DialogsUseHeader" type="empty"/>
        <property name="TitlebarMiddleClick" type="empty"/>
    </property>
    <property name="Gdk" type="empty">
        <property name="WindowScalingFactor" type="empty"/>
    </property>
    <property name="Xfce" type="empty">
        <property name="SyncThemes" type="bool" value="true"/>
    </property>
</channel>
XSETTINGS_XML

    __file_write;
}

_xorg_conf() {
    FILE_PATH \
<<_XINITRC
$home/.xinitrc
_XINITRC

    FILE \
<<'_XINITRC'
#!/bin/sh

if [ -d /etc/X11/xinit/xinitrc.d ]; then
    for f in /etc/X11/xinit/xinitrc.d/?*.sh; do
        [ -x "$f" ] && . "$f"
    done

    unset f
fi

sh -c \
    " \
    sleep 30; \
    xset -dpms; \
    xset s off; \
    xset m 0/0 0; \
_XINITRC

    if [ "$m533ia" = 1 ]; then
        FILE \
<<'_XINITRC'
    xinput set-prop 'ELAN1300:00 04F3:3104 Touchpad' \
                    'libinput Tapping Enabled' 1; \
    xrandr --output eDP-1 --set vrr_capable 1; \
    xrandr --output eDP-1 --set 'scaling mode' 'Full aspect'; \
_XINITRC
    fi

    FILE \
<<'_XINITRC'
    " &
_XINITRC

    if [ "$wm" = xfce4 ]; then
        FILE \
<<'_XINITRC'

exec startxfce4
_XINITRC
    fi

    __file_write;
}

#! .desc:
# Assert the passed arguments match BRE: [0-9A-Za-z_-]
#! .params:
# <"$1"+> - argument
#! .gives:
# (0) <"$_arg"> - the last argument
# (1) <"$_arg"> - the bad argument
#! .rc:
# (0) yes
# (1) no
# (255) bad input
#.
main_assert_args() {
    args_min 1 "$#" || return 255

    for _arg in "$@"; do
        [ "$_arg" ] || return 255

        case "$_arg" in
            *[!0-9A-Za-z_-]*) return 1 ;;
        esac
    done
}

#! .desc:
# Assert the passed arguments are valid operations
#! .params:
# <"$1"+> - operation
#! .uses:
# <ops> $ - the list of operations
#! .gives:
# (0) <"$_opd"> - the last operation
# (1) <"$_opd"> - the bad operation
#! .rc:
# (0) yes
# (1) no
# (255) bad input
#.
main_assert_ops() {
    args_min 1 "$#" || return 255

    for _opd in "$@"; do
        [ "$_opd" ] || return 255

        case "$ops" in
            "$_opd "* | *" $_opd" | *" $_opd "*) : ;;
            *) return 1 ;;
        esac
    done
}

main_func_env_cleanup() {
    FILE=; FILE_PATH_TARGET=; umask 022
    LOG_clear; rm -rf "${tmpd:?}"/*
}

main_rm_tmp() {
    if dir "$tmpd" || file "$tmpf"; then
        rm -rf "$tmpd" "$tmpf"
    fi
}

main_set_opd() {
    opd="_$1"

    if str '-' "$1"; then
        replchars '-' '_' "$1"
        opd="_$_str"
    fi
}

main_tmpd() {
    if [ "$fatal" = 1 ]; then
        if ! mkdir -p "$tmpd" 2> /dev/null; then
            errF "$?" - "Cannot create tmpd: $tmpd"
        fi
    else
        mkdir -p "$tmpd" 2> /dev/null
    fi
}

main_tmpf() {
    if [ "$fatal" = 1 ]; then
        if ! { : > "$tmpf"; } 2> /dev/null; then
            errF "$?" - "Cannot create tmpf: $tmpf"
        fi

        if ! chmod 0600 "$tmpf" 2> /dev/null; then
            errF "$?" - "Permissions error on tmpf: $tmpf"
        fi
    else
        { : > "$tmpf"; chmod 0600 "$tmpf"; } 2> /dev/null
    fi
}

err_handler() {
    main_rm_tmp;

    # These return codes signify that output has already been written and
    # exit has already been invoked. (pre-func)
    # Executed cleanup above, no more fuss needed here.
    case $1 in
        201|202|217|220|221|222|230|231|232|233|234|235)
            err -r -1 "${opd}(): Failed. (RC = $1)"

            return 0
        ;;
    esac

    if [ "$1" -eq 130 ]; then
        trap - TERM EXIT
        info -y - "${LF}Operation cancelled: ${opd}()"
        exit 130
    fi

    if [ "$1" -eq 127 ]; then
        errF 127 - "Operation unhandled: ${opd}()"
    fi

    errF "$1" -1 "${opd}(): Unhandled error. (RC = $1)"
}

main() {
    # Utility control switches
    # Compare the real file against our and do not write if same:
    avoid_write=1
    # Backup locations before respective write/delete:
    backup=0
    # Force successful operation at all costs (file overwrite/removal):
    force=0
    # Logging; recommended 1:
    logging=1

    # Utility device switches
    # ASUS VivoBook S15 X521IA-M533IA (AMD):
    m533ia=1

    # Utility OS switches
    # Arch Linux system:
    arch_linux=1

    # Utility software switches
    # Configure audio configs for highest possible quality:
    audio_hq=0
    # Bluetooth support
    bluetooth=1
    # Web browser; currently supported: firefox, none
    browser='firefox'
    # DNS; currently supported: localhost, none
    dns='localhost'
    # Dedicated DNS (stub) resolver; currently supported: dnsmasq
    dns0='dnsmasq'
    # Configure specific applications to be suited for gaming
    gaming=0
    # Init system; currently supported: systemd
    init='systemd'
    # Configure and prefer IPv6 over IPv4:
    ipv6=0
    # QT theme engine; currently supported: kvantum, none
    qt_theme='kvantum'
    # Display server; currently supported: wayland, x11, none
    server='wayland'
    # Desktop environment / window manager; currently supported: sway, xfce4,
    # none
    wm='sway'

    # Utility location switches
    # Bulgaria:
    bg=0
    # Germany:
    de=1

    # Data
    user='mscalindt'

    # Locations
    home='/home/mscalindt'
    efi_mnt='/efi'
    arch_mirlist='/etc/pacman.d/mirrorlist'
    polkit_agent='/usr/lib/polkit-gnome/polkit-gnome-authentication-agent-1'

    # Operations
    ops=
    ops="$ops alsa-conf"
    ops="$ops autostart"
    ops="$ops bash-conf"
    ops="$ops bluez-conf"
    ops="$ops clk-sync"
    ops="$ops conf-1"
    ops="$ops conf-2"
    ops="$ops conf-3"
    ops="$ops conf-4"
    ops="$ops dhcpcd-conf"
    ops="$ops dnsmasq-conf"
    ops="$ops doas-conf"
    ops="$ops env"
    ops="$ops face-bin"
    ops="$ops featherpad-conf"
    ops="$ops firefox-conf"
    ops="$ops fontconfig-conf"
    ops="$ops fuse-conf"
    ops="$ops gai-conf"
    ops="$ops git-conf"
    ops="$ops gov-performance"
    ops="$ops gov-schedutil"
    ops="$ops grub grub-conf"
    ops="$ops gtk-conf"
    ops="$ops hostname"
    ops="$ops hosts"
    ops="$ops imv-conf"
    ops="$ops initramfs-conf"
    ops="$ops iwd-conf"
    ops="$ops kitty-conf"
    ops="$ops kvantum-conf"
    ops="$ops locale"
    ops="$ops makepkg-conf"
    ops="$ops moc-conf"
    ops="$ops modprobe-conf"
    ops="$ops mpv-conf"
    ops="$ops mutt-conf"
    ops="$ops nano-conf"
    ops="$ops nvram-clr"
    ops="$ops openal-conf"
    ops="$ops pacman-conf"
    ops="$ops pam-conf"
    ops="$ops pipewire-conf"
    ops="$ops pulseaudio-conf"
    ops="$ops pipewire-media-session-conf"
    ops="$ops ranger-conf"
    ops="$ops reflector"
    ops="$ops resolv-conf"
    ops="$ops sh"
    ops="$ops sudo-conf"
    ops="$ops sway-conf"
    ops="$ops swaylock-conf"
    ops="$ops sysctl-conf"
    ops="$ops tz"
    ops="$ops wireplumber-conf"
    ops="$ops xdg-conf"
    ops="$ops xfce4-conf"
    ops="$ops xorg-conf"
    ops="${ops# }"

    # Utility env switches
    # Enable/disable env error checking:
    fatal=0

    # Utility internal locations
    # Temporary per-function dir (cleared on func exit):
    tmpd="${TMPDIR:-/tmp}/syscfg_tmpd"
    # Temporary per-function file (cleared on func exit):
    tmpf="${TMPDIR:-/tmp}/syscfg_tmpf"

    # Enable avoid_write from cmdline: ^AE as $1
    # Enable audio_hq from cmdline:    ^AQ as $1
    # Enable backup from cmdline:      ^BP as $1
    # Enable force from cmdline:       ^FE as $1
    # Enable gaming from cmdline:      ^GG as $1
    # Enable ipv6 from cmdline:        ^I6 as $1
    # Enable logging from cmdline:     ^LG as $1
    while :; do case "$1" in
        '^AE') avoid_write=1; shift && continue ;;
        '^AQ') audio_hq=1; shift && continue ;;
        '^BP') backup=1; shift && continue ;;
        '^FE') force=1; shift && continue ;;
        '^GG') gaming=1; shift && continue ;;
        '^I6') ipv6=1; shift && continue ;;
        '^LG') logging=1; shift && continue ;;
        *) break ;;
    esac done

    readonly fatal tmpd tmpf avoid_write backup force logging m533ia \
             arch_linux audio_hq bluetooth browser dns dns0 gaming init ipv6 \
             qt_theme server wm bg de user home efi_mnt arch_mirlist \
             polkit_agent ops

    { args_min 1 "$#" && main_assert_ops "$@"; } || {
        if [ "$#" -eq 0 ]; then
            err -r -1 'No operation has been specified.'
        else
            err -r -1 "Unrecognized operation: '$_opd'"
        fi

        ifs_map "$ops" info -w -1
        info -w -1 'SWITCH: avoid_write ^AE'
        info -w -1 'SWITCH: audio_hq ^AQ'
        info -w -1 'SWITCH: backup ^BP'
        info -w -1 'SWITCH: force ^FE'
        info -w -1 'SWITCH: gaming ^GG'
        info -w -1 'SWITCH: ipv6 ^I6'
        info -w -1 'SWITCH: logging ^LG'

        exit 2
    }

    if ! main_assert_args "$@"; then
        err -r - "Bad argument: '$_arg'."
        info -w - "Allowed characters: 0-9A-Za-z_-"
        exit 2
    fi

    [ "$(id -u)" = 0 ] || {
        errF 1 - 'Missing root rights.'
    }

    main_tmpd;
    main_tmpf;

    LC_ALL=C; export LC_ALL
    LF='
'

    while [ "$1" ]; do
        main_set_opd "$1"

        # use '|| :' to validate a command failure
        trap "err_handler \$?" INT TERM EXIT
        set -e

        eval "info -be -1 \"$1 -> ${opd}()\"; $opd"
        RC=$?

        main_func_env_cleanup;

        trap - INT TERM EXIT
        set +e

        info -g -1 'Done! ()'

        shift
    done

    main_rm_tmp;

    return "$RC"
}

main "$@"
